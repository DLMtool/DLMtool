[
["index.html", "Data-Limited Methods Toolkit (DLMtool) Chapter 1 Introduction 1.1 Data-Limited Methods Toolkit 1.2 Management Strategy Evaluation 1.3 How does Management Strategy Evaluation Differ from Stock Assessment? 1.4 Overview of the User Guide 1.5 Acknowledgements 1.6 Bug Reports 1.7 Version Notes", " Data-Limited Methods Toolkit (DLMtool) User Guide 2017-10-12 Chapter 1 Introduction As many as 90% of the world’s fish populations have insufficient data to conduct a conventional stock assessment (Costello et al. 2012). Although a wide range of data-limited management procedures (MPs; stock assessments, harvest control rules) have been described in the primary and gray literature (Newman et al. 2015), they have not been readily available or easily tested to determine their efficacy for specific fisheries. For many fishery managers and stakeholders, the path forward has been unclear and laden with myriad questions, such as: How do these MPs perform comparatively? What are the performance trade-offs? What MPs are appropriate for a given fishery? What is the value of collecting additional data? What is an appropriate stop-gap management approach as more data are collected? 1.1 Data-Limited Methods Toolkit The Data-Limited Methods Toolkit (DLMtool), a collaboration between the University of British Columbia’s (UBC) Institute for Oceans and Fisheries and the Natural Resources Defense Council (NRDC), is aimed at addressing these questions by offering a powerful, transparent approach to comparing, selecting, and applying various data-limited management methods. DLMtool uses management strategy evaluation (MSE) and parallel computing to make powerful diagnostics accessible. A streamlined command structure and operating model builder allow for rapid simulation testing and graphing of results. The package is relatively easy to use for those inexperienced in R, however, complete access and control is available to more experienced users. While DLMtool includes over 89 management procedures it is also designed to be extensible in order to encourage the development and testing of new methods. The package is structured such that the same management methods that are tested by the MSE can be applied to provide management recommendations from real data. Easy incorporation of real data is a central advantage of the software. A set of related functions automatically detect what management procedures can be applied with currently available data, and what additional data are needed to use currently unavailable methods. The Toolkit has been developed in collaboration with fisheries scientists around the globe. New features and functions have been added to the software package to meet the needs or the particular fisheries and management contexts where it has been applied. To date, the Toolkit has been used for management or academic research in over 25 fisheries, including by the National Marine Fisheries Service in the U.S. Mid-Atlantic and Caribbean regions, and by the California Department of Fish &amp; Wildlife. 1.2 Management Strategy Evaluation At the core of the Data-Limited Methods Toolkit is an integrated management strategy evaluation (MSE) function. Management strategy evaluation is a computer simulation approach for testing prospective management options over a wide range of possible realities for the fishery and the population. Ideally, management options can be identified that are robust and perform well over all credible scenarios for the fishery. It is extremely difficult, perhaps impossible, to conduct large-scale experiments to evaluate directly the trade-offs associated with fisheries management. Even among well-studied fisheries, considerable uncertainty often exists regarding stock status and the dynamics of the fishery, and it can be difficult to attribute particular outcomes to distinct management actions. The mathematical description of fish population dynamics and the interaction with different exploitation patterns, first developed by Beverton and Holt (1957), together with the advent of powerful and affordable computers, has allowed the development of the MSE approach (Butterworth, 2007; Punt et al. 2014). Management strategy evaluation was originally developed by the International Whaling Commission as a tool to evaluate the various trade-offs involved the management of marine mammals, and to guide the decision-making process for selecting an appropriate management strategy. Since its development in the mid-1970s, MSE has become widely used in fisheries science and is routinely applied to evaluate the trade-offs in alternative management strategies of many of the world’s fisheries. An MSE is usually comprised of three key components: an operating model that is used to simulate the stock and fleet dynamics, an assessment method and harvest control rule model (interchangeably referred to as management procedures, or management strategies) that use the simulated fishery data from the operating model to estimate the status of the (simulated) stock and provide management recommendations (e.g., a total allowable catch (TAC) or effort control), and an observation model that is used to generate the simulated observed data that would typically be used in management (i.e., with realistic imprecision and bias). The management recommendations by each management procedure are then fed-back into the operating model and projected forward one-time step. The process of simulating the population dynamics of the fishery along with the management process that feeds back and impacts the simulated fish population is known as closed-loop simulation. A benefit of closed-loop simulation is that it allows the direct comparison and evaluation of alternative management strategies against perfect knowledge of the simulated system; something that is impossible in the real world (Walters and Martell, 2004). With the aid of computer simulation, it is possible to run many hundreds of simulation runs for each management procedure being evaluated - each representing a different possible simulated future of what could happen to the fishery under various management strategies - and to take into account the uncertainty in knowledge of the stock and fishery (i.e., errors in observation), as well as the uncertainty in future environmental and ecological conditions that are likely to affect the stock dynamics. Through these simulations, MSE reveals the relative impacts of specified management approaches to their fishery decades into the future and enables managers to choose the approach that best achieves their management objectives, as articulated through a set of well-defined performance metrics. 1.3 How does Management Strategy Evaluation Differ from Stock Assessment? Stock assessments are intended to provide one-off management advice, such as a catch limit (e.g. 20,000 tonnes), based on historical data. However, a stock assessment on its own provides no knowledge of the expected performance of the assessment, harvest control rule, or management system in general. In an assessment setting there is no way to know whether a simpler assessment using other data might provide more robust performance (e.g. less overfishing, more yield) over a time horizon that managers are considering (e.g. the next 30 years). Management strategy evaluation tests a range of management approaches (of which an assessment linked to a harvest control rule is one such approach) and offers a scientific basis for selecting a management approach. MSE does not provide a catch-limit in tonnes, it identifies a modus operandi that will provide the desired management performance (it is analogous to selecting a suitable airplane via flight simulation testing rather than actually flying a plane to a specific destination). The advantage of MSE over stock assessment is that it is possible to consider a much wider range of uncertainty in stock dynamics, fleet dynamics, and data collection, which often better represents the state of knowledge (particularly for data-limited stocks). No matter how much uncertainty is factored into the MSE, a single management approach may be selected that can provide management advice. MSE was specifically introduced in controversial fishery settings where it was not possible to decide the ‘best’ representation of the state of nature. In the end, MSE was used to circumvent this problem by including all possible states of nature, often revealing that the disputes were in fact inconsequential all along. 1.4 Overview of the User Guide This User Guide is designed for new users to become familiar with the features of the DLMtool, and become comfortable with using the Toolkit to run a management strategy evaluation, select an appropriate management procedure for a particular fishery, and apply the management procedure to current fishery data to obtain specific management advice. The DLMtool is developed with R software, and users of the Toolkit will need to have the R software installed on their machine. Familiarity with the R programming language is beneficial, but an in-depth understanding of R is not required to use the DLMtool. 1.5 Acknowledgements Thanks to the many people who have alerted us to issues or bugs, provided suggestions for improvements, or asked the tricky, but important, questions that have helped us continue to develop the DLMtool. This User Guide has been developed with the bookdown package. Developers: Thomas Carruthers, University of British Columbia (UBC) Institute for the Oceans and Fisheries Adrian Hordyk, University of British Columbia (UBC) Institute for the Oceans and Fisheries Collaborators: Doug Butterworth, University of Cape Town Campbell Davies, Commonwealth Scientific and Industrial Research Organisation (CSIRO) Helena Geromont, University of Cape Town William Harford, National Oceanic and Atmospheric Administration (NOAA) Richard Hillary, Commonwealth Scientific and Industrial Research Organisation (CSIRO) Quang Huynh, Virginia Institute of Marine Science (VIMS) Laurie Kell, International Commission for the Conservation of Atlantic Tuna (ICCAT) Toshihide Kitakado, University of Tokyo Skyler Sagarese, University of Miami Rosenstiel School of Marine and Atmospheric Science (RSMAS) Liz Brooks, National Oceanic and Atmospheric Administration (NOAA) Robyn Forrest, Canadian Department of Fisheries and Oceans Chris Grandin, Canadian Department of Fisheries and Oceans California Department of Fish and Wildlife Funders: David &amp; Lucille Packard Foundation Gordon &amp; Betty Moore Foundation Kingfisher Foundation Natural Resources Defense Council Resources Legacy Fund Fisheries and Oceans, Canada (DFO) United Nations Food &amp; Agriculture Organization (FAO) 1.6 Bug Reports The package is subject to ongoing development and testing. If you find a bug or a problem please contact us or report an issue on GitHub so that it can be fixed! Fundamentally, the package is stochastic so if you run into problems with the code, please report it (along with a random seed) and, in the meantime, simply try running it again: the problem may be attributable to a rare combination of sampled parameters. 1.7 Version Notes The current version of the DLMtool package, available for download from CRAN, is 4.4.1.9999. Version notes for previous versions of DLMtool can be found at DLMtool News "],
["first-time-working-with-r.html", "Chapter 2 First Time Working With R? 2.1 R and RStudio 2.2 Installing the DLMtool Package 2.3 Assumed Knowledge 2.4 A Brief Note on S4 Methods 2.5 Getting Help", " Chapter 2 First Time Working With R? This section is designed for first-time users of the DLMtool, or users who may not have a lot of experience with R. You should be able to skip this section if you are familiar with R and RStudio, installing new R packages, and entering R commands into the R console. To get started with the DLMtool you will need at least two things: A current version of the R software installed on your machine. The latest version of the DLMtool package. 2.1 R and RStudio 2.1.1 The R Software The R software can be freely downloaded from the CRAN website and is available for all operating systems. Updated versions of R are released frequently, and it is recommended that you have the latest version installed. If you are using Windows OS, you can uses the installr package and the updateR() function to update and install the latest version. Alternatively, head to the CRAN website to download the latest version of R. 2.1.2 RStudio RStudio is a freely available integrated development environment (IDE) for R. It is not essential that you use RStudio, but it can make things a lot easier, especially if you are new to R. This User Guide assumes that you are using RStudio to operate the DLMtool. It is important to be aware that RStudio and R are two different pieces of software that must be installed separately. We recommend installing the R software before downloading and installing RStudio. 2.2 Installing the DLMtool Package If this is the first time you are using DLMtool, you will need to install the DLMtool package from CRAN. 2.2.1 Installing DLMtool Using R Console This can be done by running the command: install.packages(&quot;DLMtool&quot;) A prompt may appear asking you to select a CRAN mirror. It is best to pick the mirror that is the closest geographical distance. 2.2.2 Installing DLMtool Using RStudio An alternative method to install the DLMtool package is to click the Packages tab in the lower right panel in RStudio, and click Install. Check that Repository (CRAN, CRANextra) is selected in the Install from: drop-down menu, type DLMtool into the packages dialog box, and click Install. The DLMtool package relies on a number of other R packages, which the installation process will automatically install. The number of packages that are installed, and the time it takes, will depend on what packages you already have installed on your system (and your download speed). 2.2.3 Updating the DLMtool Package You will only need to install the DLMtool package once. However, the DLMtool package is updated from time to time, and you will need to re-install from CRAN for each new version. This can be done by using the update.packages command: update.packages(&quot;DLMtool&quot;) 2.2.4 Loading the DLMtool Package Once installed, the DLMtool package can be loaded into R by typing in the command line: library(DLMtool) or locating the DLMtool package in the list of packages in RStudio and checking the box. 2.3 Assumed Knowledge This User Guide assumes that you are using RStudio with an up-to-date version of R and the latest version of the DLMtool installed. You can check your version of R by typing version into the R console: version ## _ ## platform x86_64-w64-mingw32 ## arch x86_64 ## os mingw32 ## system x86_64, mingw32 ## status ## major 3 ## minor 4.1 ## year 2017 ## month 06 ## day 30 ## svn rev 72865 ## language R ## version.string R version 3.4.1 (2017-06-30) ## nickname Single Candle You can also find the version of DLMtool (or any other package) by typing: packageVersion(&#39;DLMtool&#39;) ## [1] &#39;4.4.1.9999&#39; The DLMtool package has been designed so that it is accessible for all users and does not assume a high level of knowledge of R. The functions and User Guide have been constructed in such a way that a user with little experience with R should be able to run the MSE and apply the methods to their data. No programming experience is required to use the package. However, users of the DLMtool should have some familiarity with R, and be comfortable with using the command line. The User Guide attempts to explain the use of the DLMtool in easy to follow steps, but familiarity with the most common R functions is assumed. The package is fully extensible, and more experienced R users are able to design their own management procedures, develop new plotting functions, and other customizations. 2.4 A Brief Note on S4 Methods The core functions of DLMtool are S4 Classes. Many R users may not have worked with S4 methods before. R has three different object oriented (OO) systems, the most common of which is known as S3. S3 is known as a generic-function OO, and is a casual system with no formal definition of classes. S4 works similar to S3, but is more formal and uses classes with a more rigid definition. It is not essential to understand the difference between S3 and S4, or why one is preferred over the other, to use the DLMtool. The most important thing that you need to know how to access the information in S4 classes. If you have work with R in the past, you are probably familiar with using the $ symbol to access elements in a data frame or list. S4 classes contain a named list of slots which are analogous to a standard R list. However, the slots in a S4 class differ in two important ways: The type of content in each slot (e.g., character, numeric, matrix) is determined in the class definition, and cannot be changed. In other words, you are not able to put content of class character into a slot that is expecting information of class numeric. This is what is meant by the S4 system being more strict than S3. The slots are accessed with the @ symbol. This is essentially the same as the $ symbol in S3 classes. You will see examples of this throughout the User Guide. The main thing to note here is that when you see the @ symbol being used, it refers to some particular information (a slot) being accessed from a larger collection of data (the object). For further information on the S3 and S4 systems see Advanced R. 2.5 Getting Help 2.5.1 Additional Help on the DLMtool This User Guide aims to explain the workings of the DLMtool, and address the most common questions and issues associated with the package. Additional help material for the DLMtool package and functions can be obtained in the usual way: help(DLMtool) Documentation for each function can be obtained by typing a ? symbol followed by the function name. For example: ?runMSE Information on the DLMtool classes can be found by first typing class followed by the ? symbol and the class name. For example: class?Data You can access this user guide at any time from the R console: userguide() 2.5.2 Questions on R-related Problems Although the User Guide attempts to address the most common issues, undoubtedly there will be times where you have problems with your R code. R has a somewhat annoying habit of returning cryptic error messages, that are sometimes indecipherable, especially to those who are new to the software. Most coding problems with the R language are the result of a missing parenthesis, an extra or missing comma or quotation mark, or some other minor typo that stops your code from running. There are a number of resources available on the Internet that are devoted to dealing with questions and problems with R programming. StackOverflow is great place to start searching for answers to your R-related problems. There is a high chance that in the past someone has posted the exact question that you are dealing with, and one or several kind souls have provided helpful solutions. If not, you can post your own question. But be aware, the StackOverflow community is made up entirely of people who volunteer their time to help others, and they sometimes have little patience for question that don’t demonstrate a proper search for already posted answers to the problem. "],
["preq.html", "Chapter 3 Prerequisites to Using DLMtool", " Chapter 3 Prerequisites to Using DLMtool At the start of every session there are a few things to do: 1. Load the DLMtool library. 2. Make the data available. 3. Set up parallel computing. The following steps must be run every time the DLMtool is used in a new R session: Load the Library - At the beginning of every session you must load the DLMtool library: library(DLMtool) Set up parallel processing: setup() The above steps need to be done each time you start a new instance of R/RStudio and use the DLMtool. It is recommended that you start a new instance of R (by restarting RStudio) each time you begin a new analysis. "],
["setupOM.html", "Chapter 4 Setting up the MSE Operating Model 4.1 Overview 4.2 The Operating Model Object 4.3 Existing Stock, Fleet, Obs, and Imp Objects 4.4 Recommended Method for Creating the Operating Model Object 4.5 Other Methods to Import OM 4.6 Customizing the Operating Model 4.7 Modifying Existing Objects 4.8 More on Customizing the Operating Model", " Chapter 4 Setting up the MSE Operating Model 4.1 Overview The Operating Model (OM) is the main component of the MSE framework. The OM is used to simulate the population and fleet dynamics, the collection of data, and the application of a harvest control rule. The class OM is used to define the parameters for the operating model. Remember, for help on classes you can type class followed by ? and the class name. For example, to see the help file for the OM class, type the following into the R console: class?OM 4.2 The Operating Model Object Objects of class OM contain all of the parameters required to run the MSE. Because this is a simulation, there must be values for all parameters. You can see from the help file (class?OM) that objects of class OM can be constructed by using the new() function, and are built from four objects: Stock, Fleet, Obs (Observation) and Imp (Implementation) Stock, Fleet, Obs and Imp are all classes in the DLMtool, and, as the names suggest, contain the parameters for the fish stock, the fishing fleet, the observations of the data, and the implementation of the management recommendations respectively. The Stock, Fleet, Obs, and Imp objects are contained within separate parameter tables, which are stitched together to form the Operating Model parameters. You can look at the help files for each the these three classes for information on the slots for each object. Here we will briefly go through the contents of each. 4.2.1 Stock Object First we will look at the contents of the Stock object. There are a number of stocks built into the DLMtool, and we will explore one of these. Later we will look at how to develop our own Stock objects, or modify an existing Stock object. One of the Stock objects that is built into the DLMtool is Albacore. If you type Albacore into the R console (or into your R script and click Run) you will see a large amount of information printed out in the R console. Let’s take a look at the contents of the Albacore Stock object: slotNames(Albacore) ## [1] &quot;Name&quot; &quot;maxage&quot; &quot;R0&quot; &quot;M&quot; ## [5] &quot;M2&quot; &quot;Mexp&quot; &quot;Msd&quot; &quot;Mgrad&quot; ## [9] &quot;h&quot; &quot;SRrel&quot; &quot;Perr&quot; &quot;AC&quot; ## [13] &quot;recgrad&quot; &quot;Period&quot; &quot;Amplitude&quot; &quot;Linf&quot; ## [17] &quot;K&quot; &quot;t0&quot; &quot;LenCV&quot; &quot;Ksd&quot; ## [21] &quot;Kgrad&quot; &quot;Linfsd&quot; &quot;Linfgrad&quot; &quot;L50&quot; ## [25] &quot;L50_95&quot; &quot;D&quot; &quot;a&quot; &quot;b&quot; ## [29] &quot;Size_area_1&quot; &quot;Frac_area_1&quot; &quot;Prob_staying&quot; &quot;Fdisc&quot; ## [33] &quot;Source&quot; The output tells us that there are 33 slots in the Albacore Stock object. Each of these slots contains information relating to stock that is used in the MSE. We can examine the information that is stored in the slots using the @ symbol. For example, the name of the species in the Stock object is: Albacore@Name ## [1] &quot;Albacore&quot; The maximum age parameter is: Albacore@maxage ## [1] 15 The values for the natural mortality (M) parameter for this stock are: Albacore@M ## [1] 0.35 0.45 Note that the natural mortality parameter (M) has two values, while the maximum age (maxage) only has one value. The MSE in the DLMtool is a stochastic model, and almost all parameters are drawn from a distribution. By default this distribution is assumed to be uniform, and the two values for the M parameter represent the lower and upper bounds of this uniform distribution. Some parameters, such as maximum age (maxage), species name (Name), or initial recruitment (R0) have only a single value and are fixed in the MSE. You can see more information on the content of the Stock object by using the help function: class?Stock 4.2.2 Fleet Object While the Stock object contains all the information relating to the fish stock that is being modeled, the Fleet object is populated with information relating to the fishing fleet and historical pattern of exploitation. Like the Stock objects, there are a number of Fleet objects that are built into the DLMtool. Here we will look at the Generic_Fleet object. slotNames(Generic_Fleet) ## [1] &quot;Name&quot; &quot;nyears&quot; &quot;Spat_targ&quot; &quot;EffYears&quot; &quot;EffLower&quot; ## [6] &quot;EffUpper&quot; &quot;Esd&quot; &quot;qinc&quot; &quot;qcv&quot; &quot;L5&quot; ## [11] &quot;LFS&quot; &quot;Vmaxlen&quot; &quot;isRel&quot; &quot;LR5&quot; &quot;LFR&quot; ## [16] &quot;Rmaxlen&quot; &quot;DR&quot; &quot;SelYears&quot; &quot;AbsSelYears&quot; &quot;L5Lower&quot; ## [21] &quot;L5Upper&quot; &quot;LFSLower&quot; &quot;LFSUpper&quot; &quot;VmaxLower&quot; &quot;VmaxUpper&quot; ## [26] &quot;CurrentYr&quot; There are 26 slots in the Fleet object. The parameters in the Fleet object relate to the exploitation pattern of the stock. For example, the number of years that the stock has been exploited is specified in the nyears slot: Generic_Fleet@nyears ## [1] 50 As another example, the smallest length at full selection is specified in the LFS slot: Generic_Fleet@LFS ## [1] 0.75 1.10 Note that by default the values in the LFS (and the L5 [smallest length at 5% selectivity]) slots are specified as multiples of the length of maturity (e.g., Albacore@L50). This is necessary because the Fleet objects built into the DLMtool are all generic, in the sense that they can be used with any Stock object. You will notice that the isRel slot in the Generic_Fleet object is set to “TRUE”. This means that the selectivity parameters are relative to the length of maturity in the Stock object. Absolute values for the selectivity parameters can be used, for example by specifying LFS and L5 to, say, 100 - 150 and 50 - 70 respectively. The isRel parameter must then be set to “FALSE”, so that the Operating Model knows that these selectivity values are in absolute terms, and does not multiply them by the length of maturity (strange things may happen if the model assumes that the size of first capture is 50 to 70 times greater than the size of maturity!). Note that all the parameters in the Fleet object have two values, representing the minimum and maximum bounds of a uniform distribution (with some exceptions that will be discussed in more detail later). More information on the Fleet object can be found by typing: class?Fleet 4.2.3 Observation Object The third component for the Operating Model is the Obs object. This object contains all the information relating to how the fishery information is generated inside the model. Why do we need a Obs table? Although the MSE may be conditioned on real data and information about the fishery, all data is generated inside the model. Because it is a simulation model and the data was generated by a computer, rather than some unobserved real world process, the fishery data is known perfectly.In the real world, however, all data sources and parameter estimates are subject to some observation error. The degree of uncertainty may vary between different data types, and between different data-limited fisheries. The advantage of the MSE process is that the performance of a management procedure using the realistically noisy simulated data can be compared to the performance under conditions of perfect knowledge. This comparison, which unfortunately is never possible in the real world, can reveal important information about the robustness (or sensitivity) of certain methods to variability and error in particular data types. This knowledge can help to prioritize research to reduce uncertainty in the parameters and data sets that are most crucial to the performance of the method. Like the other two objects, there are a number of built-in Obs objects in the DLMtool. Let’s take a look at the Imprecise_Unbiased object: slotNames(Imprecise_Unbiased) ## [1] &quot;Name&quot; &quot;Cobs&quot; &quot;Cbiascv&quot; &quot;CAA_nsamp&quot; &quot;CAA_ESS&quot; ## [6] &quot;CAL_nsamp&quot; &quot;CAL_ESS&quot; &quot;CALcv&quot; &quot;Iobs&quot; &quot;Icv&quot; ## [11] &quot;Btcv&quot; &quot;Btbias&quot; &quot;beta&quot; &quot;LenMcv&quot; &quot;Mcv&quot; ## [16] &quot;Kcv&quot; &quot;t0cv&quot; &quot;Linfcv&quot; &quot;LFCcv&quot; &quot;LFScv&quot; ## [21] &quot;FMSYcv&quot; &quot;FMSY_Mcv&quot; &quot;BMSY_B0cv&quot; &quot;Irefcv&quot; &quot;Crefcv&quot; ## [26] &quot;Brefcv&quot; &quot;Dbiascv&quot; &quot;Dcv&quot; &quot;hcv&quot; &quot;Reccv&quot; ## [31] &quot;B0cv&quot; &quot;rcv&quot; &quot;Fcurbiascv&quot; &quot;Fcurcv&quot; &quot;maxagecv&quot; There are 35 slots in Obs objects, each with information relating to the uncertainty of a data type. For example, the LenMcv slot defines the uncertainty (coefficient of variability) in the length of maturity: Imprecise_Biased@LenMcv ## [1] 0.2 This means that the assumed length of maturity that is generated by the Operating Model, and used in the simulated application of a management procedure, is not the ‘true’ value set in the Stock object, but a value sampled with a 20% coefficient of variation. More information on the Obs object can be found by typing: class?Obs 4.2.4 Implementation Object The final component for the Operating Model is the Imp object. This object contains all the information relating to how the management recommendation is actually implemented in the fishery, i.e., the implementation error. The Imp object includes slots for the over or under catch of TAC, implementation error in total allowable effort, and variability in size limits. The Imp object is a recent addition to DLMtool and may be expanded in future developments. More information on the Imp object can be found by typing: class?Imp 4.2.5 Important changes - DLMtool V4.1 and greater DLMtool V4.1 introduced some important changes to the Operating Model object. The number of simulations (nsim) and the number of projection years (proyears) are now slots in the OM object, rather than arguments to runMSE (see Management Strategy Evaluation). This change was required to allow users to specify their own custom futures for parameters like M, growth, etc. The OM object also now has a new random seed slot in the operating model, which ensures that the MSE results are now exactly reproducible. You can modify the number of simulations, the number of projection years, or the value of the random seed by modifiying the relevant slots in the OM object: myOM@nsim myOM@proyears myOM@seed 4.2.6 Important changes - DLMtool V4.5 and greater Since DLMtool V4.5 the following slots have been added to the OM object: OM@interval OM@pstar OM@maxF OM@reps This was done so that an OM object is completely self-contained and includes all information used in the MSE. 4.3 Existing Stock, Fleet, Obs, and Imp Objects As mentioned earlier, there are several Stock, Fleet, Obs and Imp objects that are built into the DLMtool. A list of available Stock, Fleet, Obs, and Imp objects can be found using the avail function. For example, here we will print out a list of the 12 Stock objects that are built into the DLMtool: avail(&quot;Stock&quot;) ## [1] &quot;Albacore&quot; &quot;Blue_shark&quot; &quot;Bluefin_tuna&quot; ## [4] &quot;Bluefin_tuna_WAtl&quot; &quot;Butterfish&quot; &quot;Herring&quot; ## [7] &quot;Mackerel&quot; &quot;Porgy&quot; &quot;Rockfish&quot; ## [10] &quot;Snapper&quot; &quot;Sole&quot; &quot;Toothfish&quot; We can do the same thing for the Fleet objects (avail(&quot;Fleet&quot;)), the Obs objects (avail(&quot;Obs&quot;)), and the Imp objects (avail(&quot;Imp&quot;)). 4.4 Recommended Method for Creating the Operating Model Object DLMtool V4.5 introduced a standardised system for initializing, populating, documenting, and importing OM objects. The figure below shows our recommended workflow for importing an Operating Model (OM) into DLMtool: 4.4.1 Set Working Directory We recommend creating a new directory for each OM. Each new R session should start by setting the working directory to this location. One of the easiest ways to do this is to create a new project in RStudio (File &gt; New Project) and open this each time you revisit the analysis. Alternatively, you can set the working directory with RStudio (Session &gt; Set Working Directory) or directly in the R console, for example: setwd(&quot;C:/MSE/MyOM&quot;) 4.4.2 Initialize a New OM The OMinit function is used to create a blank OM spreadsheet and a skeleton OM documentation file in the working directory. This is only required the first time a new OM is created. The OMinit function requires one argument, a name for the OM, and wil create two files in the working directory. For example OMinit('MyOM') will create MyOM.xlsx and MyOM_source.rmd in the working directory. MyOM.xlsx is a spreadsheet with sheets corresponding to the components of an OM: Stock, Fleet, Obs, and Imp, and OM and Data sheets. The first column in each sheet is populated with the names of the slots of the respective objects (Stock, Fleet, etc) and all slots are empty (except the OM sheet which has default values). The MyOM_source.rmd file can be opened in any text editor or RStudio, and contains a skeleton for the OM documentation. More details on populating both these files are provided in the Populate and Document OM section below. 4.4.3 Create Source Documentation for Existing OM For existing OMs without documentation, the OMinit function can be used to create just the source documentation file in the working directory: OMinit(&#39;MyOM&#39;, `rmd`) 4.4.3.1 Using Templates Some users may wish to build an operating model based on other pre-existing Stock, Fleet, Obs, or Imp objects. This can be done by using the templates argument in OMinit. The templates argument requires a named list specifying the names of the objects to be used as templates. For example, OMinit('Albacore2', templates=list(Stock=Albacore)) will result in a Albacore2.xlsx file being created with the Stock sheet populated with the values from the Albacore Stock object. Other examples: OMinit(&#39;StockAndFleet&#39;, templates=list(Stock=Albacore, Fleet=Generic_FlatE)) OMinit(&#39;ObsAndImp&#39;, templates=list(Obs=Generic_Obs, Imp=Perfect_Imp)) 4.4.4 Populate and Document OM The OM is populated by adding values for each slot into the Excel spreadsheet. To assist in documenting the rationale for the OM parameters, we recommended adding a short but informative description or rationale for the OM values in the *_source.rmd* file while the OM Excel file is being populated (open the rmd file and edit with any text editor or RStudio). Once complete, the *_source.rmd* file can be compiled into a HTML report and provides a complete documentation for the OM. The *_source.rmd* file also contains additional information including a title for the OM report, author details, and an introduction section for additional information on the OM. Instructions for completing the OM documentation are provided in *_source.rmd* file. The OM documentation file should be updated whenever values in the OM are changed. 4.4.5 Compile OM Report from Excel Once the OM has been specified in the spreadsheet and documented in the *_source.rmd* file, it can be compiled into a OM Report using the OMdoc function. The OMdoc function OMdoc(&#39;MyOM&#39;) In most cases it is not neccessary to provide the name of the *_source.rmd* file to OMdoc. By default the OMdoc function will look for the rmd file in working directory. For example, if the Excel file is named MyOM then OMdoc will look for MyOM_source.rmd, which is default name created by OMinit. Additionally, if there is only one xlsx file in the working directory the name of the OM is not required, i.e., OMdoc(). Depending on the OM (particularly number of simulations (nsim) and maximum age (maxage)), this may take some time as the historical simulations are run. The resulting MyOM.html can opened in any web browser. It may also be possible to compile the OM report into a pdf (using output=&quot;pdf_document&quot;) though this may require additional software. 4.4.6 Import OM from Excel The OM can be imported from the Excel file using the XL2OM function. For example, to import the example OM created in the previous section: OM &lt;- XL2OM(&#39;Example_Chile_hake&#39;) 4.5 Other Methods to Import OM Previous versions of DLMtool required the new command to create OM objects. This method is still available and is described in this section. Here we will create a Operating Model object called myOM, and use the Blue_shark Stock object, the Generic_Fleet Fleet object, the Imprecise_Biased Observation object, and the default Perfect_Imp Imp object: BlueSharkOM &lt;- new(&#39;OM&#39;, Blue_shark, Generic_Fleet, Imprecise_Biased, Perfect_Imp) If you use the slotNames function on the myOM object that was just created, you will see that it contains all of the information from the Stock, Fleet, Obs, and Imp objects. 4.5.1 Compile OM Report from OM The OMdoc function can be used to generate an OM report directly from an OM object and an *_source.rmd* file. In this case it is necessary to provide the name of the *_source.rmd* file to OMdoc. For example, here we create an OM using existing objects from DLMtool, generate the *_source.rmd* documentation skeleton (only required once), and compile the OM report: BlueSharkOM &lt;- new(&#39;OM&#39;, Blue_shark, Generic_Fleet, Imprecise_Biased, Perfect_Imp) # create/import an OM OMinit(&#39;BlueSharkOM&#39;, &#39;rmd&#39;, templates=list(Stock=Blue_shark, Fleet=Generic_Fleet, Obs=Imprecise_Biased, Imp=Perfect_Imp)) # - Enter OM details in BlueSharkOM_source.rmd - OMdoc(BlueSharkOM, &#39;BlueSharkOM_source.rmd&#39;) 4.5.1.1 Example Documentation An example of the OM documentation may be useful. The following command creates example (already populated) Example_Chile_hake.xlsx and Example_Chile_hake_source.rmd files: OMinit(&#39;example&#39;, overwrite = TRUE) Each slot in the OM Excel file has been populated and a rationale provided for each slot in the documentation source file. The OM documentation can be compiled: OMdoc(&#39;Example_Chile_hake&#39;) 4.6 Customizing the Operating Model We have now created or imported a Operating Model object and can begin the MSE. If you wish, you can jump ahead to the Management Strategy Evaluation section (although you may wish to read the Management Procedures section first). The remainder of this section will describe how to modify the existing Stock, Fleet, Obs, and Imp objects, as well as create new objects. The pre-defined Stock, Fleet, Obs, and Imp objects in DLMtool can be used for running an MSE and exploring the output. More often, however, users of the DLMtool will be interested in performing an MSE for their own particular fishery. To do this, the parameters of the Operating Model (or more specifically the Stock, Fleet, Obs and Imp objects from which it is built) must be specified in such a way that reflects the characteristics of the fishery. There are a number of ways of doing this. 4.6.1 Creating New Objects One method is to create empty Stock, Fleet, Obs, and Imp objects and manually populate them. This can be done using the new command: myStock &lt;- new(&quot;Stock&quot;) myFleet &lt;- new(&quot;Fleet&quot;) myObservation &lt;- new(&quot;Obs&quot;) myImp &lt;- new(&quot;Imp&quot;) This code creates new Stock, Fleet, Obs, and Imp objects that are empty and contain no information. You can check this by looking at a slot in one of the objects, for example: myStock@M ## numeric(0) The object can then be manually populated. For example, myStock@M &lt;- c(0.1, 0.25) Here we set value of the natural mortality parameter (M) to range from 0.1 to 0.25. The MSE requires values for each parameter (or slot) in the Operating Model object, and the three objects that were just created would have to be manually populated. This is possible to do, but perhaps a little tedious. More importantly, it is easy to introduce errors using this method. For example, let’s try to populate the slot that contains information on the asymptotic size (Linf) myStock@Linf &lt;- 100 This seemed to work okay. However, if we try to run an MSE using this Stock object we will be confronted with an error. This is because the Operating Model requires two values (lower and upper bounds) for the Linf parameter. The DLMtool isn’t smart enough (yet!) to detect this error before it is too late. 4.6.2 Importing Objects from a CSV File There may be cases where creating a blank object is useful. More likely, however, is that users will import an object from a file, or modify a built-in object. This can be done by using the new command and specifying the location of a comma-separated-variable (CSV) file that contains the relevant information. 4.6.2.1 Importing a Stock Object If we have a CSV file named MyStock.csv and stored in the directory CSVs (located within the working directory), we can import the Stock object using the following code: myStock &lt;- new(&quot;Stock&quot;, &quot;CSVs/MyStock.csv&quot;) The myStock object is now populated with the contents of the MyStock.csv (You may notice it is almost identical to the Albacore object that is in the DLMtool). To import objects in this way, the CSV file must be set up in a specific format. The image below shows the contents of the MyStock CSV file. The first column contains the names of the slots in the Stock object. It is important that the text in the first column of the CSV file is exactly the same as the names slot of the slots in the Stock object (you can use slotNames to check this). The second and third columns contain the values for each parameter. Note that some parameters, such as the length-weight relationship parameters (a and b), the maximum age (maxage), and the initial recruitment (R0) only require a single value. Click here for a larger version of the image. 4.6.2.2 Importing a Fleet Object A Fleet object can be imported in a similar way: myFleet &lt;- new(&quot;Fleet&quot;, &quot;CSVs/myFleet.csv&quot;) Note here again that the text in the first column must exactly match the names of the slots in the Fleet object. Click here for a larger version of the image. Note: If the DLMtool cannot find the CSV file in the specified directory, a warning message will appear and a blank object will be created. 4.6.2.3 Importing an Observation Object To import a Obs object from a CSV file you follow the same procedure: myObs &lt;- new(&quot;Obs&quot;, &quot;CSVs/myObs.csv&quot;) Note, however, that the Obs object is large (35 parameters) and it is often easiest to modify an existing Obs object. We can now stitch the four objects together into a new Operating Model: myOM &lt;- new(&quot;OM&quot;, myStock, myFleet, myObs, myImp) By default the new(&quot;OM&quot;) command includes the Perfect_Imp Imp object. 4.7 Modifying Existing Objects Often the simplest way to creating a custom Operating Model object is to modify the existing objects in the DLMtool. For example, suppose we wish to do a MSE for a species that we know has a similar life history to herring. Using the existing Herring Stock object is a good place to start. First we create a new object by copying the existing Herring object: MyStock &lt;- Herring Then we can modify the parameters so that it better suits our particular species. For example, we may wish to modify the asymptotic size (Linf), the von Bertalanffy K parameter (K), and the length at maturity (L50 and L50_95): MyStock@Linf &lt;- c(60, 80) MyStock@K &lt;- c(0.2, 0.25) MyStock@L50 &lt;- c(30, 40) MyStock@L50_95 &lt;- c(10, 15) We should also change the Name and Source for our stock: MyStock@Name &lt;- &quot;Herringish&quot; MyStock@Source &lt;- &quot;None. I made this up&quot; You can continue modifying the remaining parameters as required. The Fleet and Obs objects can be modified in from existing objects in a similar way. First we copy existing objects, and then modify them to suit our needs: MyFleet &lt;- FlatE_Dom # Dome-shaped selectivity and flat effort trajectory MyFleet@L5 &lt;- c(15, 20) # change the selectivity pattern MyFleet@LFS &lt;- c(25, 30) MyFleet@isRel &lt;- &quot;FALSE&quot; # remember to change this MyObs &lt;- Imprecise_Unbiased MyObs@Mcv &lt;- 0.15 # increase uncertainty in M Here we have modified a few parameters in the Stock, Fleet, and Obs objects and assumed that the rest of the values in built-in objects adequately describe our fishery. We can now create an Operating Model object using the same method described previously: MyOM &lt;- new(&quot;OM&quot;, MyStock, MyFleet, MyObs, myImp) 4.8 More on Customizing the Operating Model In some circumstances there may be knowledge on the changes in fishing practices over the years, and it would be good to include this information in the Operating Model. The Operating Model can be conditioned with respect to historical trends in the fishing mortality, and historical changes in the selectivity pattern. Remember to update and recompile the OM documentation whenever the OM is modified. 4.8.1 Historical Trends in Fishing Mortality Suppose that we know the fishery began in 1950, and fishing effort increased slowly over the next decade, was relatively stable between 1960 and 1970, then increased dramatically over the next 10 years. We also know that, while fishing effort stayed relatively constant from 1980 to around 2000, there has been a general decline in fishing effort in recent years. This information can be included in the Operating Model by using the ChooseEffort function. The ChooseEffort function takes an existing Fleet object as its first argument, and allows the user to manually map out the range for the historical trend in fishing effort. The ChooseEffort function then returns the updated Fleet object. A second optional argument can be used to specify the historical years. If used, this will replace the nyears in the Fleet object with the length of the Years vector. MyFleet &lt;- ChooseEffort(MyFleet, Years=1950:2016) If we take a look at the MyFleet object, we will see that three slots EffYears, EffLower and EffUpper have been replaced with the new values. Note that the trajectory that is mapped out here represents the bounds on the relative fishing mortality for each year. In this example, the fishing mortality rate was highest (on average) between 1980 and 2000, and is currently around 65 - 80% of this maximum level. 4.8.2 Historical Trends in the Selectivity Pattern Suppose that we may knew there had been changes in the selectivity pattern of the fishery over time. This information can be included in the Operating Model by using the ChooseSelect function. Like the ChooseEffort function described above, the ChooseSelection function takes a Fleet objects as it’s first argument, and returns an updated Fleet object. Suppose the selectivity pattern changed in 1970 and then again in 1990, perhaps because of changes in fishing regulations. These change points in the selectivity curve can be mapped by the following command: MyFleet &lt;- ChooseSelect(MyFleet, FstYr=1950, SelYears=c(1970, 1990)) Note that the first year (FstYr) must also be specified, and the selectivity pattern is mapped for this year as well. When ChooseSelect is used, the L5Lower, L5Upper, LFSLower, LFSUpper, VmaxLower, VmaxUpper, and SelYears slots are updated in the Fleet object. If these slots are populated, the values in the L5, LFS, and Vmaxlen slots are ignored in the operating model. "],
["MPs.html", "Chapter 5 Management Procedures 5.1 What is a Management Procedure? 5.2 Management Procedure Classes 5.3 Built-in Management Procedures 5.4 Details of the Methods 5.5 Designing New Methods", " Chapter 5 Management Procedures The purpose of an MSE is to compare the performance of alternative management approaches, or Management Procedures to identify the method that is most likely to meet the management objectives for the fishery. 5.1 What is a Management Procedure? In essence, a Management Procedure is simply a set of rules which define how a fishery will be managed. These rules can range from simple harvest policies to more complex arrangements. For example, a simple Management Procedure may be a constant catch policy, where the annual total allowable catch (TAC) is set a some fixed value. Alternatively, a more complex Management Procedure may involve multiple data sources, with rules that increase or reduce the TAC in response to trends in one or several indicators. Management Procedures can differ in data requirements and complexity. However, all Management Procedures have one thing in common. They take fishery information and return a management recommendation. To be included in an MSE, a Management Procedure must be reproducible and able to be coded in a set of instructions. While fisheries are sometimes managed by expert judgment, it is difficult to reproduce the subjective decision-making process in a computer simulation and include such methods in an MSE. 5.2 Management Procedure Classes Management Procedures in the DLMtool are divided into two classes: Output controls and Input controls. 5.2.1 Output Controls The output control methods in the DLMtool provide a management recommendation in the form of a TAC. Some output controls are stochastic, allowing for uncertainty in the data or input parameters, and return a distribution of recommended TACs. Output control methods are very common in fisheries management, especially in regions which have a tradition of managing fisheries by regulating the total amount of catch. 5.2.2 Input Controls The input control methods in the DLMtool allow regulation of fishing effort, size selecitivty, or spatial area. 5.2.2.1 Effort Controls Effort controls adjust the relative amount of fishing effort. In the DLMtool, all effort controls are designed to adjust effort relative to the current levels of effort. For example, an input control method may recommend a 15% increase or decrease in fishing effort in response to the signal in some fishery data. 5.2.2.2 Selectivity Controls Selectivity controls provide recommendations on the size selection pattern for the fishery. Selectivity controls can be static, for example a single fixed size limit, or dynamic, where a selectivity pattern is modified in response to data. The DLMtool can account for selectivity controls in the form of a minimum legal length or a harvest slot limit (upper size limit). A fixed size limit is a Management Procedure, but typically does not require any fishery data to implement the rule. 5.2.2.3 Spatial Controls Spatial controls in the DLMtool allow for the opening and closing of spatial areas to fishing activity. Spatial controls can be static (permanent closed area) or dynamic with an area opening and closing to fishing in response to indicators in the fishery data. 5.3 Built-in Management Procedures The DLMtool has a large number of Management Procedures that are built into the Toolkit. Many of these methods have been published in the scientific literature as recommended methods for managing data-limited fisheries. Other methods have been developed more recently and have been included in the DLMtool to evaluate if they have potential to be useful for management. The DLMtool has been designed to be extensible, and it is straightforward to develop additional Management Procedures and include them in the MSE. Details on how to develop new Management Procedures are provided in sections below. 5.3.1 Output Controls Output control methods (methods that return a TAC) in the DLMtool are of the class DLM_output. You can use the avail function to list the available output controls in the DLMtool: avail(&quot;Output&quot;) ## [1] &quot;AvC&quot; &quot;BK&quot; &quot;BK_CC&quot; &quot;BK_ML&quot; &quot;CC1&quot; ## [6] &quot;CC4&quot; &quot;CompSRA&quot; &quot;CompSRA4010&quot; &quot;DAAC&quot; &quot;DBSRA&quot; ## [11] &quot;DBSRA_40&quot; &quot;DBSRA_ML&quot; &quot;DBSRA4010&quot; &quot;DCAC&quot; &quot;DCAC_40&quot; ## [16] &quot;DCAC_ML&quot; &quot;DCAC4010&quot; &quot;DD&quot; &quot;DD4010&quot; &quot;DepF&quot; ## [21] &quot;DynF&quot; &quot;Fadapt&quot; &quot;Fdem&quot; &quot;Fdem_CC&quot; &quot;Fdem_ML&quot; ## [26] &quot;FMSYref&quot; &quot;FMSYref50&quot; &quot;FMSYref75&quot; &quot;Fratio&quot; &quot;Fratio_CC&quot; ## [31] &quot;Fratio_ML&quot; &quot;Fratio4010&quot; &quot;GB_CC&quot; &quot;GB_slope&quot; &quot;GB_target&quot; ## [36] &quot;Gcontrol&quot; &quot;HDAAC&quot; &quot;Islope1&quot; &quot;Islope4&quot; &quot;IT10&quot; ## [41] &quot;IT5&quot; &quot;Itarget1&quot; &quot;Itarget4&quot; &quot;ITM&quot; &quot;L95target&quot; ## [46] &quot;LBSPR_ItTAC&quot; &quot;LstepCC1&quot; &quot;LstepCC4&quot; &quot;Ltarget1&quot; &quot;Ltarget4&quot; ## [51] &quot;MCD&quot; &quot;MCD4010&quot; &quot;NFref&quot; &quot;Rcontrol&quot; &quot;Rcontrol2&quot; ## [56] &quot;SBT1&quot; &quot;SBT2&quot; &quot;SPmod&quot; &quot;SPMSY&quot; &quot;SPslope&quot; ## [61] &quot;SPSRA&quot; &quot;SPSRA_ML&quot; &quot;YPR&quot; &quot;YPR_CC&quot; &quot;YPR_ML&quot; As you can see, there are 65 output control methods built into the DLMtool. 5.3.2 Input Controls The list of the 24 available input control methods (class Input) can be displayed in the same way: avail(&quot;Input&quot;) ## [1] &quot;curE&quot; &quot;curE75&quot; &quot;DDe&quot; &quot;DDe75&quot; &quot;DDes&quot; ## [6] &quot;DTe40&quot; &quot;DTe50&quot; &quot;EtargetLopt&quot; &quot;ItargetE1&quot; &quot;ItargetE4&quot; ## [11] &quot;ITe10&quot; &quot;ITe5&quot; &quot;LBSPR_ItEff&quot; &quot;LBSPR_ItSel&quot; &quot;LstepCE1&quot; ## [16] &quot;LstepCE2&quot; &quot;LtargetE1&quot; &quot;LtargetE4&quot; &quot;matlenlim&quot; &quot;matlenlim2&quot; ## [21] &quot;minlenLopt1&quot; &quot;MRnoreal&quot; &quot;MRreal&quot; &quot;slotlim&quot; 5.4 Details of the Methods Information on each Management Procedure can be found be using the ? function. For example, to access the documentation associated with the CC1 method, you would type ?CC1 into the R console. The help documentation provides a description of the method, the arguments for the function, and the output of the function, together with references to the scientific literature that are associated with the method. 5.5 Designing New Methods DLMtool was designed to be extensible in order to promote the development of new Management Procedures. In this section we design a series of new Management Procedures that include spatial controls and input controls in the form of size limit restrictions. The central requirement of any MP is that it can be applied to a Data object using the function sapply (sfSapply() in parallel processing). Data objects have a single position x for each data entry (e.g. one value for natural mortality rate, a single vector of historical catches, etc.). In the MSE analysis this is extended to nsim positions. See the Managing Fishery Data section for more information about the Data object. It follows that any MP arranged to function sapply(x,MP,Data) will work. For example we can get five stochastic samples of the TAC for the demographic FMSY MP paired to catch-curve analysis FdemCC applied to a real data-limited data object for red snapper using: sapply(1,Fdem_CC,Red_snapper,reps=5) ## [,1] ## [1,] 17.593321 ## [2,] 11.418830 ## [3,] 6.347816 ## [4,] 8.766377 ## [5,] 38.576474 The MSE populates a Data object with many simulations and uses sfSapply() (snowfall cluster computing equivalent) to calculate a management recommendation for each simulation. By making methods compatible with this standard the very same equations are used in both the MSE and the real management advice. 5.5.1 Average Historical Catch Management Procedure The average historical catch has been suggested as a starting point for setting TACs in the most data-limited situations (following Restrepo et al., 1998). Here we design such an Management Procedure: AvC &lt;- function(x, Data, reps) { rlnorm(reps, log(mean(Data@Cat[x,], na.rm=T)), 0.1) } Note that all Management Procedures have to be stochastic in this framework, which is why we sample from a log-normal distribution with a CV of roughly 10 per cent. Before the Management Procedure can be ‘seen’ by the rest of the DLMtool package we have to do three more things. The Management Procedure must be assigned a class based on what outputs it provides. Since this is an output control (TAC) based MP we assign it class Output. The Management Procedure must also be assigned to the DLMtool namespace: class(AvC) &lt;-&quot;Output&quot; environment(AvC) &lt;-asNamespace(&#39;DLMtool&#39;) and - if we are using parallel computing - exported to the cluster: sfExport(&quot;AvC&quot;) 5.5.2 Length-at-Retention Set Equal to Length-at-Maturity Note: In DLMtool V4.4+ the structure of Input control methods has changed To simulate input controls that aim to alter the length-retention to fishing it is possible to design a Management Procedure of class Input. In this example we set the retention equal to the maturity curve, while the spatial and effort regulations remain constant: matlenlim &lt;- function (x, Data, ...) { # Knife-edge vulnerability at estimated length-at-maturity dependencies = &quot;Data@L50&quot; rec &lt;- new(&quot;InputRec&quot;) # create a input recommendation object rec@LR5 &lt;- Data@L50[x] * 0.95 # new length at 5% retention rec@LFR &lt;- Data@L50[x] # new length at full retention # other slots aren&#39;t specified so remain unchanged return(rec) } class(matlenlim) &lt;- &quot;Input&quot; environment(matlenlim) &lt;- asNamespace(&quot;DLMtool&quot;) and export to cluster: sfExport(&quot;matlenlim&quot;) 5.5.3 Harvest Slot Limit We can also choose to create a Management Procedure with a harvest slot limit. This example sets a minimum legal length at 1.1 times the size of maturity, and a maximum size limit (completely arbitrarily!) at 75% of the distance between the minimum legal length and the estimate of asymptotic length recorded in the fishery data object: slotlim &lt;- function (x, Data, ...) { dependencies = &quot;Data@L50, Data@vbLinf&quot; rec &lt;- new(&quot;InputRec&quot;) # create input recommendation object rec@LFR &lt;- 14 + 1.1 * Data@L50[x] # new length at full retention rec@LR5 &lt;- 0.95 * rec@LFR # new length at 5% retention rec@HS &lt;- as.numeric(quantile(c(rec@LFR , Data@vbLinf[x]), 0.75)) # upper harvest slot limit rec } class(slotlim) &lt;- &quot;Input&quot; environment(slotlim) &lt;- asNamespace(&quot;DLMtool&quot;) and export to cluster: sfExport(&quot;slotlim&quot;) Note that the arguments for the input methods must include either reps or ..., even if these are not used. 5.5.4 Reducing Fishing Rate in area 1 by 50% Spatial controls operate similarly to the age/size based controls: a vector of length 2 (the spatial simulator is a 2-box model) that indicates the fraction of current spatial catches. In this example we reduce effort in area 1 by 50%. area1_50 &lt;- function(x,Data, ...){ rec &lt;- new(&quot;InputRec&quot;) # create recommendation object rec@Allocate &lt;- 0 # Fraction of effort reallocated to open area rec@Spatial &lt;- c(0.5,1) # Fraction of effort found in each area # other slots aren&#39;t specified so remain unchanged return(rec) } class(area1_50)&lt;-&quot;Input&quot; environment(area1_50) &lt;- asNamespace(&#39;DLMtool&#39;) sfExport(&quot;area1_50&quot;) "],
["MSE.html", "Chapter 6 Management Strategy Evaluation 6.1 Re-cap on Setting up DLMtool 6.2 Defining the Operating Model 6.3 Choose Management Procedures 6.4 The runMSE Function 6.5 Checking Convergence 6.6 A Quick Recap", " Chapter 6 Management Strategy Evaluation The last two chapters described how to set up an Operating Model object and to select or develop Management Procedures. This chapter will describe how to run the Management Strategy Evaluation using the DLMtool 6.1 Re-cap on Setting up DLMtool Chapter 3 describes the necessary to set up the DLMtool. In brief, the following lines should appear at the top of your script whenever you are using the DLMtool to run a MSE: library(DLMtool) setup() 6.2 Defining the Operating Model The operating model is the ‘simulated reality’: a series of known simulations for testing various data-limited Management Procedures. Operating models can either be specified in detail according to each variable (e.g. sample natural mortality rate between 0.2 and 0.3) or alternatively the user can rapidly construct an operating model based on a set of predefined Stock, Fleet and Observation models. See Chapter 4 for more details on the operating model. In this case we take the latter approach and pick the Blue_shark stock type, a generic fleet type and an observation model that generates data that can be both imprecise and biased. We will ignore implementation error and use the default Perfect_Imp. OM &lt;- new(&#39;OM&#39;, Blue_shark, Generic_Fleet, Imprecise_Biased, Perfect_Imp) 6.3 Choose Management Procedures The MSE can be run either with all of the Management Procedures contained within DLMtool or a subset of methods, for example, only the output control class of methods. As an example, if you wanted to choose four output controls, and one input control method, you would enter the following code. See Chapter 5 for more details on the Management Procedures, including how we created the matlenlim input control method. MPs &lt;- c(&quot;Fratio&quot;, &quot;DCAC&quot;, &quot;Fdem&quot;, &quot;DD&quot;, &quot;matlenlim&quot;) 6.4 The runMSE Function The MSE is run using the runMSE function. In addition to the OM (Operating Model) and MPs (Management Procedures) arguments, the RunMSE function has a number of other arguments to control the MSE. You can access the help file for the runMSE function by typing: ?runMSE into the R console. 6.4.1 Description of the Arguments Here we briefly describe the arguments for the runMSE function: OM - An object of class OM. Must be specified, see Chapter 4 for details. MPs - A character vector specifying the Management Procedures to be included in the MSE. If not specified, the DLMtool will run the MSE for all available methods in the Toolkit. nsim - Number of simulations (For backward compatibility only. nsim is now a slot in the OM object and this argument will be ignored if nsim is specfied in OM@nsim) proyears - Number of projected years (For backward compatibility only. proyears is now a slot in the OM object and this argument will be ignored if proyears is specfied in OM@proyears.) interval - The assessment interval - how often would you like to update the management system? pstar - The percentile of the sample of the management recommendation for each method maxF - Maximum instantaneous fishing mortality rate that may be simulated for any given age class timelimit - Maximum time taken for a method to carry out 10 reps (methods are ignored that take longer) reps - The number of samples of the management recommendation for each method. Note that when this is set to 1, the mean value of the data inputs is used CheckMPs - A logical value to specify if the DLMtool should check if the Management Procedures can be run before running the entire MSE. Mainly used for developing and testing new methods. Hist - Logical - Should model stop after historical simulations? Returns a list containing all data simulated for historical period ntrials - Maximum of times depletion and recruitment deviations are resampled to optimize for depletion. fracD - maximum allowed proportion of simulations where depletion is not close to sampled depletion from OM before model stops with error CalcBlow - Logical - Should low biomass be calculated where this is the spawning biomass at which it takes HZN mean generation times of zero fishing to reach Bfrac fraction of SSBMSY? HZN - The number of mean generation times required to reach Bfrac SSBMSY in the Blow calculation Bfrac - The target fraction of SSBMSY for calculating Blow 6.4.2 Using runMSE Most of the arguments for the runMSE function have default values. The most important parameters to specify are the Operating Model object, the Management Procedures to include, the number of simulations, the number of projection years, and the interval for management. Here we will demonstrate running the blue shark operating model that we created above, for the five Management Procedures selected above. Note that in this example we have chosen to include 10 simulations (nsim=10) and left the other parameters at the default values. OM@nsim &lt;- 10 BSharkMSE &lt;- runMSE(OM=OM, MPs=MPs) ## Loading operating model ## Note: Maximum age (15) is lower than assuming 1% of cohort survives to maximum age (30) ## Optimizing for user-specified movement ## Optimizing for user-specified depletion ## Calculating historical stock and fishing dynamics ## Calculating MSY reference points ## Calculating reference yield - best fixed F strategy ## 1/5 Running MSE for Fratio ## .................................................. ## 2/5 Running MSE for DCAC ## .................................................. ## 3/5 Running MSE for Fdem ## .................................................. ## 4/5 Running MSE for DD ## .................................................. ## 5/5 Running MSE for matlenlim ## .................................................. Note that this is just a demonstration, in a real MSE you should use many more simulations (nsim more than 200), reps (samples per method more than 100) and perhaps a more frequent assessment interval (interval of 2 or 3 years). Note that when reps is set to 1, all stochastic MPs use the mean value of an input and do not sample from the distribution according to the specified CV (the Output MPs become deterministic and no longer produce samples of the TAC recommendation). 6.4.3 Robust Wrapper Function The above example, with 10 simulations and 5 Management Procedures, should take about 17 seconds to complete. A real MSE would include many more simulations and take significantly longer. The runMSErobust function has been designed as a more efficient way to run the MSE for a large number of simulations. The runMSErobust function splits the MSE into a number of individual packets. The advantages are that it is more efficient (i.e., quicker), it automatically saves the final MSE object to the hard disk, and re-starts a packet if the MSE model crashes. Furthermore, the individual packets can be saved so if the model crashes, or you suffer a power outage the work is not lost. It is recommended to use the runMSErobust function if you are running a large number of simulations. However, it is always a good idea to run a small number of simulations first, to test that the MSE is running correctly, and not crashing due to mis-specified parameters or bugs in the Management Procedure code. The runMSErobust function is essentially a wrapper for the runMSE function and takes the same arguments as runMSE. The runMSErobust function has several additional arguments: maxsims - The maximum number of simulations to include in each packet name - The file name of the MSE object that is saved to the hard disk unique - Logical - Should the name be unique? Current date and time will be appended to name maxCrash - The maximum number of consecutive crashes before the MSE stops saveMSE - A logical value (TRUE/FALSE) to indicate if final MSE object should be saved to current working directory (this is probably a good idea) savePack - A logical value (TRUE/FALSE) to indicate if the packets should be save to current working directory Here we will run the blue shark MSE with 300 simulations. Note that the output is not printed out in the User Manual. OM@nsim &lt;- 300 BSharkMSE &lt;- runMSErobust(OM=OM, MPs=MPs, name=&quot;bluesharkMSE&quot;) This run should be completed in 10 minutes or less. The MSE object was saved (using the saveRDS function) to the current working directory as a rdata object named ‘bluesharkMSE.rdata’. A saved MSE object can be loaded using the readRDS function: BSharkMSE &lt;- readRDS(&quot;bluesharkMSE.rdata&quot;) 6.5 Checking Convergence The MSE is now complete. We can use the Converge function to confirm that the number of simulations is sufficient and the MSE model has converged, by which we mean that the relative position of the Management Procedures are stable with respect to different performance metrics: Converge(BSharkMSE) ## All MPs appear to have converged in 300 iterations (threshold = 2%) 6.6 A Quick Recap The next step is exploring the output of the MSE, and determining which Management Procedure best meets the management objectives. The information above is spread out over a number of sections and paragraphs, and may appear a little complex. In fact, other than the initial set up of the DLMtool, it only took 4 lines of code to run the MSE and check the model for convergence: OM &lt;- new(&#39;OM&#39;, Blue_shark, Generic_Fleet, Imprecise_Biased, nsim=300) MPs &lt;- c(&quot;Fratio&quot;, &quot;DCAC&quot;, &quot;Fdem&quot;, &quot;DD&quot;, &quot;matlenlim&quot;) BSharkMSE &lt;- runMSErobust(OM=OM, MPs=MPs, name=&quot;bluesharkMSE&quot;) Converge(BSharkMSE) In the next Chapter we will look at how to examine the output of the MSE. "],
["examining-the-mse-object.html", "Chapter 7 Examining the MSE object 7.1 The MSE Object 7.2 Performance Metrics 7.3 Plotting the MSE Results 7.4 Subsetting the MSE Object 7.5 Value of Information", " Chapter 7 Examining the MSE object In the Chapter 6 we used the DLMtool to run a Management Strategy Evaluation for the blue shark stock. The output of the MSE was saved to an object, of the class MSE, called BSharkMSE. You should be able to create the BSharkMSE object following the steps outlined in the previous chapters. 7.1 The MSE Object The names of the slots in an object of class MSE can be displayed using the slotNames function: slotNames(BSharkMSE) ## [1] &quot;Name&quot; &quot;nyears&quot; &quot;proyears&quot; &quot;nMPs&quot; &quot;MPs&quot; &quot;nsim&quot; ## [7] &quot;OM&quot; &quot;Obs&quot; &quot;B_BMSY&quot; &quot;F_FMSY&quot; &quot;B&quot; &quot;SSB&quot; ## [13] &quot;VB&quot; &quot;FM&quot; &quot;C&quot; &quot;TAC&quot; &quot;SSB_hist&quot; &quot;CB_hist&quot; ## [19] &quot;FM_hist&quot; &quot;Effort&quot; &quot;PAA&quot; &quot;CAA&quot; &quot;CAL&quot; &quot;CALbins&quot; As you can see, MSE objects contain all of the information from the MSE, stored in 24 slots. 7.1.1 The First Six Slots The first six slots contain information on the structure of the MSE. For example the first slot (Name), is a combination of the names of the Stock, Fleet, and Obs objects that were used in the MSE: BSharkMSE@Name ## [1] &quot;Stock:Blue shark Fleet:Generic_fleet Obs model:Imprecise-Biased Imp model:Perfect_Imp&quot; Other information in these first slots includes the number of historical years (nyears), the number of projection years (proyears), the number of name of the Management Procedures (nMPs and MPs), and the number of simulations (nsim). 7.1.2 The OM Slot The OM slot in the MSE object is a data frame that the values of the parameters used in the Operating Model: names(BSharkMSE@OM) ## [1] &quot;RefY&quot; &quot;M&quot; &quot;Depletion&quot; &quot;A&quot; ## [5] &quot;SSBMSY_SSB0&quot; &quot;FMSY_M&quot; &quot;Mgrad&quot; &quot;Msd&quot; ## [9] &quot;procsd&quot; &quot;Esd&quot; &quot;dFfinal&quot; &quot;MSY&quot; ## [13] &quot;qinc&quot; &quot;qcv&quot; &quot;FMSY&quot; &quot;Linf&quot; ## [17] &quot;K&quot; &quot;t0&quot; &quot;hs&quot; &quot;Linfgrad&quot; ## [21] &quot;Kgrad&quot; &quot;Linfsd&quot; &quot;recgrad&quot; &quot;Ksd&quot; ## [25] &quot;ageM&quot; &quot;L5&quot; &quot;LFS&quot; &quot;Vmaxlen&quot; ## [29] &quot;LFC&quot; &quot;OFLreal&quot; &quot;Spat_targ&quot; &quot;Frac_area_1&quot; ## [33] &quot;Prob_staying&quot; &quot;AC&quot; &quot;L50&quot; &quot;L95&quot; ## [37] &quot;B0&quot; &quot;N0&quot; &quot;SSB0&quot; &quot;BMSY_B0&quot; ## [41] &quot;TACSD&quot; &quot;TACFrac&quot; &quot;ESD&quot; &quot;EFrac&quot; ## [45] &quot;SizeLimSD&quot; &quot;SizeLimFrac&quot; &quot;Blow&quot; &quot;BMSY&quot; ## [49] &quot;SSBMSY&quot; &quot;Mexp&quot; &quot;Fdisc&quot; &quot;LR5&quot; ## [53] &quot;LFR&quot; &quot;Rmaxlen&quot; &quot;DR&quot; If you use the dim function to report the dimensions of the OM data frame, you’ll notice that there are 55 columns, corresponding to the 55 parameters in the Operating Model, and 300 rows, each corresponding to a single simulation of the MSE. 7.1.3 The Obs Slot The Obs slot contains another data frame, this one with 28 columns corresponding to the values drawn from the Observation model: names(BSharkMSE@Obs) ## [1] &quot;Csd&quot; &quot;Cbias&quot; &quot;CAA_nsamp&quot; &quot;CAA_ESS&quot; &quot;CAL_nsamp&quot; ## [6] &quot;CAL_ESS&quot; &quot;CALcv&quot; &quot;betas&quot; &quot;Isd&quot; &quot;Derr&quot; ## [11] &quot;Dbias&quot; &quot;Mbias&quot; &quot;FMSY_Mbias&quot; &quot;lenMbias&quot; &quot;LFCbias&quot; ## [16] &quot;LFSbias&quot; &quot;Aerr&quot; &quot;Abias&quot; &quot;Kbias&quot; &quot;t0bias&quot; ## [21] &quot;Linfbias&quot; &quot;Irefbias&quot; &quot;Crefbias&quot; &quot;Brefbias&quot; &quot;Recsd&quot; ## [26] &quot;LenCVbias&quot; &quot;hbias&quot; &quot;BMSY_B0bias&quot; The Obs data frame also has 300 rows, each corresponding to a single simulation. The information contained in the OM and Obs slots can be used to examine the sensitivity of the performance of Management Procedures with respect to different operating model and observation parameters. This is discussed in more detail below. 7.1.4 The B_BMSY and F_FMSY Slots The B_BMSY and F_FMSY are data frames containing the biomass relative to biomass at maximum sustainable yield \\(\\left(\\frac{B}{B_{MSY}}\\right)\\), and fishing mortality relative to the rate corresponding to maximum sustainable yield \\(\\left(\\frac{F}{F_{MSY}}\\right)\\) for each simulation, Management Procedure and projection year. If we look at the class of the B_BMSY slot, we see that it is an array: class(BSharkMSE@B_BMSY) ## [1] &quot;array&quot; Using the dim function we can see that it is a 3-dimensional array, with the size corresponding to the number of simulations (nsim), the number of Management Procedures (nMPs), and the number of projection years (proyears): dim(BSharkMSE@B_BMSY) ## [1] 300 5 50 This information can be used to calculate statistics relating to the performance of each Management Procedure with respect to these metrics. For example, if you wish to look at the distribution of \\(\\frac{B}{B_{MSY}}\\) for the second Management Procedure (DCAC), you could use the boxplot function: boxplot(BSharkMSE@B_BMSY[,2,], xlab=&quot;Year&quot;, ylab=&quot;B/BMSY&quot;) This plot shows that the relative biomass for the stock generally increases through the projection period when the DCAC method is used, with the median relative biomass increasing from about 0.89 in the first year to 1.55 in the final year. However, the distribution appears to have quite high variability, which suggests that although the method works well on average, the final biomass was very low in some simulations. We will look at more aspects of plotting the MSE results in the sections below. 7.1.5 The B, FM, and C Slots The B, FM, and C slots contain the information relating to the stock biomass, the fishing mortality rate, and the catch for each simulation, Management Procedure, and projection year. Typically, the MSE model in the DLMtool does not include information on the absolute scale of the stock biomass or recruitment, and all results usually must be interpreted in a relativistic context. This is particularly true for the biomass (B) and catch (C) where the absolute values in the MSE results (other than 0!) have little meaning. The biomass can by made relative to \\(B_{MSY}\\), as shown above. Alternatively, biomass can be calculated with respect to the unfished biomass \\(\\left(B_0\\right)\\), from information stored in the OM slot. The catch information is usually made relative to the highest long-term yield (mean over last five years of projection) for each simulation obtained from a fixed F strategy. This information (RefY) can be found in the OM slot. Alternatively, the catch can be made relative to the catch in last historical year (CB_hist; see below), to see how future catches are expected to change relative to the current conditions. Examples of this are shown in sections below. 7.1.6 The TAC Slot Currently, the information in this slot is identical to that in the Catch (C) slot. This may change when an implementation error model is included in the DLMtool. 7.1.7 The SSB_hist, CB_hist, and FM_hist Slots The SSB_hist, CB_hist, and FM_hist slots contain information on the spawning stock biomass, the catch biomass, and the fishing mortality from the historical period (the nyears in the operating model). These data frames differ from the previously discussed slots as they are 4-dimensional arrays, with dimensions corresponding to the simulation, the age classes, the historical year, and the spatial areas. The apply function can be used to aggregate these data over the age-classes or spatial areas. 7.1.8 The Effort Slot The Effort slot is a 3-dimensional array containing information on the relative fishing effort (relative to last historical year, or current conditions) for each simulation, Management Procedure and projection year. We can look at the distribution of fishing effort for each Management Procedure in the final year of the projection period: pyear &lt;- BSharkMSE@proyears boxplot(BSharkMSE@Effort[,, pyear], outline=FALSE, names=BSharkMSE@MPs, ylab=&quot;Relative fishing effort&quot;) This plot shows that the median fishing effort in the final year ranges from 0.39 to 0.6 for the first four output control methods, and is constant for the input control method (matlenlim). This is because the output control method adjusts the total allowable catch, which depending on the amount of available stock, also impacts the amount of fishing activity. The input control methods assume that fishing effort is held at constant levels in the future, although the catchability is able to randomly or systematically vary between years. Furthermore, input control methods can also adjust the amount of fishing effort in each year. 7.2 Performance Metrics A key use of the DLMtool is to evaluate the trade-offs in the performance of different potential Management Procedures and to assist in the decision-making process as to which Management Procedure is most likely to satisfy the various management objectives under realistic range of uncertainty and variability in the system. 7.2.1 The Need for Performance Metrics In order to evaluate the relative effectiveness of different Management Procedures, it is important that decision-makers have clearly-defined management objectives. These management objectives can be incorporated into the MSE process in the form of performance metrics, which provide the yardstick with which to compare the relative performance of different management strategies. Fisheries managers are confronted with the difficult task of maximizing yield and ensuring the sustainability of the resource and the overall health of the marine environment. The principal objectives of fisheries management could be described as ensuring sustainable harvests and viable fishing communities, while maintaining healthy ecosystems. However, this simplistic view overlooks the fact that there are often conflicts in different management objectives and that there is rarely an optimal management approach that fully satisfies all management objectives (Punt, 2015). Walters and Martell (2004) explain that the task of modern fisheries management is to identify the various trade-offs among conflicting objectives and decide how to balance them in a satisfactory way. 7.2.2 Inevitable Trade-Offs A typical trade-off is the abundance of the target species versus the catch. Assuming no significant system-wide natural perturbations, a fish stock may be exploited sustainability if catches are set at low levels. However, such economic under-utilization of the resource is often seen as undesirable. Alternatively, high catches may produce immediate short-term benefits, but may result in long-term degradation, or perhaps collapse, of the stock. Additionally, there is often a trade-off between stock size and fishing effort, which results in lower catch rates (and lower profit) for individual fishers when a large number of fishers are active in the fishery (Walters and Martell, 2004). Other common trade-offs include the age and size at first capture, either delaying harvest until individuals are fewer in number (due to natural mortality) but larger in size, or capturing a large number of small sized fish (Punt, 2015). When multiple objectives are considered, there is usually not a single optimum solution, and fisheries managers are faced with the difficult task of determining the most appropriate management action that satisfies the numerous management objectives and stakeholder interests (Punt, 2015). 7.2.3 Operational Management Objectives A key strength of the MSE approach is that decision-makers are required to specify clear objectives, which can be classified as either “conceptual” or “operational” (Punt et al., 2014). Conceptual objectives are typically high-level policy goals that may be broadly defined. However, in order to be included in an MSE, conceptual objectives must be translated into operational objectives (i.e., expressed as values for performance metrics). Such operational objectives, or performance metrics, may consist of both a reference point (e.g., biomass some fraction of equilibrium unfished level) as well as a measure of the acceptable associated risk (e.g., less than 10% chance that biomass declines below this reference level). It is not unusual that some of the management objectives are in conflict. A key benefit of the MSE approach is to highlight these trade-offs among the different management objectives to guide the decision-making process. However, in order for these trade-offs to be quantified, it is critically important that the performance metrics are quantifiable and thus able to be incorporated into the MSE framework (Punt, 2015). 7.2.4 Performance Metrics in the DLMtool Management strategy evaluation is a simulation exercise where the model can track the specific performance with perfect information, so it is possible to state performance objectives in specific terms that are consistent with the typical objectives of fisheries policies, such as: Biomass relative to unfished biomass \\(\\left(B_0\\right)\\) or biomass at maximum sustainable yield \\(\\left(B_{MSY}\\right)\\). Fishing mortality rate relative to fishing at maximum sustainable yield \\(\\left(F_{MSY}\\right)\\). Yield (short-term or long-term) of a particular management strategy relative to the yield if the fishery were being exploited at \\(F_{MSY}\\). Inter-annual variability in yield or effort (e.g., fluctuations in yield from year to year). Because the management strategy evaluation runs many simulations of the fisheries performance under each management strategy being tested, the performance can be stated probabilistically, such as the specific probability of biomass being above or below a specific biomass threshold or target. 7.2.4.1 Fishing Mortality For example, the management strategies can be ranked by the likelihood of overfishing to occur, where the probability of overfishing is measured by the proportion of simulation runs where the fishing mortality rate (F) under a specific management strategy is higher than the F that is expected to produce the maximum sustainable yield. Management strategies that have a lower probability of overfishing occurring are typically preferable to those that frequently cause excessive fishing mortality rates. If there are 1,000 simulation runs for each management strategy over a 50-year projection period, then the probability of overfishing could be based on the proportion where F is greater than (or less than) \\(F_{MSY}\\) over all years or any subset of years (e.g., probability of overfishing in years 41-50 of the 50-year projection period). 7.2.4.2 Stock Biomass Another performance metric included in DLMtool is the probability that the stock biomass is above or below some biological reference point. For example, a minimum performance limit may be half the biomass at maximum sustainable yield (0.5 BMSY), and the performance of the management strategies can be ranked by the probability of the stock remaining above this level. Management strategies that fail to maintain biomass above this limit with a high priority may be considered too risky and therefore excluded from further examination. 7.2.5 Developing Additional Performance Metrics There may be other performance metrics that are of interest to fishery managers and stakeholders. Stakeholder participation is critical when developing performance metrics to evaluate different biological scenarios or management strategies in a MSE. Furthermore, it is important that the performance metrics, together with any acceptable risk thresholds are identified and agreed upon before the MSE is conducted. The DLMtool can be customized to track and display additional performance metrics as identified by stakeholders. 7.2.6 Summarizing Management Procedure Performance The information in the MSE object can be summarized in a number of ways. The summary function provides information on the performance of the Management Procedures with respect to various metrics, including the probability of overfishing, and the probability that the biomass is below various reference levels: summary(BSharkMSE) ## MP Yield stdev POF stdev P10 stdev P50 stdev P100 stdev ## 1 Fratio 56.57 45.86 37.19 41.64 15.01 30.64 31.23 40.40 46.76 42.63 ## 2 DCAC 57.97 47.11 24.11 38.59 13.49 30.56 19.43 35.43 31.83 38.50 ## 3 Fdem 58.65 43.86 42.12 42.84 17.93 33.06 35.20 41.83 50.70 42.95 ## 4 DD 72.75 39.17 39.53 30.24 13.07 23.86 31.29 31.56 56.39 33.24 ## 5 matlenlim 88.11 50.93 49.79 38.28 0.36 3.04 9.47 21.95 28.03 35.13 ## LTY STY VY ## 1 49.8 54.0 43.7 ## 2 58.7 62.1 91.0 ## 3 55.7 58.8 38.3 ## 4 74.7 72.0 73.3 ## 5 72.5 48.5 0.0 This information can be used to identify poorly performing methods, and exclude them from further, perhaps more comprehensive, runs of the MSE. 7.3 Plotting the MSE Results The DLMtool has 22 plotting functions which can be used to examine the performance of the Management Procedures. 7.3.1 Trade-off Plots One of the most common use of a MSE is to examine the trade-offs in the performance of alternative management procedures. The DLMtool has a number of functions to examine these trade-offs, and users of the Toolkit can easily develop their own. The Tplot function creates four plots that show the trade-off between the expected relative yield and the probability of overfishing and the probability of the biomass being below three different reference points: Tplot(BSharkMSE) In this case, the plot shows that the matlenlim method results in the highest long-term yield, and also one of the lower probabilities that the biomass will fall below \\(0.5B_{MSY}\\). The Tplot2 function shows the trade-off between long-term and short-term yield, and the trade-off between biomass being above \\(0.1B_{MSY}\\) and the expected variability in the yield: Tplot2(BSharkMSE) The NOAA_plot function was developed from applications of the DLMtool to fisheries in the Caribbean. This plot shows the trade-offs between the probability of not overfishing and long-term yield, and the probability of not being in an overfished state versus the probability of the annual variation in yield being less than 15%: NOAA_plot(BSharkMSE) ## PNOF B50 LTY VY ## Fratio 62.8 68.8 49.7 62.0 ## DCAC 75.9 80.6 58.0 86.3 ## Fdem 57.9 64.8 56.7 54.3 ## DD 60.5 68.7 75.0 74.0 ## matlenlim 50.2 90.5 71.6 0.0 7.3.2 Boxplot The distribution of various statistics can be examined for the Management Procedures using the boxplot function: boxplot(BSharkMSE) ## Calculating MP Performance for last 10 years boxplot is a generic function, which means that its behavior depends on the class of object that is supplied to it. In this case, R recognizes that we pass an object of class MSE to the boxplot function, and calls the appropriate plotting function boxplot.MSE. The boxplot.MSE function has a number of arguments which allow users to control various aspects of the plot. You can display the arguments by using the args function (args(boxplot.MSE)) or looking at the help documentation (?boxplot.MSE). 7.3.3 Barplot The barplot function is another generic function, which calls barplot.MSE when it is supplied with an object of class MSE. The barplot function shows the probability of each Management Procedure meeting the specified performance criteria: out &lt;- barplot(BSharkMSE) ## Calculating MP Performance for last 10 years Many aspects of the plot can be controlled using the arguments to the barplot.MSE function, including the number of years over which to calculate the probabilities, as well control the performance metrics that shown in the plot. The barplot function returns invisible output, which we have captured here by assigning the output of the function to the variable out. We can display this output by typing out into the R console: out ## MP B_BMSYp SSB_SSB0p Pass MPClass ## 1 Fdem 64 60 FALSE Output ## 2 Fratio 67 63 FALSE Output ## 3 DD 74 63 FALSE Output ## 4 DCAC 77 74 FALSE Output ## 5 matlenlim 91 84 TRUE Input This data frame displays the probability with respect to the different performance metrics, as well as whether the Management Procedure passed or failed the specified level of acceptable risk. In this can, we can see that the matlenlim method is the only method that meets the requirement of at least 80% probability that the biomass in the last 10 years of the projection period is above \\(0.5B_{MSY}\\) and above \\(0.2B_0\\). 7.3.4 Joint Probability Plot The previous plots calculate the probability of that Management Procedure will meet individual performance criteria. An alternative is to calculate the probability that a Management Procedure will simultaneously meet all of the performance criteria. The Jplot function has been designed to calculate and display the joint probability of meeting multiple criteria. For example, the plot below calculates the probability that the biomass in the last 10 years of the projection period is above \\(0.5B_{MSY}\\) and \\(0.2B_0\\) for each of the 5 Management Procedures included in the MSE: Jplot(BSharkMSE) ## Calculating MP Performance for last 10 years The risk threshold and the performance criteria can be adjusted in the arguments to the Jplot function. 7.3.5 Wormplot The wormplot function plots the likelihood of meeting biomass targets in future years: wormplot(BSharkMSE) The arguments to the wormplot function allow you to choose the reference level for the biomass relative to \\(B_{MSY}\\), as well as the upper and lower bounds of the colored bands. 7.3.6 Projection Plots The Pplot function plots the trajectories of biomass, fishing mortality, and relative yield for the Management Procedures. By default, the Pplot function shows the individual trajectories of \\(B/B_{MSY}\\) and \\(F/F_{MSY}\\) for each simulation: Pplot(BSharkMSE) The Pplot2 function has several additional arguments. The YVar argument can be used to specify additional variables of interest. For example, here we have included the projections of yield relative to the long-term optimum yield: Pplot2(BSharkMSE, YVar=c(&quot;B_BMSY&quot;, &quot;F_FMSY&quot;, &quot;Yield&quot;)) The traj argument can be used to summarize the projections into quantiles. Here we show the 20th and 80th percentiles of the distributions (the median (50th percentile) is included by default): Pplot2(BSharkMSE, traj=&quot;quant&quot;, quants=c(0.2, 0.8)) Details on additional controls for the Pplot and Pplot2 functions can be found in the help documentation associated with this function. 7.3.7 Kobe Plots Kobe plots are often used in stock assessment and MSE to examine the proportion of time the stock spends in different states. A Kobe plot of the MSE results can be produced with the Kplot function: Kplot(BSharkMSE) Because of the way it uses transparent colors to show the overlapping lines, the Kplot function can take a long time to render, especially on machines with a Windows OS. 7.3.8 Scatter Plots The Splot function can be used to create a simulation-by-simulation scatter plot of the relative fishing mortality and stock biomass for each Management Procedure: Splot(BSharkMSE) ## Calculating MP Performance for last 10 years 7.3.9 Compare to Current Conditions The Cplot shows a scatter plot of the median biomass and median yield over the last five years of the projection relative to the current conditions (the last year in the historical period): Cplot(BSharkMSE, ShowLabs=TRUE) ## Calculating MP Performance for last 5 years In this example, the results show that catches in the future are likely to be lower than the current levels of catch regardless of which Management Procedure is used. However, the future median biomass for the DD and Fdem methods is also lower than the current levels, which suggests that, in this case, these two methods result in both lower catches and lower biomass and are probably not the most suitable for managing this fishery. 7.3.10 List the MSE Plotting Functions You can see a list of all the plotting functions in the DLMtool for MSE objects using the plotFun function: plotFun() ## DLMtool functions for plotting objects of class MSE are: ## barplot boxplot COSEWIC_plot Cplot DFO_plot ## DFO_plot2 IOTC_plot Jplot Kplot NOAA_plot ## plotFleet plotOFL Pplot Pplot2 Splot ## Tplot Tplot2 TradePlot VOI VOI2 ## VOIplot wormplot 7.4 Subsetting the MSE Object The plotting functions demonstrated above calculate the probabilities and show the trade-offs for all the simulations in the MSE. However, sometimes it is interesting to examine the results of individual Management Procedures or simulations. Many of the plotting functions have the optional arguments MPs and sims which allow you to specify which particular Management Procedures or simulations to include in the plots. You can also manually subset the MSE object using the Sub function. 7.4.1 Subsetting by Performance For example, we may wish to exclude any Management Procedures that have less than 30% probability that the biomass is below \\(0.5B_{MSY}\\), and focus our analysis on the remaining Management Procedures. We can do this using a combination of the summary function and the Sub function: stats &lt;- summary(BSharkMSE) # save summary object to `stats` accept &lt;- which(stats$P50 &lt; 30) # index of methods that pass the criteria MPs &lt;- stats[accept,&quot;MP&quot;] # the acceptable MPs subMSE &lt;- Sub(BSharkMSE, MPs=MPs) Here we can see that the DCAC, matlenlim methods (2 of the 5) met our specified criteria. We used the Sub function to create a new MSE object that only includes these Management Procedures. We can than proceed to continue our analysis on the subMSE object, e.g.: Tplot(subMSE) 7.4.2 Subsetting by Operating Model Parameters We can also subset the MSE object by simulation. For example, we may be interested to look at how the methods perform under different assumptions about the natural mortality rate (M). In this MSE M ranged from 0.15 to 0.25. Here we identify the simulations where M was below and above the median rate: below &lt;- BSharkMSE@OM$M &lt; median(BSharkMSE@OM$M) above &lt;- BSharkMSE@OM$M &gt; median(BSharkMSE@OM$M) We can then use the Sub function to create two MSE objects, one only including simulations with lower values of M, and the other with simulations where M was above the median value: belowMSE &lt;- Sub(BSharkMSE, sims=below) aboveMSE &lt;- Sub(BSharkMSE, sims=above) You can see that the original MSE object has been split into two objects, each with half of the simulations: belowMSE@nsim ## [1] 150 aboveMSE@nsim ## [1] 150 We could then continue our analysis on each subset MSE and determine if the natural mortality rate is critical in determining which Management Procedure we would choose as the best option for managing the fishery. 7.5 Value of Information In the last section we looked at how the MSE object can subset by simulations which allows us to explore the sensitivity to various operating model parameters. However, this method only allows us the examine the sensitivity to a single parameter at a time. The Value of Information (VOI) functions have been designed to explore the sensitivity of the performance of the Management Procedures in more detail. 7.5.1 Observation Parameters The VOIplot function shows how the relative long-term yield changes with respect to the Observation parameters: VOIplot(BSharkMSE, nMP=5) By default, the VOIplot function only shows the four Management Procedures with the greatest sensitivity. Here we’ve made it show all five methods using the nMP argument. In this example, we can see that the Fratio method is particularly sensitive to bias in the current estimate of abundance, and over-estimates of the current abundance result in very low long-term yield (probably do to collapse of the stock). The DCAC method appears most sensitive to bias in the estimated catch. 7.5.2 Operating Model Parameters We can also look at the sensitivity with respect to the Operating Model parameters: VOIplot(BSharkMSE, Par=&quot;OM&quot;, nMP=5) Here we can see that the Fratio method is most sensitive to \\(F_{MSY}/M\\), with yield generally increasing for higher values of the ratio. We can also use the VOIplot function to look at the sensitivity with respect to the final biomass by specifying the YVar argument: VOIplot(BSharkMSE, Par=&quot;OM&quot;, nMP=5, YVar=&quot;B&quot;) This result shows, perhaps unsurprisingly, that the final biomass is often strongly sensitive to the initial depletion, particularly for the DCAC and matlenlim methods. The DLMtool also includes other value of information functions (VOI and VOI2) which present this information in alternative ways. "],
["managing-fishery-data.html", "Chapter 8 Managing Fishery Data 8.1 The Fishery Data Object (Data) 8.2 Example Data Objects 8.3 Creating Your Own Data Object 8.4 Working With Data Objects 8.5 Applying Management Procedures", " Chapter 8 Managing Fishery Data 8.1 The Fishery Data Object (Data) The second argument for all Management Procedures in the DLMtool is something called Data. Data is an object class in the DLMtool that contains all of the fishery information that can be used by the Management Procedure. You find the documentation for the Data class by typing: class?Data You can see from the documentation that the Data object, or Fishery Data object, contains many slots, and a lot of information can be stored in this object, including biological parameters, fishery statistics such as time-series of catch, and past management recommendations. 8.1.1 In the MSE In the MSE the Fishery Data object is populated with data that is generated by the simulation model. Here the ‘true’ data generated by the model is filtered through the Observation Model (using the Observation parameters) and entered into the Fishery Data object to represent typical fisheries data. The MSE consists of many hundreds of simulations, and because the DLMtool has been designed for parallel processing, the Fishery Data object in the MSE actually consists of hundreds of ‘versions’ of the simulated fishery data. The first argument for all Management Procedure functions is x, which is the position in the Data object that refers to the data corresponding that particular iteration. In the MSE, the value of x goes from 1 to the total number of simulations (nsim). 8.1.2 Application of Management Procedures Using Real Fisheries Data In contrast to the MSE, in the real world application of a Management Procedure, we only have one version of the fishery data: the data that has been collected from the fishery. The Fishery Data object contains all of the fishery information that can be used by a Management Procedure. By definition, many sources of data are not available in data-limited fisheries, and the Fishery Data object may not be completely populated. The DLMtool can be used to determine which of the Management Procedures in the Toolkit are available to be used given the data in the Fishery Data object, which methods cannot be used, and what data are required to make these methods available. More information on applying Management Procedures to fishery data can be found in the [Application of Management Procedure] section. 8.2 Example Data Objects The DLMtool package has a number of example Fishery Data objects. This can be listed using the avail function: avail(&quot;Data&quot;) ## [1] &quot;Atlantic_mackerel&quot; &quot;China_rockfish&quot; &quot;Cobia&quot; ## [4] &quot;Example_datafile&quot; &quot;Gulf_blue_tilefish&quot; &quot;ourReefFish&quot; ## [7] &quot;Red_snapper&quot; &quot;Simulation_1&quot; This shows us that there is 8 example Fishery Data objects in the DLMtool. 8.3 Creating Your Own Data Object DLMtool has a series of functions to make importing data and applying data-limited Management Procedures relatively straightforward. There are two approaches: Fill out a .csv data file in excel or a text editor and use a DLMtool function to create a properly formatted Data object (class Data), or Create a blank Data object and populate it in R. 8.3.1 Creating a CSV Data File Probably the easiest way to get your data into the DLMtool is to populate a .csv data file. These files have a line for each slot of the Data object: slotNames(&#39;Data&#39;) ## [1] &quot;Name&quot; &quot;Year&quot; &quot;Cat&quot; &quot;Ind&quot; &quot;Rec&quot; ## [6] &quot;t&quot; &quot;AvC&quot; &quot;Dt&quot; &quot;Mort&quot; &quot;FMSY_M&quot; ## [11] &quot;BMSY_B0&quot; &quot;Cref&quot; &quot;Bref&quot; &quot;Iref&quot; &quot;L50&quot; ## [16] &quot;L95&quot; &quot;LFC&quot; &quot;LFS&quot; &quot;CAA&quot; &quot;Dep&quot; ## [21] &quot;Abun&quot; &quot;SpAbun&quot; &quot;vbK&quot; &quot;vbLinf&quot; &quot;vbt0&quot; ## [26] &quot;LenCV&quot; &quot;wla&quot; &quot;wlb&quot; &quot;steep&quot; &quot;CV_Cat&quot; ## [31] &quot;CV_Dt&quot; &quot;CV_AvC&quot; &quot;CV_Ind&quot; &quot;CV_Mort&quot; &quot;CV_FMSY_M&quot; ## [36] &quot;CV_BMSY_B0&quot; &quot;CV_Cref&quot; &quot;CV_Bref&quot; &quot;CV_Iref&quot; &quot;CV_Rec&quot; ## [41] &quot;CV_Dep&quot; &quot;CV_Abun&quot; &quot;CV_vbK&quot; &quot;CV_vbLinf&quot; &quot;CV_vbt0&quot; ## [46] &quot;CV_L50&quot; &quot;CV_LFC&quot; &quot;CV_LFS&quot; &quot;CV_wla&quot; &quot;CV_wlb&quot; ## [51] &quot;CV_steep&quot; &quot;sigmaL&quot; &quot;MaxAge&quot; &quot;Units&quot; &quot;Ref&quot; ## [56] &quot;Ref_type&quot; &quot;Log&quot; &quot;params&quot; &quot;PosMPs&quot; &quot;MPs&quot; ## [61] &quot;OM&quot; &quot;Obs&quot; &quot;TAC&quot; &quot;Sense&quot; &quot;CAL_bins&quot; ## [66] &quot;CAL&quot; &quot;MPrec&quot; &quot;MPeff&quot; &quot;ML&quot; &quot;Lbar&quot; ## [71] &quot;Lc&quot; &quot;LHYear&quot; &quot;nareas&quot; &quot;Misc&quot; &quot;TACbias&quot; You do not have to enter data for every line of the data file, if data are not available simply put an ‘NA’ next to any given field. 8.3.1.1 Example Fishery Data CSV Files There are also CSV files for these example Fishery Data objects that are included in the DLMtool package. To find the location where these files are located on your machine, use the DLMDataDir function: DLMDataDir() ## [1] &quot;C:/Users/arhor/Documents/R/win-library/3.4/DLMtool/&quot; We can then load one of the example CSV files using the new function: China_rockfish2 &lt;- new(&quot;Data&quot;, paste0(DLMDataDir(),&quot;China_rockfish.csv&quot;)) Alternatively, you can navigate to the data directory on your machine and examine the contents and structure of the CSV data files in MS Excel or other software. 8.3.2 Populating a Data Object in R Alternatively you can create a blank Data object and fill the slots directly in R. For example: Madeup &lt;- new(&#39;Data&#39;) # Create a blank DLM object ## [1] &quot;Couldn&#39;t find specified csv file, blank DLM object created&quot; Madeup@Name &lt;- &#39;Test&#39; # Name it Madeup@Cat &lt;- matrix(20:11*rlnorm(10,0,0.2),nrow=1) # Generate fake catch data Madeup@Units &lt;- &quot;Million metric tonnes&quot; # State units of catch Madeup@AvC &lt;- mean(Madeup@Cat) # Average catches for time t (DCAC) Madeup@t &lt;- ncol(Madeup@Cat) # No. yrs for Av. catch (DCAC) Madeup@Dt &lt;- 0.5 # Depletion over time t (DCAC) Madeup@Dep &lt;- 0.5 # Depletion relative to unfished Madeup@vbK &lt;- 0.2 # VB maximum growth rate Madeup@vbt0 &lt;- (-0.5) # VB theoretical age at zero length Madeup@vbLinf &lt;- 200 # VB maximum length Madeup@Mort &lt;- 0.1 # Natural mortality rate Madeup@Abun &lt;- 200 # Current abundance Madeup@FMSY_M &lt;- 0.75 # Ratio of FMSY/M Madeup@L50 &lt;- 100 # Length at 50% maturity Madeup@L95 &lt;- 120 # Length at 95% maturity Madeup@BMSY_B0 &lt;- 0.35 # BMSY relative to unfished 8.4 Working With Data Objects A generic summary function is available to visualize the data in a Data object: summary(Atlantic_mackerel) You can see what Management Procedures can and can’t be applied given your data and also what data are needed to get them working: Can(Atlantic_mackerel) ## [1] &quot;AvC&quot; &quot;BK&quot; &quot;CC1&quot; &quot;CC4&quot; &quot;DAAC&quot; ## [6] &quot;DBSRA&quot; &quot;DBSRA_40&quot; &quot;DBSRA4010&quot; &quot;DCAC&quot; &quot;DCAC_40&quot; ## [11] &quot;DCAC4010&quot; &quot;DD&quot; &quot;DD4010&quot; &quot;DepF&quot; &quot;DynF&quot; ## [16] &quot;Fadapt&quot; &quot;Fdem&quot; &quot;Fratio&quot; &quot;Fratio4010&quot; &quot;GB_slope&quot; ## [21] &quot;Gcontrol&quot; &quot;HDAAC&quot; &quot;Itarget1&quot; &quot;Itarget4&quot; &quot;MCD&quot; ## [26] &quot;MCD4010&quot; &quot;NFref&quot; &quot;Rcontrol&quot; &quot;Rcontrol2&quot; &quot;SBT1&quot; ## [31] &quot;SPmod&quot; &quot;SPMSY&quot; &quot;SPslope&quot; &quot;SPSRA&quot; &quot;YPR&quot; ## [36] &quot;curE&quot; &quot;curE75&quot; &quot;DDe&quot; &quot;DDe75&quot; &quot;matlenlim&quot; ## [41] &quot;matlenlim2&quot; &quot;MRnoreal&quot; &quot;MRreal&quot; &quot;slotlim&quot; &quot;area1_50&quot; Cant(Atlantic_mackerel) ## [,1] [,2] ## [1,] &quot;BK_CC&quot; &quot;Insufficient data&quot; ## [2,] &quot;BK_ML&quot; &quot;Insufficient data&quot; ## [3,] &quot;CompSRA&quot; &quot;Insufficient data&quot; ## [4,] &quot;CompSRA4010&quot; &quot;Insufficient data&quot; ## [5,] &quot;DBSRA_ML&quot; &quot;Insufficient data&quot; ## [6,] &quot;DCAC_ML&quot; &quot;Insufficient data&quot; ## [7,] &quot;Fdem_CC&quot; &quot;Insufficient data&quot; ## [8,] &quot;Fdem_ML&quot; &quot;Insufficient data&quot; ## [9,] &quot;FMSYref&quot; &quot;Insufficient data&quot; ## [10,] &quot;FMSYref50&quot; &quot;Insufficient data&quot; ## [11,] &quot;FMSYref75&quot; &quot;Insufficient data&quot; ## [12,] &quot;Fratio_CC&quot; &quot;Insufficient data&quot; ## [13,] &quot;Fratio_ML&quot; &quot;Insufficient data&quot; ## [14,] &quot;GB_CC&quot; &quot;Insufficient data&quot; ## [15,] &quot;GB_target&quot; &quot;Insufficient data&quot; ## [16,] &quot;Islope1&quot; &quot;Insufficient data&quot; ## [17,] &quot;Islope4&quot; &quot;Insufficient data&quot; ## [18,] &quot;IT10&quot; &quot;Insufficient data&quot; ## [19,] &quot;IT5&quot; &quot;Insufficient data&quot; ## [20,] &quot;ITM&quot; &quot;Insufficient data&quot; ## [21,] &quot;L95target&quot; &quot;Insufficient data&quot; ## [22,] &quot;LBSPR_ItTAC&quot; &quot;Insufficient data&quot; ## [23,] &quot;LstepCC1&quot; &quot;Insufficient data&quot; ## [24,] &quot;LstepCC4&quot; &quot;Insufficient data&quot; ## [25,] &quot;Ltarget1&quot; &quot;Insufficient data&quot; ## [26,] &quot;Ltarget4&quot; &quot;Insufficient data&quot; ## [27,] &quot;SBT2&quot; &quot;Insufficient data&quot; ## [28,] &quot;SPSRA_ML&quot; &quot;Insufficient data&quot; ## [29,] &quot;YPR_CC&quot; &quot;Insufficient data&quot; ## [30,] &quot;YPR_ML&quot; &quot;Insufficient data&quot; ## [31,] &quot;DDes&quot; &quot;Insufficient data&quot; ## [32,] &quot;DTe40&quot; &quot;Insufficient data&quot; ## [33,] &quot;DTe50&quot; &quot;Insufficient data&quot; ## [34,] &quot;EtargetLopt&quot; &quot;Insufficient data&quot; ## [35,] &quot;ItargetE1&quot; &quot;Insufficient data&quot; ## [36,] &quot;ItargetE4&quot; &quot;Insufficient data&quot; ## [37,] &quot;ITe10&quot; &quot;Insufficient data&quot; ## [38,] &quot;ITe5&quot; &quot;Insufficient data&quot; ## [39,] &quot;LBSPR_ItEff&quot; &quot;Insufficient data&quot; ## [40,] &quot;LBSPR_ItSel&quot; &quot;Insufficient data&quot; ## [41,] &quot;LstepCE1&quot; &quot;Insufficient data&quot; ## [42,] &quot;LstepCE2&quot; &quot;Insufficient data&quot; ## [43,] &quot;LtargetE1&quot; &quot;Insufficient data&quot; ## [44,] &quot;LtargetE4&quot; &quot;Insufficient data&quot; ## [45,] &quot;minlenLopt1&quot; &quot;Insufficient data&quot; Needed(Atlantic_mackerel) ## [1] &quot;BK_CC: CAA&quot; &quot;BK_ML: CAL&quot; ## [3] &quot;CompSRA: CAA&quot; &quot;CompSRA4010: CAA&quot; ## [5] &quot;DBSRA_ML: CAL&quot; &quot;DCAC_ML: CAL&quot; ## [7] &quot;Fdem_CC: CAA&quot; &quot;Fdem_ML: CAL&quot; ## [9] &quot;FMSYref: OM&quot; &quot;FMSYref50: OM&quot; ## [11] &quot;FMSYref75: OM&quot; &quot;Fratio_CC: CAA&quot; ## [13] &quot;Fratio_ML: CAL&quot; &quot;GB_CC: Cref&quot; ## [15] &quot;GB_target: Cref, Iref&quot; &quot;Islope1: MPrec&quot; ## [17] &quot;Islope4: MPrec&quot; &quot;IT10: Iref, MPrec&quot; ## [19] &quot;IT5: Iref, MPrec&quot; &quot;ITM: Iref, MPrec&quot; ## [21] &quot;L95target: ML&quot; &quot;LBSPR_ItTAC: CAL, MPrec&quot; ## [23] &quot;LstepCC1: MPrec, ML&quot; &quot;LstepCC4: MPrec, ML&quot; ## [25] &quot;Ltarget1: ML&quot; &quot;Ltarget4: ML&quot; ## [27] &quot;SBT2: Rec, Cref&quot; &quot;SPSRA_ML: CAL&quot; ## [29] &quot;YPR_CC: CAA&quot; &quot;YPR_ML: CAL&quot; ## [31] &quot;DDes: MPeff&quot; &quot;DTe40: MPeff&quot; ## [33] &quot;DTe50: MPeff&quot; &quot;EtargetLopt: MPeff, ML&quot; ## [35] &quot;ItargetE1: MPeff&quot; &quot;ItargetE4: MPeff&quot; ## [37] &quot;ITe10: Iref, MPeff&quot; &quot;ITe5: Iref, MPeff&quot; ## [39] &quot;LBSPR_ItEff: CAL, MPeff&quot; &quot;LBSPR_ItSel: CAL&quot; ## [41] &quot;LstepCE1: MPeff, ML&quot; &quot;LstepCE2: MPeff, ML&quot; ## [43] &quot;LtargetE1: MPeff, ML&quot; &quot;LtargetE4: MPeff, ML&quot; ## [45] &quot;minlenLopt1: MPeff&quot; 8.5 Applying Management Procedures 8.5.1 Input Methods Spatial and length-vulnerability Management Procedures (class Input) can be MSE tested but are often a management recommendation in themselves (e.g., setting a static size limit or closing a spatial area). Other input control methods are dynamic and respond to trends in different indicators in the data. The Input function can be used to apply an input control method. For example, here we apply the matlenlim method to the Atlantic_mackerel data object: Input(Atlantic_mackerel, &quot;matlenlim&quot;) ## Checking which MPs can be run ## Running 1 of 1 - matlenlim ## Effort LR5 LFR Harvest Slot Limit Area 1 Area 2 ## matlenlim NA 90.25 95 NA NA NA The resulting recommendation is a size limit around 90 cm. There is no upper slot limit specified, and the fishing effort and spatial areas open to fishing remained unchanged. 8.5.2 Output Methods The TAC function can be used to calculate the recommended TAC for output controls Management Procedures. Here we apply the DCAC method, with 1,000 repetitions, to the Atlantic_mackerel data object: Atlantic_mackerel &lt;- TAC(Atlantic_mackerel, MPs=&quot;DCAC&quot;, reps=1000) The resulting distribution of the recommended TAC can be plotted using the plot function: plot(Atlantic_mackerel) We can also apply all the out control methods that can be run with the Fishery Data object to compare the resulting recommendations: Atlantic_mackerel &lt;- TAC(Atlantic_mackerel) plot(Atlantic_mackerel) Alternatively, we can use boxplot, a generic function that calls the boxplot.Data function, to display the distribution of recommended TACs and report the statistics (median and standard deviation): boxplot(Atlantic_mackerel) "],
["custom-parameters.html", "Chapter 9 Custom Parameters 9.1 Valid cpars names 9.2 Correlated samples 9.3 Custom time-varying parameters", " Chapter 9 Custom Parameters By default, DLMtool samples the operating model parameters from a uniform distribution. Because the parameters are sampled independently, it is not possible to generate correlated samples. However, the cpars slot in the OM object can be used to pass custom samples into the MSE. The addition of the cpars slot provides a lot of flexibility to the DLMtool, and allows users full control of all parameters used in the model. For example, it is possible to generate operating models directly from the output of common stock assessment packages using functions in DLMtool (e.g SS2DLM for Stock Synthesis 3, and iSCAM2DLM for a iSCAM model). These functions take the correlated parameter values from the output of the stock assessment and provide them to DLMtool via the cpars slot, resulting in an operating model that is conditioned on the stock assessment. The cpars feature is being continually developed as more features are requested for DLMtool. 9.1 Valid cpars names The cpars slot requires a named list containing the custom parameter values. You can see the valid names for cpars by typing: validcpars() ## [,1] [,2] [,3] ## [1,] &quot;Abias&quot; &quot;AC&quot; &quot;Aerr&quot; ## [2,] &quot;age95&quot; &quot;ageM&quot; &quot;betas&quot; ## [3,] &quot;Brefbias&quot; &quot;CAA_ESS&quot; &quot;CAA_nsamp&quot; ## [4,] &quot;CAL_bins&quot; &quot;CAL_binsmid&quot; &quot;CAL_ESS&quot; ## [5,] &quot;CAL_nsamp&quot; &quot;CALcv&quot; &quot;Cbias&quot; ## [6,] &quot;Crefbias&quot; &quot;Csd&quot; &quot;Dbias&quot; ## [7,] &quot;dep&quot; &quot;Derr&quot; &quot;dFfinal&quot; ## [8,] &quot;DR&quot; &quot;EffLower&quot; &quot;EffUpper&quot; ## [9,] &quot;EffYears&quot; &quot;Esd&quot; &quot;Fdisc&quot; ## [10,] &quot;Find&quot; &quot;FMSY_Mbias&quot; &quot;Frac_area_1&quot; ## [11,] &quot;hs&quot; &quot;Irefbias&quot; &quot;Isd&quot; ## [12,] &quot;K&quot; &quot;Kbias&quot; &quot;Kgrad&quot; ## [13,] &quot;Krand&quot; &quot;Ksd&quot; &quot;L5&quot; ## [14,] &quot;L50&quot; &quot;L50_95&quot; &quot;L95&quot; ## [15,] &quot;LatASD&quot; &quot;Len_age&quot; &quot;LenCV&quot; ## [16,] &quot;lenMbias&quot; &quot;LFCbias&quot; &quot;LFR&quot; ## [17,] &quot;LFS&quot; &quot;LFSbias&quot; &quot;Linf&quot; ## [18,] &quot;Linfbias&quot; &quot;Linfgrad&quot; &quot;Linfrand&quot; ## [19,] &quot;Linfsd&quot; &quot;LR5&quot; &quot;M&quot; ## [20,] &quot;M_at_Length&quot; &quot;Marray&quot; &quot;Mat_age&quot; ## [21,] &quot;maxage&quot; &quot;Mbias&quot; &quot;Mgrad&quot; ## [22,] &quot;Mrand&quot; &quot;Msd&quot; &quot;Perr&quot; ## [23,] &quot;Prob_staying&quot; &quot;procsd&quot; &quot;qcv&quot; ## [24,] &quot;qinc&quot; &quot;R0&quot; &quot;recgrad&quot; ## [25,] &quot;Recsd&quot; &quot;Rmaxlen&quot; &quot;Size_area_1&quot; ## [26,] &quot;Spat_targ&quot; &quot;t0&quot; &quot;t0bias&quot; ## [27,] &quot;V&quot; &quot;Vmaxlen&quot; &quot;Wt_age&quot; A warning message will alert you if variables appear in the named cpars list that are not in validcpars(), and these will be ignored in the MSE. 9.2 Correlated samples As the cpars function is used to provide correlated samples to the MSE, it is important that the same number of custom parameters are provided for each variable. In most cases, this is simply a vector nsim long. For example, if you wish to supply correlated samples of the von Bertalanffy growth parameters, you would create three vectors of length nsim containing the samples of Linf, K, and t0. If the vectors are shorter than nsim they will simply be recycled. An error message will alert you if the vectors are not the same length. As a demonstration, we will use the ForceCor function to generate correlated samples of M, K, L50, and Linf and examine the cpars slot in the resulting OM object: OM &lt;- ForceCor(DLMtool::testOM) str(OM@cpars) ## List of 4 ## $ M : num [1:48] 0.382 0.39 0.396 0.353 0.4 ... ## $ K : num [1:48] 0.174 0.176 0.187 0.163 0.196 ... ## $ L50 : num [1:48] 84.8 86.6 88.9 88.3 88 ... ## $ Linf: num [1:48] 132 132 130 134 128 ... You can see that the OM@cpars slot is a list of length 4 and contains named vectors with 48 correlated samples of the four parameters. Because the OM@cpars slot contains these values, the M, K, L50, and Linf values in the OM, e.g. OM@M will be ignored. Any additional custom parameters can be added to cpars using this same approach. For example, to provide custom (in this case uncorrelated) samples of t0: OM@cpars$t0 &lt;- runif(OM@cpars, -1, 0) str(OM@cpars) ## List of 5 ## $ M : num [1:48] 0.382 0.39 0.396 0.353 0.4 ... ## $ K : num [1:48] 0.174 0.176 0.187 0.163 0.196 ... ## $ L50 : num [1:48] 84.8 86.6 88.9 88.3 88 ... ## $ Linf: num [1:48] 132 132 130 134 128 ... ## $ t0 : num [1:4] -0.768 -0.759 -0.203 -0.168 9.3 Custom time-varying parameters It is also possible to supply custom generated time-varing values for some parameters using the cpars slot. For example, time-varying natural mortality or selectivity patterns. Additional details on using the cpars slot for this will be added to the userguide soon. If you find that this is a feature you wish to use but are unclear how to do it bug us with an email! "],
["size-specific-natural-mortality.html", "Chapter 10 Size-Specific Natural Mortality 10.1 Constant M at age/size 10.2 Lorenzen function of weight 10.3 Map Age-Specific M 10.4 Map Length-Specific M", " Chapter 10 Size-Specific Natural Mortality 10.1 Constant M at age/size By default DLMtool assumes that natural mortality (M) is constant across age and size classes. However, in many species M is known to vary by size, and is often assumed to be higher for smaller age-classes and reduces as individuals age and grow. A number of users requested the option to include age or size-specific M and this has now been added to DLMtool. There are a number of ways to specify age or size-specific M in DLMtool. 10.2 Lorenzen function of weight Natural mortality is often assumed to be a function of weight. Size-specific M can be included in DLMtool following the approach of Lorenzen (1996): \\[M_w = M\\left(\\frac{W}{W_\\infty}\\right)^b\\] where \\(M_w\\) is the natural mortality at weight \\(W\\), \\(M\\) is the natural mortality rate of adult fish, \\(W_\\infty\\) is the asymptotic weight, and \\(b\\) is the allometric scaling factor (Stock@Mexp). Lorezen (1996) found that the exponent \\(b\\) had an average value of -0.288, with 90% confidence intervals of -0.315 – -0.261 for fish from natural systems. Because DLMtool uses an age-structured model, M is calculated as a function of age: \\[M_a = M\\left(\\frac{W_a}{W_\\infty}\\right)^b\\] where \\(M_a\\) is natural mortality at age \\(a\\) and \\(W_a\\) is the mean weight at age \\(a\\). M-at-age is then rescaled so that the mean M of adult age classes (mean age of maturity and greater) is equal to the natural mortality rate sampled from the stock object (Stock@M). The plotM function can be used to visually inspect samples of the M-at-age, -length, and -weight that are generated by the model: Albacore@Mexp &lt;- c(-0.315, -0.261) plotM(Albacore) 10.3 Map Age-Specific M Usually the M slot contains two values, a lower and upper bound for the constant M-at-age. Users who wish for more control of M-at-age can use the M and M2 slots in the Stock object to directly input values for M-at-age (M for lower bound and M2 for upper bound). maxage values of M must be supplied for slots M and M2. One way to do this is to use the ChooseM function to map out the bounds for age-specific M: OM &lt;- new(&quot;OM&quot;, Blue_shark, Generic_FlatE, Generic_Obs, Perfect_Imp) OM &lt;- ChooseM(OM) Click here for a larger version of the image. Alternatively, users can input the values directly into the M and M2 slots (must be length maxage): OM &lt;- new(&quot;OM&quot;, Blue_shark, Generic_FlatE, Generic_Obs, Perfect_Imp) OM@M &lt;- c(0.7, 0.65, 0.60, 0.55, 0.61, 0.68, 0.75, 0.63, 0.51, 0.39, 0.27, 0.15, 0.15, 0.15, 0.15) OM@M2 &lt;- c(0.85, 0.8, 0.75, 0.7, 0.76, 0.83, 0.9, 0.78, 0.66, 0.54, 0.42, 0.3, 0.3, 0.3, 0.3) The plotM function can then be used to visually display samples of the resulting M at age and size: plotM(OM) 10.4 Map Length-Specific M There is also the option to map length-specific M using the plotting tool: OM &lt;- new(&quot;OM&quot;, Blue_shark, Generic_FlatE, Generic_Obs, Perfect_Imp) OM &lt;- ChooseM(OM, &quot;length&quot;) Click here for a larger version of the image. This option uses the Custom Parameters feature of DLMtool: str(OM@cpars) ## List of 1 ## $ M_at_Length:&#39;data.frame&#39;: 42 obs. of 3 variables: ## ..$ Lens: int [1:42] 0 5 10 15 20 25 30 35 40 45 ... ## ..$ M1 : num [1:42] 0.8 0.8 0.8 0.8 0.8 0.8 0.8 0.8 0.8 0.725 ... ## ..$ M2 : num [1:42] 0.9 0.9 0.9 0.9 0.9 ... Again, samples of the resulting M at age and size can be plotted: plotM(OM) ## valid custom parameters (OM@cpars) found: ## M_at_Length "],
["selection-retention-and-discard-mortality.html", "Chapter 11 Selection, Retention and Discard Mortality 11.1 Fishery Selection Curve 11.2 Fishery Retention Curve 11.3 Discard Mortality 11.4 General Discarding", " Chapter 11 Selection, Retention and Discard Mortality 11.1 Fishery Selection Curve The fishery selection or vulnerability to the fishing gear in DLMtool is modelled using a double-normal curve and the parameters in the Fleet object: L5 - smallest length at 5% selection, LFS - smallest length at full selection, and Vmaxlen the vulnerability of the largest length class (defined as expected length at maximum age Stock@maxage). Here we set up a Operating Model with dome-shaped selectivity and plot a sample of the selectivity-at-age and -length using the plotSelect function: OM &lt;- new(&quot;OM&quot;, Albacore, FlatE_Dom, Generic_Obs, Perfect_Imp, nsim=5) plotSelect(OM, sim=1) The plot shows three curves - vulnerability, realized selection and retention - in each panel. In this case they are all the same, because the default setting of DLMtool is to assume that all selected fish are retained in the catch. 11.2 Fishery Retention Curve In some cases the fishing gear selects fish (often small sizes) that are not retained in the catch and are discarded at sea. The fishery-retention curve can be specified following the same approach as selectivity, using the following slots in the Fleet or OM object: LR5 - the smallest length at 5% retention LFR - the smallest length at full selection Rmaxlen - the retention of the largest size class (defined as expected length at maximum age Stock@maxage). The default values for these parameters are: OM@LR5 ## [1] 0 0 OM@LFR ## [1] 0 0 OM@Rmaxlen ## [1] 1 1 meaning that the default assumption is that all size classes are fully retained by the fishery. The retention curve can be modified by providing values for these slots: OM@LR5 &lt;- c(0.6, 0.7) OM@LFR &lt;- c(0.9, 1) Note that the values in the LR5 and LFR slots must be in the same units as those in the L5 and LFS slots. Here we are specifying the values relative to the size of maturity, and assuming that the fishery discards the smaller sized fish: plotSelect(OM, sim=1) The plot shows that the retention curve for the fishery has shifted to the right, towards larger and older fish, while the vulnerability of the fishing gear remains the same. Because we are assuming no discard mortality in this case, the realized selection and retention curves are equivalent. This means that although fish of age/length between the vulnerability and retention curves are selected by the fishery, they are discarded with 100% survival and therefore are not removed from the population. 11.3 Discard Mortality The assumption of 100% survival of discarded fish may be unrealistic in many situations. Discard mortality can be specified by the Fdisc slot in the Stock or OM object. The Fdisc slot represents the fraction of discarded fish that die, or \\(1-\\text{survival}\\). Here we assume that between 30 and 50% of discarded fish suffer fishing mortality: OM@Fdisc &lt;- c(0.3, 0.5) plotSelect(OM, sim=1) We can see now that the realized selection and the retention curves are different for the age/size classes that are discarded by the fishery. The realized selection curve (dashed red line) represents the actual selectivity of the fish removed from the population. The retention curve (dotted blue line) shows the age/size classes that are retained by the fishery and appear in the total cathc, catch-at-age, and catch-at-length fishery data. The shaded gray area between these two curves represents that age/size classes that are caught and killed by the fishery but are discarded and do not appear in the catch statistics. The gear vulnerability curve remains unchanged, and shows that some individuals in the smaller age/size classes are caught and discarded alive back into the population. 11.4 General Discarding General discarding across all age or size classes can be included using the discarding rate slot DR in the Fleet or OM object. For example, here we assume that between 10 and 20% of all age/size classes are discarded by the fishery: OM@DR &lt;- c(0.1, 0.2) Plotting the selectivity and retention curves shows that a proportion of all age and size classes are now discarded, with the survival rate determined by the Fdisc parameter: plotSelect(OM, sim=1) "],
["assumptions-of-dlmtool.html", "Chapter 12 Assumptions of DLMtool 12.1 Biology 12.2 MSE Model Assumptions 12.3 Management Procedures 12.4 Data and Method Application", " Chapter 12 Assumptions of DLMtool Like all models, DLMtool is a simplication of reality. In order to approximate real fishery dynamics, DLMtool relies on a number of simplifying assumptions. Some of these assumptions are common to many fishery science models (e.g., age-structured population dynamics) and are a central to the structure of DLMtool. Other assumptions are a result of the way DLMtool was designed and developed, and may represent limitations of DLMtool for applications to particular situations. It may be possible to deal with some of these assumptions by further development of DLMtool. 12.1 Biology 12.1.1 Short-Lived Species Due to the problems with approximating fine-scale temporal dynamics with an annual model it is not advised to use the DLMtool for very short lived stocks (i.e., species with a longevity of 5 years or less). Technically, you could just divide all temporal parameters by a subyear resolution, but the TAC would be set by sub year and the data would also be available at this fine-scale which is highly unlikely in a data-limited setting. A MSE model with monthly or weekly time-steps for the population dynamics is required for short-lived species, and may be developed in the future. 12.1.2 Density-Dependent Compensation DLMtool assumes that, with the exception of the stock-recruitment relationship, there is no density-dependent compensation in the population dynamics, and fish growth, maturity, and mortality does not change directly in response to changes in stock size. 12.1.3 von Bertalanffy Growth Growth model in DLMtool is modelled using the von Bertalanffy growth curve. While this is the most commonly applied model to describe fish growth, it may not be the preferred growth model for some species. The consequences of assuming the von Bertalanffy growth model should be considered when using the DLMtool for species with alternative growth patterns. Since DLMtool V4.4 it is possible to use alternative length-at-age models by using cpars. See the Custom Parameters chapter for more information. 12.1.4 Natural Mortality Rate at Age By default DLMtool assumes that natural mortality (M) is constant with age and size. Since DLMtool V4.4 size or age-specific M can be specified. See the Size-Specific Natural Mortality chapter for more information. 12.2 MSE Model Assumptions 12.2.1 Idealised Observation Models for Catch Composition Data Currently, DLMtool simulates catch-composition data from the true simulated catch composition data via a multinomial distribution and some effective sample size. This observation model may be unrealistically well-behaved and favour those approaches that use these data. We are considering adding a growth-type-group model to improve the realism of simulated length composition data. 12.2.2 Discard Mortality Since DLMtool V4.4 DLMtool can account for discarding of fish that are smaller than the size of retention by the fishery. See the Selection, Retention and Discard Mortality chapter for more information. 12.2.3 Two-Box Model DLMtool uses a two-box spatial model and assumes homogeneous fishing, and distribution of the fish stock. That is, growth and other life-history characteristics do not vary across the two spatial areas. Spatial targeting of the fishing fleet is currently being developed in the model. 12.2.4 Ontogenetic Habitat Shifts Since the operating model simulates two areas, it is possible to prescribe a log-linear model that moves fish from one area to the other as they grow older. This could be used to simulate the ontogenetic shift of groupers from near shore waters to offshore reefs. Currently this feature is in development. 12.2.5 Closed System DLMtool assumes that the population being modelled is in a closed system. There is no immigration or emigration, and a unit stock is assumed to be represented in the model and impacted by the management decisions. This assumption may be violated where the stock extends across management jurisdictions. Violations of this assumption may impact the interpretation of the MSE results, and these implications should be considered when applying DLMtool. Although a unit stock is a central assumption of many modeling and assessment approaches, it may be possible to further develop DLMtool to account for stocks that cross management boundaries. 12.2.6 Marine Protected Areas (MPA) MPAs can be evaluated as management action in DLMtool by closing one area to fishing in the future projections. Currently, it is not possible to include new MPAs in future projections alongside output management methods (TACs). Similarly, further development of DLMtool is required to fully incorporate existing MPA networks into the MSE simulations 12.3 Management Procedures 12.3.1 Harvest Control Rules Must be Integrated into Data-Limited MPs In this version of DLMtool, harvest control rules (e.g. the 40-10 rule) must be written into a data-limited MP. There is currently no ability to do a factorial comparison of say 4 harvest controls rules against 3 MPs (the user must describe all 12 combinations). The reason for this is that it would require further subclasses. For example the 40-10 rule may be appropriate for the output of DBSRA but it would not be appropriate for some of the simple management procedures such as DynF that already incorporate throttling of TAC recommendations according to stock depletion. 12.4 Data and Method Application 12.4.1 Data Assumed to be Representative The MSE model accounts for observation error in the simulated fishery data. However, the application of management procedures for management advice assumes that the provided fishery data is representative of the fishery and is the best available information on the stock. Processing of fishery data should take place before entering the data into the fishery data tables, and assumptions of the management procedures should be carefully evaluated when applying methods using DLMtool. "],
["references.html", "Chapter 13 References", " Chapter 13 References Beverton, R. J. H., &amp; Holt, S. J. (1957). On the dynamics of exploited fish populations. Fishery Investigation Series 2, United Kingdom Ministry of Agriculture and Fisheries, (Vol. 19). Book, London, United Kingdom. Butterworth, D. S. (2007). Why a management procedure approach? Some positives and negatives. ICES Journal of Marine Science: Journal Du Conseil, 64(1995), 613–617. Costello, C., Ovando, D., Hilborn, R., Gaines, S. D., Deschenes, O., &amp; Lester, S. E. (2012). Status and solutions for the world’s unassessed fisheries. Science, 338, 517–520. Lorenzen, K. (1996), The relationship between body weight and natural mortality in juvenile and adult fish: a comparison of natural ecosystems and aquaculture. Journal of Fish Biology, 49: 627–642 Newman, D., Berkson, J., &amp; Suatoni, L. (2015). Current methods for setting catch limits for data-limited fish stocks in the United States. Fisheries Research, 164, 86–93. Punt, A. E. (2015). Strategic management decision-making in a complex world: quantifying, understanding, and using trade-offs. ICES Journal of Marine Science, (fsv193), 12. Punt, A. E., Butterworth, D. S., de Moor, C. L., De Oliveira, J. A. A., &amp; Haddon, M. (2014). Management strategy evaluation: best practices. Fish and Fisheries. Restrepo, V., Thompson, G. G., Mace, P., Gabriel, W., Low, L., MacCall, A., Methot, R.D., Powers, J.E., Taylor, B., Wade, P.R., &amp; Witzig, J. (1998). Guidance on the use of precautionary approaches to implementing National Standard 1 of the Magnuson-Stevens Fishery Conservation and Management. NOAA Technical Memorandum. Walters, C. J., &amp; Martell, S. J. D. (2004). Fisheries ecology and management. Book, Princeton, USA: Princeton University Press. "]
]
