[
["introduction.html", "Data-Limited Methods Toolkit (DLMtool 5.3) User Guide Chapter 1 Introduction 1.1 Data-Limited Methods Toolkit 1.2 Management Strategy Evaluation 1.3 How does Management Strategy Evaluation Differ from Stock Assessment? 1.4 Assumed Knowledge 1.5 The User Manual 1.6 DLMtool Bug Reports 1.7 Version Notes", " Data-Limited Methods Toolkit (DLMtool 5.3) User Guide Tom Carruthers &amp; Adrian Hordyk 2019-03-12 Chapter 1 Introduction As many as 90% of the world’s fish populations have insufficient data to conduct a conventional stock assessment (Costello et al. 2012). Although a wide range of data-limited management procedures (MPs; stock assessments, harvest control rules) have been described in the primary and gray literature (Newman et al. 2015), they have not been readily available or easily tested to determine their efficacy for specific fisheries. For many fishery managers and stakeholders, the path forward has been unclear and laden with myriad questions, such as: How do these MPs perform comparatively? What are the performance trade-offs? What MPs are appropriate for a given fishery? What is the value of collecting additional data? What is an appropriate stop-gap management approach as more data are collected? 1.1 Data-Limited Methods Toolkit The Data-Limited Methods Toolkit (DLMtool), a collaboration between the University of British Columbia’s (UBC) Institute for Oceans and Fisheries and the Natural Resources Defense Council (NRDC), is aimed at addressing these questions by offering a powerful, transparent approach to comparing, selecting, and applying various data-limited management methods. DLMtool uses management strategy evaluation (MSE) and parallel computing to make powerful diagnostics accessible. A streamlined command structure and operating model builder allow for rapid simulation testing and graphing of results. The package is relatively easy to use for those inexperienced in R, however, complete access and control is available to more experienced users. While DLMtool includes over 108 management procedures it is also designed to be extensible in order to encourage the development and testing of new methods. The package is structured such that the same management methods that are tested by the MSE can be applied to provide management recommendations from real data. Easy incorporation of real data is a central advantage of the software. A set of related functions automatically detect what management procedures can be applied with currently available data, and what additional data are needed to use currently unavailable methods. The Toolkit has been developed in collaboration with fisheries scientists around the globe. New features and functions have been added to the software package to meet the needs or the particular fisheries and management contexts where it has been applied. To date, the Toolkit has been used for management or academic research in over 25 fisheries, including by the National Marine Fisheries Service in the U.S. Mid-Atlantic and Caribbean regions, and by the California Department of Fish &amp; Wildlife. 1.2 Management Strategy Evaluation At the core of the Data-Limited Methods Toolkit is an integrated management strategy evaluation (MSE) function. Management strategy evaluation is a computer simulation approach for testing prospective management options over a wide range of possible realities for the fishery and the population. Ideally, management options can be identified that are robust and perform well over all credible scenarios for the fishery. It is extremely difficult, perhaps impossible, to conduct large-scale experiments to evaluate directly the trade-offs associated with fisheries management. Even among well-studied fisheries, considerable uncertainty often exists regarding stock status and the dynamics of the fishery, and it can be difficult to attribute particular outcomes to distinct management actions. The mathematical description of fish population dynamics and the interaction with different exploitation patterns, first developed by Beverton and Holt (1957), together with the advent of powerful and affordable computers, has allowed the development of the MSE approach (Butterworth, 2007; Punt et al. 2014). Management strategy evaluation was originally developed by the International Whaling Commission as a tool to evaluate the various trade-offs involved the management of marine mammals, and to guide the decision-making process for selecting an appropriate management strategy. Since its development in the mid-1970s, MSE has become widely used in fisheries science and is routinely applied to evaluate the trade-offs in alternative management strategies of many of the world’s fisheries. An MSE is usually comprised of three key components: an operating model that is used to simulate the stock and fleet dynamics, an assessment method and harvest control rule model (interchangeably referred to as management procedures, or management strategies) that use the simulated fishery data from the operating model to estimate the status of the (simulated) stock and provide management recommendations (e.g., a total allowable catch (TAC) or effort control), and an observation model that is used to generate the simulated observed data that would typically be used in management (i.e., with realistic imprecision and bias). The management recommendations by each management procedure are then fed-back into the operating model and projected forward one-time step. The process of simulating the population dynamics of the fishery along with the management process that feeds back and impacts the simulated fish population is known as closed-loop simulation. A benefit of closed-loop simulation is that it allows the direct comparison and evaluation of alternative management strategies against perfect knowledge of the simulated system; something that is impossible in the real world (Walters and Martell, 2004). With the aid of computer simulation, it is possible to run many hundreds of simulation runs for each management procedure being evaluated - each representing a different possible simulated future of what could happen to the fishery under various management strategies - and to take into account the uncertainty in knowledge of the stock and fishery (i.e., errors in observation), as well as the uncertainty in future environmental and ecological conditions that are likely to affect the stock dynamics. Through these simulations, MSE reveals the relative impacts of specified management approaches to their fishery decades into the future and enables managers to choose the approach that best achieves their management objectives, as articulated through a set of well-defined performance metrics. 1.3 How does Management Strategy Evaluation Differ from Stock Assessment? Stock assessments are intended to provide one-off management advice, such as a catch limit (e.g. 20,000 tonnes), based on historical data. However, a stock assessment on its own provides no knowledge of the expected performance of the assessment, harvest control rule, or management system in general. In an assessment setting there is no way to know whether a simpler assessment using other data might provide more robust performance (e.g. less overfishing, more yield) over a time horizon that managers are considering (e.g. the next 30 years). Management strategy evaluation tests a range of management approaches (of which an assessment linked to a harvest control rule is one such approach) and offers a scientific basis for selecting a management approach. MSE does not provide a catch-limit in tonnes, it identifies a modus operandi that will provide the desired management performance (it is analogous to selecting a suitable airplane via flight simulation testing rather than actually flying a plane to a specific destination). The advantage of MSE over stock assessment is that it is possible to consider a much wider range of uncertainty in stock dynamics, fleet dynamics, and data collection, which often better represents the state of knowledge (particularly for data-limited stocks). No matter how much uncertainty is factored into the MSE, a single management approach may be selected that can provide management advice. MSE was specifically introduced in controversial fishery settings where it was not possible to decide the ‘best’ representation of the state of nature. In the end, MSE was used to circumvent this problem by including all possible states of nature, often revealing that the disputes were in fact inconsequential all along. 1.4 Assumed Knowledge This User Guide assumes that you are using RStudio with an up-to-date version of R and the latest version of the DLMtool installed. You can check your version of R by typing version into the R console: version ## _ ## platform x86_64-w64-mingw32 ## arch x86_64 ## os mingw32 ## system x86_64, mingw32 ## status ## major 3 ## minor 5.2 ## year 2018 ## month 12 ## day 20 ## svn rev 75870 ## language R ## version.string R version 3.5.2 (2018-12-20) ## nickname Eggshell Igloo You can also find the version of DLMtool (or any other package) by typing: packageVersion(&#39;DLMtool&#39;) ## [1] &#39;5.3&#39; The DLMtool package has been designed so that it is accessible for all users and does not assume a high level of knowledge of R. The functions and User Guide have been constructed in such a way that a user with little experience with R should be able to run the MSE and apply the methods to their data. No programming experience is required to use the package. However, users of the DLMtool should have some familiarity with R, and be comfortable with using the command line. The User Guide attempts to explain the use of the DLMtool in easy to follow steps, but familiarity with the most common R functions is assumed. The package is fully extensible, and more experienced R users are able to design their own management procedures, develop new plotting functions, and other customizations. 1.5 The User Manual This user manual has been designed to introduce users to DLMtool and does not assume prior knowledge of DLMtool or extensive knowledge of R. Some familiarity with the concept of Management Strategy Evaluation and the commonly used parameters and data types is assumed. The user manual is continually being developed and we could use your help! We’ve tried to design it from the perspective of someone who is brand new to DLMtool. But there are undoubtedly many ways in which it can be improved. Please contact us through our website or email us directly if you have any questions or suggestions for improvement. Bug or typos can be reported on the userguide GitHub issues page. Pull requests with edits are most welcome. 1.6 DLMtool Bug Reports The package is subject to ongoing development and testing. If you find a bug or a problem please contact us or report an issue on GitHub so that it can be fixed. If possible, please provide a minimal reproducible example so that we can recreate the problem and fix it. 1.7 Version Notes The current version of the DLMtool package is available for download from CRAN. Version notes for previous versions of DLMtool can be found at DLMtool News "],
["getting-started.html", "Chapter 2 Getting Started 2.1 Required Software 2.2 Installing DLMtool 2.3 Loading DLMtool", " Chapter 2 Getting Started 2.1 Required Software To get started with the DLMtool you will need at least two things: A current version of the R software installed on your machine. The latest version of the DLMtool package. 2.1.1 The R Software The R software can be freely downloaded from the CRAN website and is available for all operating systems. Updated versions of R are released frequently, and it is recommended that you have the latest version installed. If you are using Windows OS, you can uses the installr package and the updateR() function to update and install the latest version. Alternatively, head to the CRAN website to download the latest version of R. You can check your version of R by typing version into the R console: version ## _ ## platform x86_64-w64-mingw32 ## arch x86_64 ## os mingw32 ## system x86_64, mingw32 ## status ## major 3 ## minor 5.2 ## year 2018 ## month 12 ## day 20 ## svn rev 75870 ## language R ## version.string R version 3.5.2 (2018-12-20) ## nickname Eggshell Igloo 2.1.2 RStudio RStudio is a freely available integrated development environment (IDE) for R. It is not essential that you use RStudio, but it can make things a lot easier, especially if you are new to R. This User Guide assumes that you are using RStudio to operate the DLMtool. It is important to be aware that RStudio and R are two different pieces of software that must be installed separately. We recommend installing the R software before downloading and installing RStudio. 2.2 Installing DLMtool If this is the first time you are using DLMtool, you will need to install the DLMtool package from CRAN. 2.2.1 Installing DLMtool using R Console This can be done by running the command: install.packages(&quot;DLMtool&quot;) A prompt may appear asking you to select a CRAN mirror. It is best to pick the mirror that is the closest geographical distance. 2.2.2 Installing DLMtool in RStudio An alternative method to install the DLMtool package is to click the Packages tab in the lower right panel in RStudio, and click Install. Check that Repository (CRAN, CRANextra) is selected in the Install from: drop-down menu, type DLMtool into the packages dialog box, and click Install. The DLMtool package relies on a number of other R packages, which the installation process will automatically install. The number of packages that are installed, and the time it takes, will depend on what packages you already have installed on your system (and your download speed). 2.2.3 Updating the DLMtool Package You will only need to install the DLMtool package once. However, the DLMtool package is updated from time to time, and you will need to re-install from CRAN for each new version. This can be done by using the update.packages command: update.packages(&quot;DLMtool&quot;) 2.2.4 Checking DLMtool version You can confirm the version of DLMtool by typing: packageVersion(&#39;DLMtool&#39;) ## [1] &#39;5.3&#39; 2.3 Loading DLMtool Once installed, the DLMtool package can be loaded into R by typing in the command line: library(DLMtool) ## Loading required package: snowfall ## Loading required package: snow or locating the DLMtool package in the list of packages in RStudio and checking the box. You need to load the DLMtool package each time you start a new instance of R. "],
["a-very-quick-demo.html", "Chapter 3 A Very Quick Demo", " Chapter 3 A Very Quick Demo Running an MSE with DLMtool is quite straightforward and only requires a single line of code: myMSE &lt;- runMSE() If you run this line (remember, if you haven’t already you must first run library(DLMtool)) and see something similiar to the output shown here, then DLMtool is successfully working on your system. If the MSE did not run successfully, repeat the previous steps, ensuring that you have the latest version of R and the DLMtool package. If still no success, please contact us with a description of the problem and we will try to help. Once an MSE is run, the results can be examined visually using plotting functions, for example: Pplot(myMSE) Or quantified in various ways, for example: summary(myMSE) ## Calculating Performance Metrics ## Performance.Metrics ## 1 Probability of not overfishing (F&lt;FMSY) ## 2 Spawning Biomass relative to SBMSY ## 3 Average Annual Variability in Yield (Years 1-50) ## 4 Average Yield relative to Reference Yield (Years 41-50) ## ## 1 Prob. F &lt; FMSY (Years 1 - 50) ## 2 Prob. SB &gt; 0.5 SBMSY (Years 1 - 50) ## 3 Prob. AAVY &lt; 20% (Years 1-50) ## 4 Prob. Yield &gt; 0.5 Ref. Yield (Years 41-50) ## ## ## Probability: ## MP PNOF P50 AAVY LTY ## 1 AvC 0.67 0.75 0.94 0.54 ## 2 DCAC 0.62 0.73 0.96 0.61 ## 3 FMSYref 0.37 0.98 1.00 0.99 ## 4 curE 0.71 0.88 0.21 0.77 ## 5 matlenlim 0.72 0.99 0.27 0.59 ## 6 MRreal 0.76 0.92 0.23 0.79 Later sections of the user manual will describe more ways to evaluate the outputs of the runMSE function. But first we will look at the most fundamental part of MSE: the Operating Model. "],
["the-operating-model.html", "Chapter 4 The Operating Model 4.1 OM Components 4.2 Plotting OM Components 4.3 Building an OM from Component Objects 4.4 Visualizing an OM", " Chapter 4 The Operating Model The Operating Model (OM) is the main component of the MSE framework. The OM is used to describe the characterstics of a fishery system and contains all the parameters required to simulate the population and fleet dynamics, the collection of data, and the application of a management procedure (e.g., implement a size regulation, effort control, spatial closure, or catch limit). 4.1 OM Components An OM is built from four separate components, each containing a set of parameter values for different aspects of the simulation: Stock - parameters describing the stock dynamics Fleet - parameters describing the fishing fleet dynamics Obs (Observation) - parameters describing the observation processes (how the observed fishery data is generated from the simulated data) Imp (Implementation) - parameters describing the management implemetation (how well the management regulations are implemented) There are a number of example Stock, Fleet, Obs, and Imp parameter sets built into DLMtool which make it easy to quickly construct an OM and run an MSE. These parameter sets are referred to as Objects and have an associated Class. 4.1.1 Stock Object The avail function can be used to examine the available Objects of a particular Class. For example, to see the available objects of class Stock: avail(&#39;Stock&#39;) ## [1] &quot;Albacore&quot; &quot;Blue_shark&quot; &quot;Bluefin_tuna&quot; ## [4] &quot;Bluefin_tuna_WAtl&quot; &quot;Butterfish&quot; &quot;Herring&quot; ## [7] &quot;Mackerel&quot; &quot;Porgy&quot; &quot;Rockfish&quot; ## [10] &quot;Snapper&quot; &quot;Sole&quot; &quot;Toothfish&quot; This shows that there are 12 objects of class Stock. We can confirm the class of this object by using the class function. For example, to examine the class of the object Albacore: class(Albacore) ## [1] &quot;Stock&quot; ## attr(,&quot;package&quot;) ## [1] &quot;DLMtool&quot; As expected, the Albacore object is class Stock. Let’s take a quick look at the contents of the Albacore Stock object: slotNames(Albacore) ## [1] &quot;Name&quot; &quot;Common_Name&quot; &quot;Species&quot; &quot;maxage&quot; ## [5] &quot;R0&quot; &quot;M&quot; &quot;M2&quot; &quot;Mexp&quot; ## [9] &quot;Msd&quot; &quot;Mgrad&quot; &quot;h&quot; &quot;SRrel&quot; ## [13] &quot;Perr&quot; &quot;AC&quot; &quot;Period&quot; &quot;Amplitude&quot; ## [17] &quot;Linf&quot; &quot;K&quot; &quot;t0&quot; &quot;LenCV&quot; ## [21] &quot;Ksd&quot; &quot;Kgrad&quot; &quot;Linfsd&quot; &quot;Linfgrad&quot; ## [25] &quot;L50&quot; &quot;L50_95&quot; &quot;D&quot; &quot;a&quot; ## [29] &quot;b&quot; &quot;Size_area_1&quot; &quot;Frac_area_1&quot; &quot;Prob_staying&quot; ## [33] &quot;Fdisc&quot; &quot;Source&quot; The output tells us that there are 34 slots in the Albacore Stock object. Each of these slots contains information relating to stock that is used in the MSE. We can examine the information that is stored in the slots using the @ symbol. For example, the name of the species in the Stock object is: Albacore@Name ## [1] &quot;Albacore&quot; The maximum age parameter is: Albacore@maxage ## [1] 15 The values for the natural mortality (M) parameter for this stock are: Albacore@M ## [1] 0.35 0.45 Note that the natural mortality parameter (M) has two values, while the maximum age (maxage) only has one value. The MSE in the DLMtool is a stochastic model, and almost all parameters are drawn from a distribution. By default this distribution is assumed to be uniform, and the two values for the M parameter represent the lower and upper bounds of this uniform distribution. Some parameters, such as maximum age (maxage), species name (Name), or initial recruitment (R0) have only a single value and are fixed in the MSE. You can see more information on the content of the Stock object by using the help function: class?Stock 4.1.2 Fleet Object While the Stock object contains all the information relating to the fish stock that is being modeled, the Fleet object is populated with information relating to the fishing fleet and historical pattern of exploitation. Like the Stock objects, there are a number of Fleet objects that are built into the DLMtoo: avail(&#39;Fleet&#39;) ## [1] &quot;DecE_Dom&quot; &quot;DecE_HDom&quot; ## [3] &quot;DecE_NDom&quot; &quot;FlatE_Dom&quot; ## [5] &quot;FlatE_HDom&quot; &quot;FlatE_NDom&quot; ## [7] &quot;Generic_DecE&quot; &quot;Generic_FlatE&quot; ## [9] &quot;Generic_Fleet&quot; &quot;Generic_IncE&quot; ## [11] &quot;IncE_HDom&quot; &quot;IncE_NDom&quot; ## [13] &quot;Low_Effort_Non_Target&quot; &quot;Target_All_Fish&quot; ## [15] &quot;Targeting_Small_Fish&quot; Here we will look at the Generic_Fleet object. class(Generic_Fleet) ## [1] &quot;Fleet&quot; ## attr(,&quot;package&quot;) ## [1] &quot;DLMtool&quot; slotNames(Generic_Fleet) ## [1] &quot;Name&quot; &quot;nyears&quot; &quot;Spat_targ&quot; &quot;EffYears&quot; &quot;EffLower&quot; ## [6] &quot;EffUpper&quot; &quot;Esd&quot; &quot;qinc&quot; &quot;qcv&quot; &quot;L5&quot; ## [11] &quot;LFS&quot; &quot;Vmaxlen&quot; &quot;isRel&quot; &quot;LR5&quot; &quot;LFR&quot; ## [16] &quot;Rmaxlen&quot; &quot;DR&quot; &quot;SelYears&quot; &quot;AbsSelYears&quot; &quot;L5Lower&quot; ## [21] &quot;L5Upper&quot; &quot;LFSLower&quot; &quot;LFSUpper&quot; &quot;VmaxLower&quot; &quot;VmaxUpper&quot; ## [26] &quot;CurrentYr&quot; &quot;MPA&quot; There are 27 slots in the Fleet object. The parameters in the Fleet object relate to the exploitation pattern of the stock. For example, the number of years that the stock has been exploited is specified in the nyears slot: Generic_Fleet@nyears ## [1] 50 As another example, the smallest length at full selection is specified in the LFS slot: Generic_Fleet@LFS ## [1] 0.75 1.10 Note that by default the values in the LFS (and the L5 [smallest length at 5% selectivity]) slots are specified as multiples of the length of maturity (e.g., Albacore@L50). This is necessary because the Fleet objects built into the DLMtool are all generic, in the sense that they can be used with any Stock object. You will notice that the isRel slot in the Generic_Fleet object is set to “TRUE”. This means that the selectivity parameters are relative to the length of maturity in the Stock object. Absolute values for the selectivity parameters can be used, for example by specifying LFS and L5 to, say, 100 - 150 and 50 - 70 respectively. The isRel parameter must then be set to “FALSE”, so that the Operating Model knows that these selectivity values are in absolute terms, and does not multiply them by the length of maturity (strange things may happen if the model assumes that the size of first capture is 50 to 70 times greater than the size of maturity!). Note that all the parameters in the Fleet object have two values, representing the minimum and maximum bounds of a uniform distribution (with some exceptions that will be discussed in more detail later). More information on the Fleet object can be found by typing: class?Fleet 4.1.3 Obs Object The third component for the Operating Model is the Obs (Observation) object. This object contains all the information relating to how the fishery information is generated inside the model. Why do we need a Obs object? Although the MSE may be conditioned on real data and information about the fishery, all data is generated inside the model. Because it is a simulation model and the data was generated by a computer, rather than some unobserved real world process, the fishery data is known perfectly. In the real world, however, all data sources and parameter estimates are subject to some observation error. The degree of uncertainty may vary between different data types, and between fisheries. The advantage of the MSE process is that the performance of a management procedure using the realistically noisy simulated data can be compared to the performance under conditions of perfect knowledge. This comparison, which unfortunately is never possible in the real world, can reveal important information about the robustness (or sensitivity) of certain methods to variability and error in particular data types. This knowledge can help to prioritize research to reduce uncertainty in the parameters and data sets that are most crucial to the performance of the method. Like the other two objects, there are a number of built-in Obs objects in the DLMtool. avail(&#39;Obs&#39;) ## [1] &quot;Generic_Obs&quot; &quot;Imprecise_Biased&quot; &quot;Imprecise_Unbiased&quot; ## [4] &quot;Perfect_Info&quot; &quot;Precise_Biased&quot; &quot;Precise_Unbiased&quot; Let’s take a look at the Imprecise_Unbiased object: class(Imprecise_Unbiased) ## [1] &quot;Obs&quot; ## attr(,&quot;package&quot;) ## [1] &quot;DLMtool&quot; slotNames(Imprecise_Unbiased) ## [1] &quot;Name&quot; &quot;Cobs&quot; &quot;Cbiascv&quot; &quot;CAA_nsamp&quot; ## [5] &quot;CAA_ESS&quot; &quot;CAL_nsamp&quot; &quot;CAL_ESS&quot; &quot;Iobs&quot; ## [9] &quot;Ibiascv&quot; &quot;Btobs&quot; &quot;Btbiascv&quot; &quot;beta&quot; ## [13] &quot;LenMbiascv&quot; &quot;Mbiascv&quot; &quot;Kbiascv&quot; &quot;t0biascv&quot; ## [17] &quot;Linfbiascv&quot; &quot;LFCbiascv&quot; &quot;LFSbiascv&quot; &quot;FMSYbiascv&quot; ## [21] &quot;FMSY_Mbiascv&quot; &quot;BMSY_B0biascv&quot; &quot;Irefbiascv&quot; &quot;Brefbiascv&quot; ## [25] &quot;Crefbiascv&quot; &quot;Dbiascv&quot; &quot;Dobs&quot; &quot;hbiascv&quot; ## [29] &quot;Recbiascv&quot; There are 29 slots in Obs objects, each with information relating to the uncertainty of a data type. For example, the LenMbiascv slot defines the bias (coefficient of variability) in the length of maturity: Imprecise_Biased@LenMbiascv ## [1] 0.2 This means that the assumed length of maturity that is generated by the Operating Model, and used in the simulated application of a management procedure, is not the ‘true’ value set in the Stock object, but a value sampled with a 20% coefficient of variation. More information on the Obs object can be found by typing: class?Obs 4.1.4 Imp Object The final component for the Operating Model is the Imp (Implementation) object. This object contains all the information relating to how the management recommendation is actually implemented in the fishery, i.e., the implementation error. The Imp object includes slots for the over or under catch of TAC, implementation error in total allowable effort, and variability in size regulations. avail(&#39;Imp&#39;) ## [1] &quot;Overages&quot; &quot;Perfect_Imp&quot; class(Overages) ## [1] &quot;Imp&quot; ## attr(,&quot;package&quot;) ## [1] &quot;DLMtool&quot; More information on the Imp object can be found by typing: class?Imp 4.2 Plotting OM Components The OM Components Stock, Fleet, Obs, and Imp can be plotted to visually examine the contents. For example, to plot a Stock object (note that the figures are not shown here): plot(Albacore) To plot a Fleet object you must also provide an object of class Stock, for example: plot(FlatE_Dom, Albacore) The Obs and Imp objects can also be plotted: plot(Generic_Obs) plot(Overages) 4.3 Building an OM from Component Objects We will now look at how to combine objects of the four classes into an OM. For now we will work with the OM components that are built into DLMtool. In later sections of the user manual we will cover how to build your own Stock, Fleet, Obs, and Imp objects that characterises your fishery. Objects of class Stock, Fleet, Obs and Imp are used to create an Operating Model object (class OM). The simplest way to do this is to use new command. For example, here we are building a OM using the Rockfish Stock object, Generic_Fleet Fleet object, Generic_Obs Obs object, and Perfect_Imp Imp object and assigning it the name myOM: myOM &lt;- new(&quot;OM&quot;, Rockfish, Generic_Fleet, Generic_Obs, Perfect_Imp) What is the class of our newly created objects myOM? class(myOM) ## [1] &quot;OM&quot; ## attr(,&quot;package&quot;) ## [1] &quot;DLMtool&quot; If you use the slotNames function on the myOM object that was just created, you will see that it contains all of the information from the Stock, Fleet, Obs, and Imp objects: slotNames(myOM) ## [1] &quot;Name&quot; &quot;Agency&quot; &quot;Region&quot; &quot;Sponsor&quot; ## [5] &quot;Latitude&quot; &quot;Longitude&quot; &quot;nsim&quot; &quot;proyears&quot; ## [9] &quot;interval&quot; &quot;pstar&quot; &quot;maxF&quot; &quot;reps&quot; ## [13] &quot;cpars&quot; &quot;seed&quot; &quot;Source&quot; &quot;Common_Name&quot; ## [17] &quot;Species&quot; &quot;maxage&quot; &quot;R0&quot; &quot;M&quot; ## [21] &quot;M2&quot; &quot;Mexp&quot; &quot;Msd&quot; &quot;Mgrad&quot; ## [25] &quot;h&quot; &quot;SRrel&quot; &quot;Perr&quot; &quot;AC&quot; ## [29] &quot;Period&quot; &quot;Amplitude&quot; &quot;Linf&quot; &quot;K&quot; ## [33] &quot;t0&quot; &quot;LenCV&quot; &quot;Ksd&quot; &quot;Kgrad&quot; ## [37] &quot;Linfsd&quot; &quot;Linfgrad&quot; &quot;L50&quot; &quot;L50_95&quot; ## [41] &quot;D&quot; &quot;a&quot; &quot;b&quot; &quot;Size_area_1&quot; ## [45] &quot;Frac_area_1&quot; &quot;Prob_staying&quot; &quot;Fdisc&quot; &quot;nyears&quot; ## [49] &quot;Spat_targ&quot; &quot;EffYears&quot; &quot;EffLower&quot; &quot;EffUpper&quot; ## [53] &quot;Esd&quot; &quot;qinc&quot; &quot;qcv&quot; &quot;L5&quot; ## [57] &quot;LFS&quot; &quot;Vmaxlen&quot; &quot;isRel&quot; &quot;LR5&quot; ## [61] &quot;LFR&quot; &quot;Rmaxlen&quot; &quot;DR&quot; &quot;SelYears&quot; ## [65] &quot;AbsSelYears&quot; &quot;L5Lower&quot; &quot;L5Upper&quot; &quot;LFSLower&quot; ## [69] &quot;LFSUpper&quot; &quot;VmaxLower&quot; &quot;VmaxUpper&quot; &quot;CurrentYr&quot; ## [73] &quot;MPA&quot; &quot;Cobs&quot; &quot;Cbiascv&quot; &quot;CAA_nsamp&quot; ## [77] &quot;CAA_ESS&quot; &quot;CAL_nsamp&quot; &quot;CAL_ESS&quot; &quot;Iobs&quot; ## [81] &quot;Ibiascv&quot; &quot;Btobs&quot; &quot;Btbiascv&quot; &quot;beta&quot; ## [85] &quot;LenMbiascv&quot; &quot;Mbiascv&quot; &quot;Kbiascv&quot; &quot;t0biascv&quot; ## [89] &quot;Linfbiascv&quot; &quot;LFCbiascv&quot; &quot;LFSbiascv&quot; &quot;FMSYbiascv&quot; ## [93] &quot;FMSY_Mbiascv&quot; &quot;BMSY_B0biascv&quot; &quot;Irefbiascv&quot; &quot;Brefbiascv&quot; ## [97] &quot;Crefbiascv&quot; &quot;Dbiascv&quot; &quot;Dobs&quot; &quot;hbiascv&quot; ## [101] &quot;Recbiascv&quot; &quot;TACFrac&quot; &quot;TACSD&quot; &quot;TAEFrac&quot; ## [105] &quot;TAESD&quot; &quot;SizeLimFrac&quot; &quot;SizeLimSD&quot; You can access individual slots in the OM object using the @ symbol and confirm that these values are the same as those in the Stock object used to create the OM: Rockfish@M ## [1] 0.04 0.08 myOM@M ## [1] 0.04 0.08 In addition to the information from the Stock, Fleet, Obs, and Imp objects, the OM object also contains other values relating to the MSE, including the number of simulations to run (nsim), the number of projection years (proyears), and the management interval (interval): myOM@nsim ## [1] 48 myOM@proyears ## [1] 50 myOM@interval ## [1] 4 These slots all have default values that can be modified easily, for example: myOM@proyears &lt;- 60 Remember, you can access the help information for objects by typing ? followed by the class name, for example: class?OM In later chapters we will cover a range of methods to build new Stock, Fleet, Obs, and Imp objects and constructing OMs that characterise your fishery. 4.4 Visualizing an OM The newly created OM object myOM contains all the parameters that will be used to simulate our fishery, both the historical conditions and the future projections. The OM can visualized with the plot function (plots not shown here): plot(myOM) "],
["management-procedures.html", "Chapter 5 Management Procedures 5.1 What is a Management Procedure? 5.2 Available Management Procedures 5.3 Types of Management Procedure", " Chapter 5 Management Procedures The purpose of an MSE is to compare the performance of alternative management approaches, or Management Procedures to identify the method that is most likely to meet the management objectives for the fishery. 5.1 What is a Management Procedure? In essence, a Management Procedure is simply a set of rules which define how a fishery will be managed. These rules can range from simple harvest policies to more complex arrangements. For example, a simple Management Procedure may be a constant catch policy, where the annual total allowable catch (TAC) is set a some fixed value. Alternatively, a more complex Management Procedure may involve multiple data sources, with rules that increase or reduce the TAC in response to trends in one or several indicators. Management Procedures can differ in data requirements and complexity. However, all Management Procedures have one thing in common. They take fishery information and return a management recommendation. To be included in an MSE, a Management Procedure must be reproducible and able to be coded in a set of instructions. While fisheries are sometimes managed by expert judgment, it is difficult to reproduce the subjective decision-making process in a computer simulation and include such methods in an MSE. 5.2 Available Management Procedures All management procedures in DLMtool are objects (actually functions in this case) of class MP. There are a number of MPs built into DLMtool. The avail function can be used to provide a list of MPs that can be included in the MSE: avail(&#39;MP&#39;) ## [1] &quot;AvC&quot; &quot;AvC_MLL&quot; &quot;BK&quot; &quot;BK_CC&quot; ## [5] &quot;BK_ML&quot; &quot;CC1&quot; &quot;CC2&quot; &quot;CC3&quot; ## [9] &quot;CC4&quot; &quot;CC5&quot; &quot;CompSRA&quot; &quot;CompSRA4010&quot; ## [13] &quot;curE&quot; &quot;curE75&quot; &quot;DAAC&quot; &quot;DBSRA&quot; ## [17] &quot;DBSRA_40&quot; &quot;DBSRA4010&quot; &quot;DCAC&quot; &quot;DCAC_40&quot; ## [21] &quot;DCAC_ML&quot; &quot;DCAC4010&quot; &quot;DCACs&quot; &quot;DD&quot; ## [25] &quot;DD4010&quot; &quot;DDe&quot; &quot;DDe75&quot; &quot;DDes&quot; ## [29] &quot;DepF&quot; &quot;DTe40&quot; &quot;DTe50&quot; &quot;DynF&quot; ## [33] &quot;EtargetLopt&quot; &quot;Fadapt&quot; &quot;Fdem&quot; &quot;Fdem_CC&quot; ## [37] &quot;Fdem_ML&quot; &quot;FMSYref&quot; &quot;FMSYref50&quot; &quot;FMSYref75&quot; ## [41] &quot;Fratio&quot; &quot;Fratio_CC&quot; &quot;Fratio_ML&quot; &quot;Fratio4010&quot; ## [45] &quot;GB_CC&quot; &quot;GB_slope&quot; &quot;GB_target&quot; &quot;Gcontrol&quot; ## [49] &quot;HDAAC&quot; &quot;ICI&quot; &quot;ICI2&quot; &quot;Iratio&quot; ## [53] &quot;Islope1&quot; &quot;Islope2&quot; &quot;Islope4&quot; &quot;IT10&quot; ## [57] &quot;IT5&quot; &quot;Itarget1&quot; &quot;Itarget1_MPA&quot; &quot;Itarget2&quot; ## [61] &quot;Itarget3&quot; &quot;Itarget4&quot; &quot;ItargetE1&quot; &quot;ItargetE2&quot; ## [65] &quot;ItargetE3&quot; &quot;ItargetE4&quot; &quot;ITe10&quot; &quot;ITe5&quot; ## [69] &quot;ITM&quot; &quot;L95target&quot; &quot;LBSPR&quot; &quot;LBSPR_MLL&quot; ## [73] &quot;Lratio_BHI&quot; &quot;Lratio_BHI2&quot; &quot;Lratio_BHI3&quot; &quot;LstepCC1&quot; ## [77] &quot;LstepCC2&quot; &quot;LstepCC3&quot; &quot;LstepCC4&quot; &quot;LstepCE1&quot; ## [81] &quot;LstepCE2&quot; &quot;Ltarget1&quot; &quot;Ltarget2&quot; &quot;Ltarget3&quot; ## [85] &quot;Ltarget4&quot; &quot;LtargetE1&quot; &quot;LtargetE4&quot; &quot;matlenlim&quot; ## [89] &quot;matlenlim2&quot; &quot;MCD&quot; &quot;MCD4010&quot; &quot;minlenLopt1&quot; ## [93] &quot;MRnoreal&quot; &quot;MRreal&quot; &quot;NFref&quot; &quot;Rcontrol&quot; ## [97] &quot;Rcontrol2&quot; &quot;SBT1&quot; &quot;SBT2&quot; &quot;slotlim&quot; ## [101] &quot;SPmod&quot; &quot;SPMSY&quot; &quot;SPslope&quot; &quot;SPSRA&quot; ## [105] &quot;SPSRA_ML&quot; &quot;YPR&quot; &quot;YPR_CC&quot; &quot;YPR_ML&quot; As you can see, there are 108 MPs built into the DLMtool. DLMtool is extensible and it is relatively straightforward to develop your own MPs and include them in the MSE. This is covered in Developing Custom Management Procedures. 5.3 Types of Management Procedure In previous versions of DLMtool, the MPs were divided into two classes: Output controls which returned a total allowable catch (TAC) and Input controls which allow regulation of fishing effort, size selectivity, or spatial area. Since DLMtool V5.1 it is possible to include MPs that provide a combination of input and output controls. All MPs in DLMtool are now class MP, but the MPs are divided into four types: Input which allow regulation offishing effort, size selectivity, or spatial area but not a TAC, Output which return only a TAC recommendation, Mixed which return a combination of one or several input controls and a TAC, and Reference which are MPs that have been designed to be used as reference management procedures (e.g FMSYref which uses perfect information of FMSY and abundance). The MPtype function can be used to display the type for a particular MP, for example: MPtype(&quot;DCAC&quot;) ## MP Type Recs ## 1 DCAC Output TAC This tells us that DCAC is an Output control MP and returns a management recommendation in the form of a total allowable catch limit (TAC). Here we list all available MPs: MPtype(avail(&#39;MP&#39;)) ## MP Type Recs ## 1 curE Input TAE ## 2 curE75 Input TAE ## 3 DDe Input TAE ## 4 DDe75 Input TAE ## 5 DDes Input TAE ## 6 DTe40 Input TAE ## 7 DTe50 Input TAE ## 8 EtargetLopt Input TAE ## 9 ItargetE1 Input TAE ## 10 ItargetE2 Input TAE ## 11 ItargetE3 Input TAE ## 12 ItargetE4 Input TAE ## 13 ITe10 Input TAE ## 14 ITe5 Input TAE ## 15 LBSPR Input TAE ## 16 LBSPR_MLL Input SL ## 17 LstepCE1 Input TAE ## 18 LstepCE2 Input TAE ## 19 LtargetE1 Input TAE ## 20 LtargetE4 Input TAE ## 21 matlenlim Input SL ## 22 matlenlim2 Input SL ## 23 minlenLopt1 Input SL ## 24 MRnoreal Input Spatial ## 25 MRreal Input Spatial ## 26 slotlim Input SL ## 27 AvC_MLL Mixed TAC, SL ## 28 Itarget1_MPA Mixed TAC, Spatial ## 29 AvC Output TAC ## 30 BK Output TAC ## 31 BK_CC Output TAC ## 32 BK_ML Output TAC ## 33 CC1 Output TAC ## 34 CC2 Output TAC ## 35 CC3 Output TAC ## 36 CC4 Output TAC ## 37 CC5 Output TAC ## 38 CompSRA Output TAC ## 39 CompSRA4010 Output TAC ## 40 DAAC Output TAC ## 41 DBSRA Output TAC ## 42 DBSRA_40 Output TAC ## 43 DBSRA4010 Output TAC ## 44 DCAC Output TAC ## 45 DCAC_40 Output TAC ## 46 DCAC_ML Output TAC ## 47 DCAC4010 Output TAC ## 48 DCACs Output TAC ## 49 DD Output TAC ## 50 DD4010 Output TAC ## 51 DepF Output TAC ## 52 DynF Output TAC ## 53 Fadapt Output TAC ## 54 Fdem Output TAC ## 55 Fdem_CC Output TAC ## 56 Fdem_ML Output TAC ## 57 Fratio Output TAC ## 58 Fratio_CC Output TAC ## 59 Fratio_ML Output TAC ## 60 Fratio4010 Output TAC ## 61 GB_CC Output TAC ## 62 GB_slope Output TAC ## 63 GB_target Output TAC ## 64 Gcontrol Output TAC ## 65 HDAAC Output TAC ## 66 ICI Output TAC ## 67 ICI2 Output TAC ## 68 Iratio Output TAC ## 69 Islope1 Output TAC ## 70 Islope2 Output TAC ## 71 Islope4 Output TAC ## 72 IT10 Output TAC ## 73 IT5 Output TAC ## 74 Itarget1 Output TAC ## 75 Itarget2 Output TAC ## 76 Itarget3 Output TAC ## 77 Itarget4 Output TAC ## 78 ITM Output TAC ## 79 L95target Output TAC ## 80 Lratio_BHI Output TAC ## 81 Lratio_BHI2 Output TAC ## 82 Lratio_BHI3 Output TAC ## 83 LstepCC1 Output TAC ## 84 LstepCC2 Output TAC ## 85 LstepCC3 Output TAC ## 86 LstepCC4 Output TAC ## 87 Ltarget1 Output TAC ## 88 Ltarget2 Output TAC ## 89 Ltarget3 Output TAC ## 90 Ltarget4 Output TAC ## 91 MCD Output TAC ## 92 MCD4010 Output TAC ## 93 Rcontrol Output TAC ## 94 Rcontrol2 Output TAC ## 95 SBT1 Output TAC ## 96 SBT2 Output TAC ## 97 SPmod Output TAC ## 98 SPMSY Output TAC ## 99 SPslope Output TAC ## 100 SPSRA Output TAC ## 101 SPSRA_ML Output TAC ## 102 YPR Output TAC ## 103 YPR_CC Output TAC ## 104 YPR_ML Output TAC ## 105 FMSYref Reference TAC ## 106 FMSYref50 Reference TAC ## 107 FMSYref75 Reference TAC ## 108 NFref Reference TAC You can access help documentation for the MPs in the usual fashion, for example: ?DCAC 5.3.1 Input Control MPs Input controls allow some combination of adjustments to fishing effort, size selectivity, or spatial area. The available input control MPs are: avail(&quot;Input&quot;) ## [1] &quot;curE&quot; &quot;curE75&quot; &quot;DDe&quot; &quot;DDe75&quot; &quot;DDes&quot; ## [6] &quot;DTe40&quot; &quot;DTe50&quot; &quot;EtargetLopt&quot; &quot;ItargetE1&quot; &quot;ItargetE2&quot; ## [11] &quot;ItargetE3&quot; &quot;ItargetE4&quot; &quot;ITe10&quot; &quot;ITe5&quot; &quot;LBSPR&quot; ## [16] &quot;LBSPR_MLL&quot; &quot;LstepCE1&quot; &quot;LstepCE2&quot; &quot;LtargetE1&quot; &quot;LtargetE4&quot; ## [21] &quot;matlenlim&quot; &quot;matlenlim2&quot; &quot;minlenLopt1&quot; &quot;MRnoreal&quot; &quot;MRreal&quot; ## [26] &quot;slotlim&quot; Remember, to access help documentation: ?matlenlim More information on input control MPs can be found in Beyond the Catch Limit. 5.3.2 Output Control MPs The output control methods in the DLMtool provide a management recommendation in the form of a TAC. Some output controls are stochastic, allowing for uncertainty in the data or input parameters, and return a distribution of recommended TACs. Output control methods are very common in fisheries management, especially in regions which have a tradition of managing fisheries by regulating the total amount of catch. The available output controls are: avail(&#39;Output&#39;) ## [1] &quot;AvC&quot; &quot;BK&quot; &quot;BK_CC&quot; &quot;BK_ML&quot; &quot;CC1&quot; ## [6] &quot;CC2&quot; &quot;CC3&quot; &quot;CC4&quot; &quot;CC5&quot; &quot;CompSRA&quot; ## [11] &quot;CompSRA4010&quot; &quot;DAAC&quot; &quot;DBSRA&quot; &quot;DBSRA_40&quot; &quot;DBSRA4010&quot; ## [16] &quot;DCAC&quot; &quot;DCAC_40&quot; &quot;DCAC_ML&quot; &quot;DCAC4010&quot; &quot;DCACs&quot; ## [21] &quot;DD&quot; &quot;DD4010&quot; &quot;DepF&quot; &quot;DynF&quot; &quot;Fadapt&quot; ## [26] &quot;Fdem&quot; &quot;Fdem_CC&quot; &quot;Fdem_ML&quot; &quot;Fratio&quot; &quot;Fratio_CC&quot; ## [31] &quot;Fratio_ML&quot; &quot;Fratio4010&quot; &quot;GB_CC&quot; &quot;GB_slope&quot; &quot;GB_target&quot; ## [36] &quot;Gcontrol&quot; &quot;HDAAC&quot; &quot;ICI&quot; &quot;ICI2&quot; &quot;Iratio&quot; ## [41] &quot;Islope1&quot; &quot;Islope2&quot; &quot;Islope4&quot; &quot;IT10&quot; &quot;IT5&quot; ## [46] &quot;Itarget1&quot; &quot;Itarget2&quot; &quot;Itarget3&quot; &quot;Itarget4&quot; &quot;ITM&quot; ## [51] &quot;L95target&quot; &quot;Lratio_BHI&quot; &quot;Lratio_BHI2&quot; &quot;Lratio_BHI3&quot; &quot;LstepCC1&quot; ## [56] &quot;LstepCC2&quot; &quot;LstepCC3&quot; &quot;LstepCC4&quot; &quot;Ltarget1&quot; &quot;Ltarget2&quot; ## [61] &quot;Ltarget3&quot; &quot;Ltarget4&quot; &quot;MCD&quot; &quot;MCD4010&quot; &quot;Rcontrol&quot; ## [66] &quot;Rcontrol2&quot; &quot;SBT1&quot; &quot;SBT2&quot; &quot;SPmod&quot; &quot;SPMSY&quot; ## [71] &quot;SPslope&quot; &quot;SPSRA&quot; &quot;SPSRA_ML&quot; &quot;YPR&quot; &quot;YPR_CC&quot; ## [76] &quot;YPR_ML&quot; 5.3.3 Mixed MPs Mixed MPs return a combination of input and output controls. Currently there are only a few mixed MPs in DLMtool, and these were developed simply for demonstration purposes. They may not work very well! See Developing Custom Management Procedures for more information on developing your own mixed MPs. And please share them with us, we’d love to add them to DLMtool! avail(&#39;Mixed&#39;) ## [1] &quot;AvC_MLL&quot; &quot;Itarget1_MPA&quot; 5.3.4 Reference MPs The final type is the reference MPs. These MPs are not designed to be used in practice, but are useful for providing a reference for comparing for the performance of other MPs. For example, the FMSYref and NFref methods (fishing perfectedly at F[MSY] and no fishing at all) can be useful for framing realistic performance with respect to a set of management objectives. The available reference MPs are: avail(&#39;Reference&#39;) ## [1] &quot;FMSYref&quot; &quot;FMSYref50&quot; &quot;FMSYref75&quot; &quot;NFref&quot; "],
["running-the-mse.html", "Chapter 6 Running the MSE 6.1 Specify an Operating Model 6.2 Choose the Management Procedures 6.3 Run the MSE", " Chapter 6 Running the MSE We have now covered the two main components of the MSE: the Operating Model (OM) and the Management Procedures (MPs). To run a MSE we need to specify the OM and the set of MPs that we wish to test. Here we will create an OM from the built-in objects and choose 2 MPs of each type to test in our demonstration MSE. 6.1 Specify an Operating Model First, we will construct the OM using a different set of built-in Stock, Fleet, Obs, and Imp objects: myOM &lt;- new(&quot;OM&quot;, Albacore, DecE_Dom, Imprecise_Unbiased, Overages) 6.2 Choose the Management Procedures Next, we’ll select 8 MPs to test in our MSE: myMPs &lt;- c(&#39;AvC&#39;, &#39;Itarget1&#39;, &#39;matlenlim&#39;, &#39;ITe10&#39;, &#39;AvC_MLL&#39;, &#39;Itarget1_MPA&#39;, &#39;FMSYref&#39;, &#39;NFref&#39;) MPtype(myMPs) ## MP Type Recs ## 1 matlenlim Input SL ## 2 ITe10 Input TAE ## 3 AvC_MLL Mixed TAC, SL ## 4 Itarget1_MPA Mixed TAC, Spatial ## 5 AvC Output TAC ## 6 Itarget1 Output TAC ## 7 FMSYref Reference TAC ## 8 NFref Reference TAC See Determining Feasible and Available Management Procedures for information on how to identify management procedures that are potentially suitable for your fishery. 6.3 Run the MSE Now that we have specified an OM and chosen a set of management procedures we are ready to run the MSE: myMSE &lt;- runMSE(OM=myOM, MPs=myMPs) This may take a minute or two to run. We have now conducted a Management Strategy Evaluation for our fishery described in the Operating Model with 8 Management Procedures. Next we will evaluate whether the model has converged and then look at the MSE results. "],
["checking-convergence.html", "Chapter 7 Checking Convergence", " Chapter 7 Checking Convergence It is important to ensure that we have included enough simulations in the MSE for the results to be stable. The Converge function can be used to confirm that the number of simulations is sufficient and the MSE model has converged, by which we mean that the relative position of the Management Procedures are stable with respect to different performance metrics and the performance statistics have stablized, i.e., they won’t change significantly if the model was run with more simulations. The purpose of the Converge function is to answer the question: have I run enough simulations? By default the Converge function includes three commonly used performance metrics, and plots the performance statistics against the number of simulations. The convergence diagnostics are: Does the order of the MPs change as more simulations are added? By default this is calculated over the last 20 simulations. Is the average difference in the performance statistic over the last 20 simulations changing by more than 2%? The number of simulations to calculate the convergence statistics, the minimum change threshold, and the performance metrics to use can be specified as arguments to the function. See the help documentation for more details (?Converge). Converge(myMSE) ## Checking if order of MPs is changing in last 20 iterations ## Checking average difference in PM over last 20 iterations is &gt; 0.5 ## Plotting MPs 1 - 8 ## ## Yield relative to Reference Yield (Years 1-50) ## Mean difference over last 20 iterations is &gt; 0.5 for: ## Itarget1 matlenlim AvC_MLL Itarget1_MPA ## ## Spawning Biomass relative to SBMSY ## Mean difference over last 20 iterations is &gt; 0.5 for: ## ITe10 ## ## Average Annual Variability in Yield (Years 1-50) ## Mean difference over last 20 iterations is &gt; 0.5 for: ## AvC Itarget1 matlenlim ITe10 AvC_MLL Itarget1_MPA FMSYref Have we run enough simulations? The convergence plot reveals that both the order of the MPs and the performance statistics are not stable. This suggests that 48 simulations is not enough to produce reliable results. Let’s increase the number of simulations and try again: myOM@nsim &lt;- 200 myMSE_200 &lt;- runMSE(OM=myOM, MPs=myMPs) Is 200 simulations enough? Converge(myMSE_200) ## Checking if order of MPs is changing in last 20 iterations ## Checking average difference in PM over last 20 iterations is &gt; 0.5 ## Plotting MPs 1 - 8 "],
["examining-the-mse-results.html", "Chapter 8 Examining the MSE Results 8.1 Introducing Performance Metrics 8.2 Summary Table 8.3 Plotting MSE Results", " Chapter 8 Examining the MSE Results Arguably the most important part of the MSE is interpreting the results and identifying a management procedure (MP) that is most suitable for the fishery. This involves asking several questions: Which MPs can be excluded from the list of candidates because they perform worst than all other options? Which MPs are most likely to meet our management objectives? How do we identify the MP most suited to our fishery? Which data sources are most critical to the performance of the best performing MP? 8.1 Introducing Performance Metrics To interpret the MSE results it is important that a clear set of performance metrics have been defined. Fisheries managers often have broadly defined policy goals. These conceptual objectives must be translated to quantitative operational objectives so that the MSE results can be used to evaluate performance against the specified management objectives. For example, suppose that the fishery managers had stated broad goals to maximize yield from the fishery while minimizing the risk of the stock collapsing to unacceptably low levels. In order to use MSE to determine which MPs are most likely to meet these objectives it is neccessary to be more specific: What are unacceptable low stock levels? Some fraction of unfished biomass? The lowest observed historical biomass? What is an acceptable level of risk? What chance are we willing to tolerate that the stock will fall below that limit? How much yield are we willing to give up in order to increase the probability of the stock staying above unacceptably low limit? It is important to recognize that performance metrics can vary considerably between different fisheries and management structures, but are a crucial component of the MSE and must be carefully defined before the analysis is carried out. The Performance Metrics chapter discusses this topic in more detail. The DLMtool includes a number of commonly used performance metrics and a series of functions to summarize MP performance. The MSE results can be examined either graphically in a plot or summarized in a table. Advanced users can also develop their own plotting and summary functions (see the Custom Performance Metrics chapter for more details). Here we briefly demonstrate some of the plotting and summary functions in DLMtool. The Examining the MSE object chapter and other chapters in that section describe the process of evaluating MSE results in more detail. 8.2 Summary Table The summary function can be used to generate a table of MP performance with respect to a set of performance metrics: summary(myMSE_200) ## Calculating Performance Metrics ## Performance.Metrics ## 1 Probability of not overfishing (F&lt;FMSY) ## 2 Spawning Biomass relative to SBMSY ## 3 Average Annual Variability in Yield (Years 1-50) ## 4 Average Yield relative to Reference Yield (Years 41-50) ## ## 1 Prob. F &lt; FMSY (Years 1 - 50) ## 2 Prob. SB &gt; 0.5 SBMSY (Years 1 - 50) ## 3 Prob. AAVY &lt; 20% (Years 1-50) ## 4 Prob. Yield &gt; 0.5 Ref. Yield (Years 41-50) ## ## ## Probability: ## MP PNOF P50 AAVY LTY ## 1 AvC 0.73 0.92 0.520 0.83 ## 2 Itarget1 0.87 0.97 0.760 0.79 ## 3 matlenlim 0.75 0.99 0.075 0.63 ## 4 ITe10 0.33 0.60 0.200 0.60 ## 5 AvC_MLL 0.48 0.99 0.180 0.63 ## 6 Itarget1_MPA 0.87 0.98 0.760 0.78 ## 7 FMSYref 0.15 0.98 0.400 0.88 ## 8 NFref 1.00 1.00 1.000 0.00 By default the summary function includes four performance metrics, and displays the probability that: fishing mortality \\(\\left(F\\right)\\) is below \\(F_\\text{MSY}\\), i.e Not Overfishing (PNOF) spawning biomass \\(\\left(\\text{SB}\\right)\\) is above half of biomass at maximum sustainable yield \\(\\left(\\text{SB}_{\\text{MSY}}\\right)\\) (P50) average interannual variability in yield is less than 20% (AAVY) long-term yield (last 10 years of projection period) is above half of the maximum yield obtainable at a constant fishing rate (LTY) In this example we can see that probability of \\(\\text{SB} &gt; 0.5\\text{SB}_\\text{MSY}\\) for AvC is 0.92. The performance metrics have been defined in such a way that a higher number is always better (e.g, probability of Not Overfishing rather than Overfishing where a lower probability would be more desirable). Help documentation for the peformance metrics can be found in the usual way, for example: ?PNOF The performance metrics in the summary function are completely customizable. See the Performance Metrics and Custom Performance Metrics chapters for more details. 8.3 Plotting MSE Results DLMtool includes several functions for plotting the MSE results. You can see a list of all the plotting functions in the DLMtool for MSE objects using the plotFun function: plotFun() ## DLMtool functions for plotting objects of class MSE are: ## barplot COSEWIC_Dplot COSEWIC_Hplot COSEWIC_Pplot Cplot ## DFO_plot DFO_plot2 DFO_proj IOTC_plot Kplot ## NOAA_plot NOAA_plot2 Pplot Pplot2 PWhisker ## Tplot Tplot_old Tplot2 Tplot2_old Tplot3 ## TradePlot TradePlot_old VOI VOI2 VOIplot ## VOIplot2 wormplot Here we demonstrate a few of the plotting functions for the MSE results. 8.3.1 Trade-Off Plots The Tplot function creates four plots that show the trade-off between the probability that the long-term expected yield is greater than half of the highest obtainable yield at a fixed F (reference yield) against the probability of: Not overfishing in all projection years (\\(F/F_\\text{MSY} &lt; 1\\)) Spawning biomass (\\(\\text{SB}\\)) above \\(\\text{SB}_\\text{MSY}\\) in all projection years (\\(\\text{SB} &gt; \\text{SB}_\\text{MSY}\\)) Spawning biomass above \\(0.5 \\text{SB}_\\text{MSY}\\) (\\(\\text{SB} &gt; 0.5 \\text{SB}_\\text{MSY}\\)) Spawning biomass above \\(0.1 \\text{SB}_\\text{MSY}\\) (\\(\\text{SB} &gt; 0.1 \\text{SB}_\\text{MSY}\\)) The Tplot function includes minimum acceptable risk thresholds indicated by the horizontal and vertical gray shading. These thresholds can be adjusted be the Lims argument to the Tplot function. See ?Tplot for more information on adjusting the risk thresholds. MPs that fail to meet one or both of the risk thresholds for each axis are shown in italics text. The Tplot function returns a data frame showing the performance of each MP with respect to the 5 performance metrics, and whether the MP is Satisificed, i.e., if it meets the minimum performance criteria for all performance metrics. Tplot(myMSE_200) ## MP PNOF LTY P100 P50 P10 Satisificed ## 1 AvC 0.73 0.83 0.78 0.92 0.98 TRUE ## 2 Itarget1 0.87 0.79 0.88 0.97 1.00 TRUE ## 3 matlenlim 0.75 0.63 0.93 0.99 1.00 TRUE ## 4 ITe10 0.33 0.60 0.34 0.60 0.89 FALSE ## 5 AvC_MLL 0.48 0.63 0.95 0.99 1.00 FALSE ## 6 Itarget1_MPA 0.87 0.78 0.89 0.98 1.00 TRUE ## 7 FMSYref 0.15 0.88 0.75 0.98 1.00 FALSE ## 8 NFref 1.00 0.00 0.98 1.00 1.00 FALSE The Tplot2 function shows the trade-off between long-term and short-term yield, and the trade-off between biomass being above \\(0.1B_{MSY}\\) and the expected variability in the yield: Tplot2(myMSE_200) ## MP STY LTY P10 AAVY Satisificed ## 1 AvC 0.84 0.83 0.98 0.520 FALSE ## 2 Itarget1 0.62 0.79 1.00 0.760 FALSE ## 3 matlenlim 0.48 0.63 1.00 0.075 FALSE ## 4 ITe10 0.87 0.60 0.89 0.200 FALSE ## 5 AvC_MLL 0.49 0.63 1.00 0.180 FALSE ## 6 Itarget1_MPA 0.62 0.78 1.00 0.760 FALSE ## 7 FMSYref 0.83 0.88 1.00 0.400 FALSE ## 8 NFref 0.00 0.00 1.00 1.000 FALSE The Tplot, Tplot2 and Tplot3 functions are part of a family of plotting functions that are fully customizable, and designed to work with all Performance Metrics objects. See ?Tplot and the Performance Metrics chapter for more information. 8.3.2 Wormplot The wormplot function plots the likelihood of meeting biomass targets in future years: wormplot(myMSE_200) The arguments to the wormplot function allow you to choose the reference level for the biomass relative to \\(B_{MSY}\\), as well as the upper and lower bounds of the colored bands. 8.3.3 Projection Plots The Pplot function plots the trajectories of biomass, fishing mortality, and relative yield for the Management Procedures. By default, the Pplot function shows the individual trajectories of \\(B/B_{MSY}\\) and \\(F/F_{MSY}\\) for each simulation: Pplot(myMSE_200) The Pplot2 function has several additional arguments. The YVar argument can be used to specify additional variables of interest. For example, here we have included the projections of yield relative to the long-term optimum yield: Pplot2(myMSE_200, YVar=c(&quot;B_BMSY&quot;, &quot;F_FMSY&quot;, &quot;Yield&quot;)) ## MSE object has more than 6 MPs. Plotting the first 6 The traj argument can be used to summarize the projections into quantiles. Here we show the 20th and 80th percentiles of the distributions (the median (50th percentile) is included by default): Pplot2(myMSE_200, traj=&quot;quant&quot;, quants=c(0.2, 0.8)) ## MSE object has more than 6 MPs. Plotting the first 6 Details on additional controls for the Pplot and Pplot2 functions can be found in the help documentation associated with this function. 8.3.4 Kobe Plots Kobe plots are often used in stock assessment and MSE to examine the proportion of time the stock spends in different states. A Kobe plot of the MSE results can be produced with the Kplot function: Kplot(myMSE_200) 8.3.5 Compare to Current Conditions The Cplot shows a scatter plot of the median biomass and median yield over the last five years of the projection relative to the current conditions (the last year in the historical period): Cplot(myMSE_200) "],
["parallel-processing.html", "Chapter 9 Parallel Processing 9.1 Setting up Parallel Processing 9.2 Running MSE with Parallel Processing 9.3 Determining Optimal Number of Processors", " Chapter 9 Parallel Processing Parallel processing increases the speed of running the MSE in DLMtool significantly. The use of parallel processing in DLMtool has changed slightly from previous versions of the package. By default the MSE runs without using parallel processing. We recommend running a few test runs of your MSE with a low number of simulations and without parallel processing. Once you are satisfied the model is running correctly for your operating model, you can increase the number of simulations and use parallel processing. 9.1 Setting up Parallel Processing The setup function is used to set up parallel processing. setup() ## R Version: R version 3.5.2 (2018-12-20) ## snowfall 1.84-6.1 initialized (using snow 0.4-3): parallel execution on 10 CPUs. ## Library DLMtool loaded. ## Library DLMtool loaded in cluster. By default the setup function initializes half of the available processors as we have found this to be the most efficient for most systems. You can change the number of processors by specifying the cpu argument, e.g., setup(cpu=6). See Determining Optimal Number of Processors for more details on calculating the optimal number of processors to use on your system. 9.2 Running MSE with Parallel Processing Use the parallel=TRUE argument in runMSE to use parallel processing. Note that you must run setup() first. You will notice that the usual update messages are not printed to the console when parallel processing is used. This is why it is important to initially test your MSE with a small number of simulations without parallel processing. myMSE_200P &lt;- runMSE(myOM, parallel = TRUE) ## Running MSE in parallel on 10 processors ## MSE completed Parallel processing can increase the speed of running the MSE considerably. For example, although in this demonstration we are only running a low number of simulations, run time decreased from 7 to 11 seconds when using parallel processing on 10 processors. 9.3 Determining Optimal Number of Processors The optCPU function can be used to evaluate the relationship between number of processors and run time: optCPU() ## ncpu time ## 1 1 37.22 ## 2 2 18.96 ## 3 3 12.92 ## 4 4 9.95 ## 5 5 8.56 ## 6 6 7.32 ## 7 7 6.75 ## 8 8 6.20 ## 9 9 6.04 ## 10 10 5.79 ## 11 11 6.09 ## 12 12 6.23 "],
["creating-a-new-operating-model.html", "Chapter 10 Creating a New Operating Model 10.1 An Example WorkFlow 10.2 Create a New Project 10.3 Initialize a New OM 10.4 Populate and Document OM 10.5 Compile the OM Report 10.6 Import the OM into R 10.7 Documenting an Existing OM", " Chapter 10 Creating a New Operating Model 10.1 An Example WorkFlow The figure below shows our recommended workflow creating a new Operating Model (OM) in DLMtool. 10.2 Create a New Project We recommend creating a new directory for each OM. Each new R session should start by setting the working directory to this location. One of the easiest ways to do this is to create a new project in RStudio (File &gt; New Project) and open this each time you revisit the analysis. Alternatively, you can set the working directory with RStudio (Session &gt; Set Working Directory) or directly in the R console, for example: setwd(&quot;C:/MSE/MyOM&quot;) 10.3 Initialize a New OM The OMinit function is used to create a blank OM spreadsheet and a skeleton OM documentation file in the working directory. This is only required the first time a new OM is created. The OMinit function requires one argument, a name for the OM, and wil create two files in the working directory. For example OMinit('MyOM') will create MyOM.xlsx and MyOM.rmd in the working directory. MyOM.xlsx is a spreadsheet with sheets corresponding to the components of an OM: Stock, Fleet, Obs, and Imp, and OM worksheets. The first column in each sheet is populated with the names of the slots of the respective objects (Stock, Fleet, etc) and all slots are empty (except the OM sheet which has default values). The filled grey cells represent optional parameters - these are not required to run the MSE but may be used to further customized the OM (e.g age-dependant M). Values are required for all other parameters. The MyOM.rmd file can be opened in any text editor or RStudio, and contains a skeleton for the OM documentation. The OMinit function also creates several folders in the working directory: data, docs, images, and robustness. These sub-directories can be used to store data, documents, images, and other information that is reference in the OM Report. 10.3.1 Using Templates Note: This feature requires additional software and may not be available on all systems. Specifically, it requires a zip application on the system PATH. Possibly the easiest way for this is to install Rtools on your system. However, please note that this feature is not required to use DLMtool. Some users may wish to build an operating model based on other pre-existing OM, Stock, Fleet, Obs, or Imp objects. For example, OMinit('Albacore2', Albacore) will result in a Albacore2.xlsx file being created with the Stock sheet populated with the values from the Albacore Stock object. Other examples: OMinit(&#39;StockAndFleet&#39;, Albacore, Generic_FlatE) # using existing Stock and Fleet objects OMinit(&#39;ObsAndImp&#39;, Generic_Obs, Perfect_Imp) # using existing Obs and Imp objects OMinit(&#39;BorrowOM&#39;, OtherOM) # using an existing OM 10.3.2 An Example In this example we are going to create an OM called ‘MyOM’ using existing OM objects: OMinit(&#39;MyOM&#39;, Albacore, Generic_FlatE, Imprecise_Unbiased, Perfect_Imp) We did this so that we can demonstrate the populated Excel and RMarkdown Files. To create a blank OM called ‘MyOM’ you would simply write: OMinit(&#39;MyOM&#39;) 10.4 Populate and Document OM Next we open Excel workbook and populate the OM. Because we used templates our workbook is already populated. You can download and inspect the populated OM workbook we created in the previous step. To assist in documenting the rationale for the OM parameters, we recommended adding a short but informative description or rationale for the OM values in the RMarkdown file while the OM Excel file is being populated (open the RMarkdown file and edit with any text editor or RStudio). Once complete, the RMarkdown file can be compiled into a HTML report and provides a complete documentation for the OM. The RMarkdown file we created earlier can be accessed here and opened in RStudio. You will see that the RMarkdown file has a series of headings (marked by #, ##, and ### for first, second and third level respectively) followed by some text, in this case default text is mainly instructions on how to fill the document. The instruction text should be deleted and replaced with the relevant information for your operating model. For example, below the line “# Introduction” you would delete the instructions and provide a brief introduction to your fishery and the purpose of the OM and MSE. It is important not to delete any of the headings. After the Introduction section, the document has four first level headings corresponding to the Stock, Fleet, Obs and Imp components of the operating model. Each section has a series of second level headings (e.g., ## M) which correspond to the slots of that object. In this example, the text below these headings indicates that this parameter was borrowed from another object (e.g ‘Borrowd from: Albacore’). If the parameters in the OM workbook are modified from those borrowed from the existing object (in this case ‘Albacore’), you would delete this text and replace it will your own justification. If you did not initialize your OM using existing objects as templates, it will say something like ‘No justification provided’. It is not neccessary to include the actual values in the justification text. The RMarkdown file containing the justifications/rationale will be compiled together with the OM Excel workbook containing the OM parameter values into a OM Report that contains both the justification text, the OM values, and a series of plots to visualize the OM parameters and properties. The OM documentation file should be updated whenever values in the OM are changed. 10.5 Compile the OM Report Once the OM has been specified in the spreadsheet and documented in the RMarkdown file, it can be compiled into a OM Report using the OMdoc function. The OMdoc function OMdoc(&#39;MyOM&#39;) In most cases it is not neccessary to provide the name of the RMarkdown file to OMdoc. By default the OMdoc function will look for a file with the extension ‘.rmd’ in working directory. For example, if the Excel file is named MyOM then OMdoc will look for MyOM.rmd, which is default name created by OMinit. Additionally, if there is only one xlsx file in the working directory the name of the OM is not required, i.e., OMdoc(). The resulting MyOM.html can opened in any web browser. Because we have not replaced any of the default text in the RMarkdown file, the resulting OM Report contains the same text. In your case, this default text should be replaced with information relevant to your OM. It is also be possible to compile the OM report into a pdf using OMdoc('MyOM', output=&quot;pdf_document&quot;), although this may require the installation of additional software on your system. 10.6 Import the OM into R The OM can be imported from the Excel file using the XL2OM function. For example, to import the example OM created in the previous section: OM &lt;- XL2OM(&#39;MyOM&#39;) The OM is now ready to be used for analysis, for example: # Plot the OM plot(OM) # Run an MSE using default MPs MyMSE &lt;- runMSE(OM) 10.7 Documenting an Existing OM To document existing OMs that don’t use the Excel workbook the OMinit function can be used to create just the RMarkdown documentation file in the working directory. The OMdoc function can be used to generate an OM report directly from an OM object and a RMarkdown file. In this case it is necessary to provide the name of the Rmarkdown file to OMdoc. For example, here we create an OM using existing objects from DLMtool, generate the RMarkdown documentation skeleton (only required once), and compile the OM report: BlueSharkOM &lt;- new(&#39;OM&#39;, Blue_shark, Generic_Fleet, Imprecise_Biased, Perfect_Imp) OMinit(&#39;BlueSharkOM&#39;, files=&#39;rmd&#39;, BlueSharkOM) # - Enter OM details in BlueSharkOM.rmd - OMdoc(BlueSharkOM, &#39;BlueSharkOM.rmd&#39;) The same process is used if you are using the cpars feature to provide custom parameters to the MSE (see Custom Parameters section for more details). "],
["generating-correlated-life-history-parameters.html", "Chapter 11 Generating Correlated Life-History Parameters 11.1 Predicting all life-history parameters 11.2 Predicting some life-history parameters 11.3 Predicting correlated parameters 11.4 Introducing Custom Parameters", " Chapter 11 Generating Correlated Life-History Parameters By default DLMtool independently samples the life-history parameters from uniform distributions. The LH2OM function can be used to force correlation between the life-history parameters, or predict values for missing life-history parameters. Thorson et al. (2017) developed a hierarchical model, based on records available in FishBase, to predict life-history parameters for all 33,000+ fish species listed within FishBase. The LH2OM function uses the Thorson et al. (2017) model to generate correlated samples of the life-history parameters based on the relevant taxonomic information (Class, Family, Genus, and Species) for the species being modelled in the MSE. The approach uses taxonomic information and any available information on the life-history parameters of the species in the OM to generate predictions of the missing parameters. For example, if no knowledge exists on the four life-history parameters (Linf, L50, M, and K), the model uses the taxonomic information (first Genus and Species, and if records don’t exist for this species in FishBase, then up a taxonomic level to Family, and so on) to generate predicted values for all four parameters. If information is available for some parameters, e.g., reasonable bounds on Linf and M for the species, the hierarchical model is used to generate predictions of the corresponding L50 and K values. That is, the observed ratios of L50/Linf and M/K are maintained. In this way the simulated life-history strategies are biologically realistic, and are appropriate for the species being modelled in the MSE. 11.1 Predicting all life-history parameters The LH2OM function can be used to predict the four correlated life-history parameters (Linf, L50, M, and K) using only the available taxonomic information (only for fish species). For example, here we create an empty OM object, populate the Species slot and use the LH2OM function to predict the life-history parameters using hierarchical model (Thorson et al. 2017): OM &lt;- new(&quot;OM&quot;) ## No Stock object found. Returning a blank OM object OM@Species &lt;- &quot;Scomber japonicus&quot; OM &lt;- LH2OM(OM) ## Predicting Linf ## Predicting L50 ## Predicting K ## Predicting M ## Species match: Actinopterygii Perciformes Scombridae Scomber japonicus 11.2 Predicting some life-history parameters In some cases local estimates of life-history parameters may be available which are more reliable and less variable than those predicted from the FishBase database. For example, suppose that we had estimates of the natural mortality rate (M) for our stock that ranged between 0.3 and 0.4. We populate the OM@M slot with these values and use LH2OM to predict the correlated K parameter values: OM &lt;- new(&quot;OM&quot;) ## No Stock object found. Returning a blank OM object OM@Species &lt;- &quot;Scomber japonicus&quot; OM@M &lt;- c(0.3, 0.4) OM &lt;- LH2OM(OM) ## Predicting Linf ## Predicting L50 ## Predicting K ## Predicting K from M ## Species match: Actinopterygii Perciformes Scombridae Scomber japonicus Notice that the sampled M values are within the bounds specified in OM@M (vertical lines). Similiarly, if information is also available for asymptotic length Linf: OM &lt;- new(&quot;OM&quot;) ## No Stock object found. Returning a blank OM object OM@Species &lt;- &quot;Scomber japonicus&quot; OM@M &lt;- c(0.3, 0.4) OM@Linf &lt;- c(35, 40) OM &lt;- LH2OM(OM) ## Predicting L50 ## Predicting K ## Predicting L50 from Linf ## Predicting K from M ## Species match: Actinopterygii Perciformes Scombridae Scomber japonicus 11.3 Predicting correlated parameters If bounds for all life-history parameters are specified in the OM, the LH2OM function will predict values of L50 and K which may fall outside of the bounds specified in the OM. For example, here we specify bounds for all life-history parameters and see that the predicted values for L50 and K are mostly above and below the bounds we specied in the OM slots (vertical lines and shading). This is because the predictions of the L50/Linf and M/K ratios from the FishBase database were outside the ranges specied in the OM; in other words, the ranges specified in the OM have rarely been observed in nature. OM &lt;- new(&quot;OM&quot;) ## No Stock object found. Returning a blank OM object OM@Species &lt;- &quot;Scomber japonicus&quot; OM@M &lt;- c(0.3, 0.4) OM@K &lt;- c(0.2, 0.3) OM@Linf &lt;- c(35, 40) OM@L50 &lt;- c(15, 20) OM &lt;- LH2OM(OM) ## Predicting L50 from Linf ## Predicting K from M ## Species match: Actinopterygii Perciformes Scombridae Scomber japonicus We can force the LH2OM function to only return values within the M and K bounds by using the filterMK argument: OM &lt;- new(&quot;OM&quot;) ## No Stock object found. Returning a blank OM object OM@Species &lt;- &quot;Scomber japonicus&quot; OM@M &lt;- c(0.3, 0.4) OM@K &lt;- c(0.2, 0.3) OM@Linf &lt;- c(35, 40) OM@L50 &lt;- c(15, 20) OM &lt;- LH2OM(OM, filterMK=TRUE) ## Predicting L50 from Linf ## Predicting K from M ## Filtering predicted K within bounds: 0.2 0.3 ## Species match: Actinopterygii Perciformes Scombridae Scomber japonicus 11.4 Introducing Custom Parameters The LH2OM function uses a feature of DLMtool called Custom Parameters, which are stored in the OM@cpars slot. By default the OM@cpars is an empty list: OM &lt;- new(&quot;OM&quot;) ## No Stock object found. Returning a blank OM object str(OM@cpars) ## list() After using the LH2OM function, the cpars slot is populated with OM@nsim correlated samples of the life-history parameters: OM &lt;- new(&quot;OM&quot;) ## No Stock object found. Returning a blank OM object OM@Species &lt;- &quot;Scomber japonicus&quot; OM@M &lt;- c(0.3, 0.4) OM &lt;- LH2OM(OM, plot=FALSE, msg=FALSE) str(OM@cpars) ## List of 4 ## $ Linf: num [1:48] 42 44.4 42.8 48.3 42.7 ... ## $ M : num [1:48] 0.38 0.383 0.339 0.385 0.335 ... ## $ K : num [1:48] 0.226 0.232 0.206 0.246 0.187 ... ## $ L50 : num [1:48] 26.2 27.8 27.1 30 25.7 ... Notice also that the OM@M slot is no longer used after the LH2OM function has been run on the OM object: OM@M ## [1] 0 0 Custom Parameters are a very powerful way to customize the DLMtool, and allow users full control over all sampled and most internal parameters in the DLMtool Operating Model. See the Custom Parameters chapter for more information on this feature. "],
["modifying-the-om.html", "Chapter 12 Modifying the OM 12.1 The tinyErr function 12.2 The Replace function", " Chapter 12 Modifying the OM It is often desirable to created modified versions of an OM for testing purposes such as series of robustness tests or to evaluate whether an MP is performing as expected under ideal conditions. DLMtool includes several functions for this purpose. 12.1 The tinyErr function The tinyErr function can be used to remove observation, implementation, and process error, as well as any gradients in life-history parameters. For example, we first create an Operating Model using built-in OM Components: OM &lt;- new(&quot;OM&quot;, Albacore, Generic_IncE, Imprecise_Biased, Overages) Notice that our OM includes process error and gradients in life-history parameters, as well as observation and implementation error: OM@Perr # recruitment process error ## [1] 0.15 0.30 OM@Linfgrad # gradient in Linf ## numeric(0) OM@Cobs # error in observations ## [1] 0.2 0.6 OM@TACFrac # implementation error in TAC ## [1] 1.1 1.2 By default the tinyErr function will remove all sources of uncertainty and variability: OM2 &lt;- tinyErr(OM) ## Removing all Observation Error ## Removing all Implementation Error ## Removing all Process Error ## Removing all Gradients OM2@Perr # no recruitment process error ## [1] 0 0 OM2@Linfgrad # no gradient in Linf ## [1] 0 0 OM2@Cobs # very low observation error ## [1] 0.00 0.05 OM2@TACFrac # no implementation error ## [1] 1 1 The obs, imp, proc, and grad arguments to the tinyErr function can be used to control which sources of error and variability to remove from the OM. See ?tinyErr for more details. 12.2 The Replace function The can be used to replace individual Stock, Fleet, Obs, or Imp components in an Operating Model. For example, to replace the Stock object in an OM we provide Replace with a new Stock object: OM1 &lt;- new(&quot;OM&quot;, Albacore, Generic_DecE, Generic_Obs, Overages) OM2 &lt;- Replace(OM1, Blue_shark, Name=&quot;Blue_shark OM based on OM1&quot;) ## Replacing sub-model: Stock Likewise, to replace any of the other OM components: OM1 &lt;- new(&quot;OM&quot;, Albacore, Generic_DecE, Generic_Obs, Overages) OM2 &lt;- Replace(OM1, Generic_IncE, Name=&quot;OM1 with new Fleet&quot;) ## Replacing sub-model: Fleet OM3 &lt;- Replace(OM2, Perfect_Info, Name=&quot;OM2 with new Obs&quot;) ## Replacing sub-model: Obs OM4 &lt;- Replace(OM3, Perfect_Imp, Name=&quot;OM2 with new Imp&quot;) ## Replacing sub-model: Imp "],
["operating-model-library.html", "Chapter 13 Operating Model Library", " Chapter 13 Operating Model Library We are in the process of developing an online library of DLMtool Operating Models. This library includes the OM Report, the OM Excel workbook, and the OM R Data file for many of the fisheries where DLMtool OMs have been built. The idea behind the OM library is to develop a resource for DLMtool users to learn from other applications as well as to provide OM templates which users can borrow and modify to suit their own fishery. The OM library is still being developed and we are continuing to add OMs that we have constructed. If you have built a DLMtool OM and are happy to make it public, please contact us through the website or email us directly, we would love to include it on our website. "],
["examining-the-mse-object.html", "Chapter 14 Examining the MSE object 14.1 The First Six Slots 14.2 The OM Slot 14.3 The Obs Slot 14.4 The B_BMSY and F_FMSY Slots 14.5 The B, FM, C and TAC Slots 14.6 The SSB_hist, CB_hist, and FM_hist Slots 14.7 The Effort Slot", " Chapter 14 Examining the MSE object The MSE object contains all of the output from the MSE. In this chapter we will examine the MSE object in more detail. First we will run an MSE so that we have an MSE object to work with. We will then briefly examine some of the contents of the MSE object. The chapters Performance Metrics and Custom Performance Metrics contain more information on the MSE object. We create an OM based on the Blue Shark stock object and other built-in objects: OM &lt;- new(&#39;OM&#39;, Blue_shark, Generic_Fleet, Imprecise_Biased, Perfect_Imp, nsim=200) Note that we have increased the number of simulations from the default 48 to 200: OM@nsim ## [1] 200 Let’s choose an arbitrary set of MPs: MPs &lt;- c(&quot;Fratio&quot;, &quot;DCAC&quot;, &quot;Fdem&quot;, &quot;DD&quot;, &quot;matlenlim&quot;) Set up parallel processing: setup() ## Library DLMtool loaded. And run the MSE using parallel processing and save the output to an object called BSharkMSE: BSharkMSE &lt;- runMSE(OM, MPs, parallel = TRUE) ## Running MSE in parallel on 10 processors ## MSE completed The names of the slots in an object of class MSE can be displayed using the slotNames function: slotNames(BSharkMSE) ## [1] &quot;Name&quot; &quot;nyears&quot; &quot;proyears&quot; &quot;nMPs&quot; &quot;MPs&quot; &quot;nsim&quot; ## [7] &quot;OM&quot; &quot;Obs&quot; &quot;B_BMSY&quot; &quot;F_FMSY&quot; &quot;B&quot; &quot;SSB&quot; ## [13] &quot;VB&quot; &quot;FM&quot; &quot;C&quot; &quot;TAC&quot; &quot;SSB_hist&quot; &quot;CB_hist&quot; ## [19] &quot;FM_hist&quot; &quot;Effort&quot; &quot;PAA&quot; &quot;CAA&quot; &quot;CAL&quot; &quot;CALbins&quot; ## [25] &quot;Misc&quot; As you can see, MSE objects contain all of the information from the MSE, stored in 25 slots. 14.1 The First Six Slots The first six slots contain information on the structure of the MSE. For example the first slot (Name), is a combination of the names of the Stock, Fleet, and Obs objects that were used in the MSE: BSharkMSE@Name ## [1] &quot;Stock:Blue shark Fleet:Generic_Fleet Obs model:Imprecise-Biased Imp model:Perfect_Imp&quot; Other information in these first slots includes the number of historical years (nyears), the number of projection years (proyears), the number of name of the Management Procedures (nMPs and MPs), and the number of simulations (nsim). 14.2 The OM Slot The OM slot in the MSE object is a data frame that the values of the parameters used in the Operating Model: names(BSharkMSE@OM) ## [1] &quot;A&quot; &quot;AC&quot; &quot;ageM&quot; &quot;Asp&quot; ## [5] &quot;Blow&quot; &quot;BMSY&quot; &quot;BMSY_B0&quot; &quot;D&quot; ## [9] &quot;dFfinal&quot; &quot;DR&quot; &quot;Esd&quot; &quot;Fdisc&quot; ## [13] &quot;FinF&quot; &quot;FMSY&quot; &quot;FMSY_M&quot; &quot;Frac_area_1&quot; ## [17] &quot;hs&quot; &quot;K&quot; &quot;Ksd&quot; &quot;L5&quot; ## [21] &quot;L50&quot; &quot;L50_95&quot; &quot;L95&quot; &quot;LenCV&quot; ## [25] &quot;LFR&quot; &quot;LFS&quot; &quot;Linf&quot; &quot;Linfsd&quot; ## [29] &quot;LR5&quot; &quot;M&quot; &quot;maxF&quot; &quot;maxlen&quot; ## [33] &quot;Mexp&quot; &quot;MGT&quot; &quot;Msd&quot; &quot;MSY&quot; ## [37] &quot;OFLreal&quot; &quot;Prob_staying&quot; &quot;procmu&quot; &quot;procsd&quot; ## [41] &quot;qcv&quot; &quot;qinc&quot; &quot;R0&quot; &quot;RefY&quot; ## [45] &quot;Rmaxlen&quot; &quot;Size_area_1&quot; &quot;SizeLimFrac&quot; &quot;SizeLimSD&quot; ## [49] &quot;Spat_targ&quot; &quot;SRrel&quot; &quot;SSB0&quot; &quot;SSBMSY&quot; ## [53] &quot;SSBMSY_SSB0&quot; &quot;t0&quot; &quot;TACFrac&quot; &quot;TACSD&quot; ## [57] &quot;TAEFrac&quot; &quot;TAESD&quot; &quot;UMSY&quot; &quot;Vmaxlen&quot; If you use the dim function to report the dimensions of the OM data frame, you’ll notice that there are 60 columns, corresponding to the 60 parameters in the Operating Model, and 200 rows, each corresponding to a single simulation of the MSE. More information on the MSE@OM slot can be found in the help documentation: class?MSE 14.3 The Obs Slot The Obs slot contains another data frame, this one with 26 columns corresponding to the values drawn from the Observation model: names(BSharkMSE@Obs) ## [1] &quot;Abias&quot; &quot;Aerr&quot; &quot;betas&quot; &quot;BMSY_B0bias&quot; &quot;Brefbias&quot; ## [6] &quot;CAA_ESS&quot; &quot;CAA_nsamp&quot; &quot;CAL_ESS&quot; &quot;CAL_nsamp&quot; &quot;Cbias&quot; ## [11] &quot;Crefbias&quot; &quot;Csd&quot; &quot;Dbias&quot; &quot;Derr&quot; &quot;FMSY_Mbias&quot; ## [16] &quot;hbias&quot; &quot;Irefbias&quot; &quot;Isd&quot; &quot;Kbias&quot; &quot;lenMbias&quot; ## [21] &quot;LFCbias&quot; &quot;LFSbias&quot; &quot;Linfbias&quot; &quot;Mbias&quot; &quot;Recsd&quot; ## [26] &quot;t0bias&quot; The Obs data frame also has 200 rows, each corresponding to a single simulation. More information on the MSE@Obs slot can be found in the help documentation: class?MSE The information contained in the OM and Obs slots can be used to examine the sensitivity of the performance of Management Procedures with respect to different operating model and observation parameters. This is discussed in more detail below. 14.4 The B_BMSY and F_FMSY Slots The B_BMSY and F_FMSY are data frames containing the biomass relative to biomass at maximum sustainable yield \\(\\left(\\frac{B}{B_{MSY}}\\right)\\), and fishing mortality relative to the rate corresponding to maximum sustainable yield \\(\\left(\\frac{F}{F_{MSY}}\\right)\\) for each simulation, Management Procedure and projection year. If we look at the class of the B_BMSY slot, we see that it is an array: class(BSharkMSE@B_BMSY) ## [1] &quot;array&quot; Using the dim function we can see that it is a 3-dimensional array, with the size corresponding to the number of simulations (nsim), the number of Management Procedures (nMPs), and the number of projection years (proyears): dim(BSharkMSE@B_BMSY) ## [1] 200 5 50 This information can be used to calculate statistics relating to the performance of each Management Procedure with respect to these metrics. For example, if you wish to look at the distribution of \\(\\frac{B}{B_{MSY}}\\) for the second Management Procedure (DCAC), you could use the boxplot function: boxplot(BSharkMSE@B_BMSY[,2,], xlab=&quot;Year&quot;, ylab=&quot;B/BMSY&quot;) This plot shows that the relative biomass for the stock generally increases through the projection period when the DCAC method is used, with the median relative biomass increasing from about 0.98 in the first year to 0.93 in the final year. However, the distribution appears to have quite high variability, which suggests that although the method works well on average, the final biomass was very low in some simulations. 14.5 The B, FM, C and TAC Slots The B, FM, and C slots contain the information relating to the stock biomass, the fishing mortality rate, and the catch for each simulation, Management Procedure, and projection year. Typically, the MSE model in the DLMtool does not include information on the absolute scale of the stock biomass or recruitment, and all results usually must be interpreted in a relativistic context. This is particularly true for the biomass (B) and catch (C) where the absolute values in the MSE results (other than 0!) have little meaning. The biomass can by made relative to \\(B_{MSY}\\), as shown above. Alternatively, biomass can be calculated with respect to the unfished biomass \\(\\left(B_0\\right)\\), from information stored in the OM slot. The catch information is usually made relative to the highest long-term yield (mean over last five years of projection) for each simulation obtained from a fixed F strategy. This information (RefY) can be found in the OM slot. Alternatively, the catch can be made relative to the catch in last historical year (CB_hist; see below), to see how future catches are expected to change relative to the current conditions. The TAC slot contains the TAC recommendation for each simulation, MP, and projection year. In cases where a TAC was not set (e.g for a size limit), the value will be NA. The values in TAC may be different to those in the catch (C) slot due to implementation error of the total catch limit. 14.6 The SSB_hist, CB_hist, and FM_hist Slots The SSB_hist, CB_hist, and FM_hist slots contain information on the spawning stock biomass, the catch biomass, and the fishing mortality from the historical period (the nyears in the operating model). These data frames differ from the previously discussed slots as they are 4-dimensional arrays, with dimensions corresponding to the simulation, the age classes, the historical year, and the spatial areas. The apply function can be used to aggregate these data over the age-classes or spatial areas. 14.7 The Effort Slot The Effort slot is a 3-dimensional array containing information on the relative fishing effort (relative to last historical year, or current conditions) for each simulation, Management Procedure and projection year. We can look at the distribution of fishing effort for each Management Procedure in the final year of the projection period: pyear &lt;- BSharkMSE@proyears boxplot(BSharkMSE@Effort[,, pyear], outline=FALSE, names=BSharkMSE@MPs, ylab=&quot;Relative fishing effort&quot;) This plot shows that the median fishing effort in the final year ranges from 0.77 to 1.81 for the first four output control methods, and is constant for the input control method (matlenlim). This is because the output control method adjusts the total allowable catch, which depending on the amount of available stock, also impacts the amount of fishing activity. The input control methods assume that fishing effort is held at constant levels in the future, although the catchability is able to randomly or systematically vary between years. Furthermore, input control methods can also adjust the amount of fishing effort in each year. "],
["performance-metrics.html", "Chapter 15 Performance Metrics 15.1 The Need for Performance Metrics 15.2 Inevitable Trade-Offs 15.3 Commonly used Performance Metrics 15.4 Performance Metrics Methods 15.5 Summarizing Management Procedure Performance", " Chapter 15 Performance Metrics A key use of the DLMtool is to evaluate the trade-offs in the performance of different potential Management Procedures and to assist in the decision-making process as to which Management Procedure is most likely to satisfy the various management objectives under realistic range of uncertainty and variability in the system. 15.1 The Need for Performance Metrics In order to evaluate the relative effectiveness of different Management Procedures, it is important that decision-makers have clearly-defined management objectives. These management objectives can be incorporated into the MSE process in the form of performance metrics, which provide the yardstick with which to compare the relative performance of different management strategies. Fisheries managers are confronted with the difficult task of maximizing yield and ensuring the sustainability of the resource and the overall health of the marine environment. The principal objectives of fisheries management could be described as ensuring sustainable harvests and viable fishing communities, while maintaining healthy ecosystems. However, this simplistic view overlooks the fact that there are often conflicts in different management objectives and that there is rarely an optimal management approach that fully satisfies all management objectives (Punt, 2015). Walters and Martell (2004) explain that the task of modern fisheries management is to identify the various trade-offs among conflicting objectives and decide how to balance them in a satisfactory way. 15.2 Inevitable Trade-Offs A typical trade-off is the abundance of the target species versus the catch. Assuming no significant system-wide natural perturbations, a fish stock may be exploited sustainability if catches are set at low levels. However, such economic under-utilization of the resource is often seen as undesirable. Alternatively, high catches may produce immediate short-term benefits, but may result in long-term degradation, or perhaps collapse, of the stock. Additionally, there is often a trade-off between stock size and fishing effort, which results in lower catch rates (and lower profit) for individual fishers when a large number of fishers are active in the fishery (Walters and Martell, 2004). Other common trade-offs include the age and size at first capture, either delaying harvest until individuals are fewer in number (due to natural mortality) but larger in size, or capturing a large number of small sized fish (Punt, 2015). When multiple objectives are considered, there is usually not a single optimum solution, and fisheries managers are faced with the difficult task of determining the most appropriate management action that satisfies the numerous management objectives and stakeholder interests (Punt, 2015). 15.2.1 Operational Management Objectives A key strength of the MSE approach is that decision-makers are required to specify clear objectives, which can be classified as either “conceptual” or “operational” (Punt et al., 2014). Conceptual objectives are typically high-level policy goals that may be broadly defined. However, in order to be included in an MSE, conceptual objectives must be translated into operational objectives (i.e., expressed as values for performance metrics). Such operational objectives, or performance metrics, may consist of both a reference point (e.g., biomass some fraction of equilibrium unfished level) as well as a measure of the acceptable associated risk (e.g., less than 10% chance that biomass declines below this reference level). It is not unusual that some of the management objectives are in conflict. A key benefit of the MSE approach is to highlight these trade-offs among the different management objectives to guide the decision-making process. However, in order for these trade-offs to be quantified, it is critically important that the performance metrics are quantifiable and thus able to be incorporated into the MSE framework (Punt, 2015). 15.3 Commonly used Performance Metrics Management strategy evaluation is a simulation exercise where the model can track the specific performance with perfect information, so it is possible to state performance objectives in specific terms that are consistent with the typical objectives of fisheries policies, such as: Biomass relative to unfished biomass \\(\\left(B_0\\right)\\) or biomass at maximum sustainable yield \\(\\left(B_{MSY}\\right)\\). Fishing mortality rate relative to fishing at maximum sustainable yield \\(\\left(F_{MSY}\\right)\\). Yield (short-term or long-term) of a particular management strategy relative to the yield if the fishery were being exploited at \\(F_{MSY}\\). Inter-annual variability in yield or effort (e.g., fluctuations in yield from year to year). Because the management strategy evaluation runs many simulations of the fisheries performance under each management strategy being tested, the performance can be stated probabilistically, such as the specific probability of biomass being above or below a specific biomass threshold or target. 15.3.1 Fishing Mortality For example, the management strategies can be ranked by the likelihood of overfishing to occur, where the probability of overfishing is measured by the proportion of simulation runs where the fishing mortality rate (F) under a specific management strategy is higher than the F that is expected to produce the maximum sustainable yield. Management strategies that have a lower probability of overfishing occurring are typically preferable to those that frequently cause excessive fishing mortality rates. If there are 1,000 simulation runs for each management strategy over a 50-year projection period, then the probability of overfishing could be based on the proportion where F is greater than (or less than) \\(F_{MSY}\\) over all years or any subset of years (e.g., probability of overfishing in years 41-50 of the 50-year projection period). 15.3.2 Stock Biomass Another common performance metric is the probability that the stock biomass is above or below some biological reference point. For example, a minimum performance limit may be half the biomass at maximum sustainable yield (0.5 BMSY), and the performance of the management strategies can be ranked by the probability of the stock remaining above this level. Management strategies that fail to maintain biomass above this limit with a high priority may be considered too risky and therefore excluded from further examination. 15.3.3 Additional Performance Metrics There may be other performance metrics that are of interest to fishery managers and stakeholders. Stakeholder participation is critical when developing performance metrics to evaluate different biological scenarios or management strategies in a MSE. Furthermore, it is important that the performance metrics, together with any acceptable risk thresholds are identified and agreed upon before the MSE is conducted. 15.4 Performance Metrics Methods DLMtool includes a set of functions, of class PM, for calculating Performance Metrics. The available PM functions (referred to as PMs) can be found using the avail function: avail(&quot;PM&quot;) ## [1] &quot;AAVY&quot; &quot;LTY&quot; &quot;P10&quot; &quot;P100&quot; &quot;P50&quot; &quot;PNOF&quot; &quot;STY&quot; &quot;Yield&quot; The PMs are used for summarizing the performance of the management procedures and plotting the results in trade-off plots. Here we briefly describe the built-in Performance Metrics functions and demonstrate their use. Advanced DLMtool users can develop their own PM methods, see the Custom Performance Metrics chapter for details. Functions of class PM are used on an object of class MSE (i.e the object returned by runMSE), and return an object of class PMobj. Most of the time the PM functions are used internally in the summary or plotting functions, and it will not be neccessary to acess the PMobj directly. To demonstrate the PM functions we first run a quick example MSE: MSE &lt;- runMSE() 15.4.1 Overview of the PM Functions We will use the P50 function to demonstrate the PM methods. Help documentation on the PM methods can be accessed in the usual way: ?P50. The P50 PM method calculates the probability that spawning biomass is above half of the spawning biomass that results in maximum sustainable yield \\(\\left(\\text{SB} &gt; 0.5\\text{SB}_\\text{MSY}\\right)\\). Applying the P50 function to our MSE object results in the following output: P50(MSE) ## Spawning Biomass relative to SBMSY ## Prob. SB &gt; 0.5 SBMSY (Years 1 - 50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 1 1 1 1 1 ## 2 1 0.88 1 1 1 1 ## 3 0.04 0.06 0.96 0.24 1 0.78 ## 4 1 0.9 0.96 1 1 1 ## 5 1 0.98 1 1 1 1 ## 6 1 1 1 1 1 1 ## 7 1 0.54 1 1 1 1 ## 8 0.38 0.36 1 1 1 1 ## 9 0.42 0.58 1 0.42 1 0.6 ## 10 1 1 1 0.96 1 1 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 0.44 0.42 0.96 1 1 1 ## ## Mean ## [1] 0.75 0.73 0.98 0.88 0.99 0.92 We can see that the PM function calculated, for the 6 MPs in the MSE object, the probability \\(\\text{SB} &gt; 0.5\\text{SB}_\\text{MSY}\\) for all 50 projection years. The PM function prints out a summary table of the performance metrics statistics for the first 10 simulations and the last simulation (48 in this case) for each MP. The final line shows the overall probability of the performance metric, i.e the average performance across all simulations. We will look into this output in a little more detail. We can see that the first MP is AvC and the performance statistics for the first and second simulations are 1 and 1. How have these values been calculated and what do they mean? Let’s first plot the spawning biomass relative to BMSY for the first two simulations of the AvC MP: par(mfrow=c(1,2)) plot(1:MSE@proyears, MSE@B_BMSY[1,1,], type=&#39;l&#39;, xlab=&quot;Years&quot;, ylab=&quot;B/BMSY&quot;, lwd=2, bty=&quot;l&quot;, ylim=c(0,2), main=&quot;MP = &#39;AvC&#39;; Sim = 1&quot;) abline(h=0.5, lty=3) plot(1:MSE@proyears, MSE@B_BMSY[2,1,], type=&#39;l&#39;, xlab=&quot;Years&quot;, ylab=&#39;&#39;, lwd=2, bty=&quot;l&quot;, ylim=c(0,2), main=&quot;MP = &#39;AvC&#39;; Sim = 2&quot;) abline(h=0.5, lty=3) Now we will calculate fraction of years where spawning biomass is above 0.5 \\(\\text{SB}_\\text{MSY}\\) for the first and second simulations: mean(MSE@B_BMSY[1,1,] &gt; 0.5) # first simulation ## [1] 1 mean(MSE@B_BMSY[2,1,] &gt; 0.5) # second simulation ## [1] 1 # identical to: # sum(MSE@B_BMSY[1,1,] &gt; 0.5)/MSE@proyears # sum(MSE@B_BMSY[2,1,] &gt; 0.5)/MSE@proyears Notice how the performance statistics for each simulation correspond with the plot shown above? The overall performance is then calculated by the probability over all simulations, i.e for the first MP AvC: mean(MSE@B_BMSY[,1,]&gt;0.5) ## [1] 0.7475 And for 6 MPs: round(apply(MSE@B_BMSY &gt;0.5, 2, mean),2) ## [1] 0.75 0.73 0.98 0.88 0.99 0.92 which, reassuringly, is the same as the output of the P50 function. 15.4.2 Customizing the PM Functions The PM functions allow for very quick calculation of performance metrics. For example, suppose that instead of calculating performance over all projection years, we are only interested in the long-term performance, say over the last 10 years. This can be easily achieved using the Yrs argument in the PM function: P50(MSE, Yrs=c(41,50)) ## Spawning Biomass relative to SBMSY ## Prob. SB &gt; 0.5 SBMSY (Years 41 - 50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 1 1 1 1 1 ## 2 1 0.4 1 1 1 1 ## 3 0 0 1 0 1 0.8 ## 4 1 0.5 0.9 1 1 1 ## 5 1 0.9 1 1 1 1 ## 6 1 1 1 1 1 1 ## 7 1 0 1 1 1 1 ## 8 0 0 1 1 1 1 ## 9 0 0 1 0 1 0.2 ## 10 1 1 1 0.9 1 1 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 0 0 1 1 1 1 ## ## Mean ## [1] 0.66 0.48 0.98 0.82 0.99 0.88 Or the first 10 years: P50(MSE, Yrs=c(1,10)) ## Spawning Biomass relative to SBMSY ## Prob. SB &gt; 0.5 SBMSY (Years 1 - 10) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 1 1 1 1 1 ## 2 1 1 1 1 1 1 ## 3 0.2 0.3 0.8 0.3 1 0.7 ## 4 1 1 1 1 1 1 ## 5 1 1 1 1 1 1 ## 6 1 1 1 1 1 1 ## 7 1 1 1 1 1 1 ## 8 1 1 1 1 1 1 ## 9 1 1 1 1 1 1 ## 10 1 1 1 1 1 1 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 1 1 1 1 1 1 ## ## Mean ## [1] 0.91 0.95 0.98 0.91 0.99 0.95 The other biomass Performance Metric functions work in the same way: P10(MSE) # probability SB &gt; 0.1SB_MSY for all years ## Spawning Biomass relative to SBMSY ## Prob. SB &gt; 0.1 SBMSY (Years 1 - 50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 1 1 1 1 1 ## 2 1 1 1 1 1 1 ## 3 0.22 0.34 1 1 1 1 ## 4 1 0.98 1 1 1 1 ## 5 1 1 1 1 1 1 ## 6 1 1 1 1 1 1 ## 7 1 0.64 1 1 1 1 ## 8 0.58 0.52 1 1 1 1 ## 9 0.58 0.72 1 1 1 1 ## 10 1 1 1 1 1 1 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 0.56 0.5 1 1 1 1 ## ## Mean ## [1] 0.81 0.82 1.00 0.99 1.00 1.00 P100(MSE) # probability SB &gt; SB_MSY for all years ## Spawning Biomass relative to SBMSY ## Prob. SB &gt; SBMSY (Years 1 - 50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 0.88 0.5 1 1 1 ## 2 1 0.8 0.5 1 1 1 ## 3 0 0 0.4 0 0.94 0 ## 4 1 0.82 0.42 0.86 1 0.86 ## 5 0.84 0.78 0.6 0.86 0.9 0.88 ## 6 1 1 0.42 1 1 1 ## 7 0.96 0.4 0.36 1 1 1 ## 8 0.22 0.24 0.74 0.98 1 1 ## 9 0 0.38 0.34 0 0.96 0 ## 10 0.96 0.98 0.66 0.16 0.7 0.34 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 0.26 0.28 0.44 0.9 0.96 0.92 ## ## Mean ## [1] 0.66 0.63 0.41 0.67 0.94 0.71 Long-term, short-term and overall average yield are calculated using LTY, STY and Yield respectively: LTY(MSE) ## Average Yield relative to Reference Yield (Years 41-50) ## Prob. Yield &gt; 0.5 Ref. Yield (Years 41-50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 1 1 1 0.5 1 ## 2 1 1 1 0.2 0 0.2 ## 3 0 0 1 0.9 0.7 1 ## 4 1 1 1 1 0.2 1 ## 5 1 1 1 1 1 1 ## 6 0 1 1 1 0.9 1 ## 7 1 0 1 0.8 0 0.8 ## 8 0 0 1 1 1 1 ## 9 0 0 1 1 0.2 1 ## 10 1 1 1 1 1 1 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 0 0 1 0.8 0.3 0.8 ## ## Mean ## [1] 0.54 0.61 0.99 0.77 0.59 0.79 STY(MSE) ## Average Yield relative to Reference Yield (Years 1-10) ## Prob. Yield &gt; 0.5 Ref. Yield (Years 1-10) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 1 1 0.7 0 0.7 ## 2 1 1 1 1 0 1 ## 3 1 1 1 1 0 1 ## 4 1 1 1 1 0 1 ## 5 1 1 1 0.9 0.7 0.8 ## 6 0 0 1 1 0.5 1 ## 7 1 1 1 1 0 1 ## 8 1 1 1 1 0.8 1 ## 9 1 1 1 1 0 1 ## 10 1 1 1 1 1 1 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 1 1 1 1 0.6 1 ## ## Mean ## [1] 0.86 0.81 0.99 0.87 0.43 0.86 Yield(MSE) ## Yield relative to Reference Yield (Years 1-50) ## Mean Relative Yield (Years 1-50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 0.68 0.89 1.03 0.79 0.33 0.77 ## 2 0.76 0.93 1.1 0.63 0.3 0.62 ## 3 0.35 0.47 1.16 1.02 0.55 1 ## 4 0.76 1 1.06 1.01 0.4 0.97 ## 5 0.97 1.1 1.27 1.15 0.97 1.12 ## 6 0.46 0.66 0.88 0.71 0.57 0.68 ## 7 0.71 0.56 0.8 0.64 0.12 0.63 ## 8 0.73 0.68 1.11 1.04 0.86 1 ## 9 0.64 0.76 0.91 0.83 0.38 0.82 ## 10 0.98 0.91 1.25 1.25 1.38 1.2 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 0.65 0.62 0.98 0.8 0.53 0.77 ## ## Mean ## [1] 0.62 0.73 1.02 0.82 0.61 0.81 The PNOF PM function calculates the probability of not overfishing: PNOF(MSE) ## Probability of not overfishing (F&lt;FMSY) ## Prob. F &lt; FMSY (Years 1 - 50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 0.84 0.32 1 1 1 ## 2 1 0.8 0.3 1 1 1 ## 3 0 0 0.36 0.04 0.08 0.12 ## 4 1 0.74 0.36 0.92 0.94 0.96 ## 5 0.9 0.8 0.38 0.94 0.92 0.96 ## 6 1 1 0.38 1 1 1 ## 7 1 0.32 0.48 1 1 1 ## 8 0.18 0.2 0.3 0.86 0.88 0.92 ## 9 0 0.44 0.44 0.04 0.06 0.08 ## 10 1 1 0.36 0.2 0.2 0.32 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 0.12 0.3 0.4 0.92 0.94 0.94 ## ## Mean ## [1] 0.67 0.62 0.37 0.71 0.72 0.76 Finally, the average annual variability in yield (AAVY) can be calculated with the AAVY function: AAVY(MSE) ## Average Annual Variability in Yield (Years 1-50) ## Prob. AAVY &lt; 20% (Years 1-50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 1 1 0 0 0 ## 2 1 1 1 1 1 1 ## 3 1 1 1 0 0 0 ## 4 1 1 1 1 1 1 ## 5 1 1 1 0 0 0 ## 6 1 1 1 0 0 0 ## 7 1 1 1 0 0 0 ## 8 1 1 1 0 0 0 ## 9 1 1 1 0 0 0 ## 10 1 1 1 0 0 0 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 1 1 1 0 0 0 ## ## Mean ## [1] 0.94 0.96 1.00 0.21 0.27 0.23 By default the AAVY PM function calculates the probability that AAVY is less than 20%. This reference level can easily be modified using the Ref argument: AAVY(MSE, Ref=0.15) # prob. AAVY &lt; 15% ## Average Annual Variability in Yield (Years 1-50) ## Prob. AAVY &lt; 15% (Years 1-50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 1 1 0 0 0 ## 2 1 1 1 0 0 0 ## 3 0 1 1 0 0 0 ## 4 1 1 1 0 0 0 ## 5 1 1 1 0 0 0 ## 6 1 1 1 0 0 0 ## 7 1 1 1 0 0 0 ## 8 1 1 1 0 0 0 ## 9 1 1 1 0 0 0 ## 10 1 1 1 0 0 0 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 1 1 1 0 0 0 ## ## Mean ## [1] 0.88 0.90 1.00 0.02 0.04 0.02 AAVY(MSE, Ref=0.30) # prob. AAVY &lt; 30% ## Average Annual Variability in Yield (Years 1-50) ## Prob. AAVY &lt; 30% (Years 1-50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 1 1 1 1 1 ## 2 1 1 1 1 1 1 ## 3 1 1 1 0 0 1 ## 4 1 1 1 1 1 1 ## 5 1 1 1 0 0 0 ## 6 1 1 1 1 1 1 ## 7 1 1 1 1 1 1 ## 8 1 1 1 0 0 0 ## 9 1 1 1 1 1 1 ## 10 1 1 1 1 1 1 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 1 1 1 1 1 1 ## ## Mean ## [1] 1.00 1.00 1.00 0.79 0.79 0.81 The other PM functions also have the Ref argument which can be used in the same way. For example, you may notice that the P50 and P100 functions are identical except for the value of the Ref argument: args(P50) ## function (MSEobj = NULL, Ref = 0.5, Yrs = NULL) ## NULL args(P100) ## function (MSEobj = NULL, Ref = 1, Yrs = NULL) ## NULL It follows then that it is very simple to calculate a custom performance metric based on the built-in PM functions. For example, suppose we wanted to calculate the probability that spawning biomass was above 5% of BMSY. This can be achieved by using any of the biomass-based PM functions and modifying the Ref argument: P50(MSE, Ref=0.05) ## Spawning Biomass relative to SBMSY ## Prob. SB &gt; 0.05 SBMSY (Years 1 - 50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 1 1 1 1 1 ## 2 1 1 1 1 1 1 ## 3 0.32 0.4 1 1 1 1 ## 4 1 1 1 1 1 1 ## 5 1 1 1 1 1 1 ## 6 1 1 1 1 1 1 ## 7 1 0.68 1 1 1 1 ## 8 0.74 0.72 1 1 1 1 ## 9 0.62 0.78 1 1 1 1 ## 10 1 1 1 1 1 1 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 0.64 0.6 1 1 1 1 ## ## Mean ## [1] 0.83 0.85 1.00 0.99 1.00 1.00 P100(MSE, Ref=0.05) ## Spawning Biomass relative to SBMSY ## Prob. SB &gt; 0.05 SBMSY (Years 1 - 50) ## AvC DCAC FMSYref curE matlenlim MRreal ## 1 1 1 1 1 1 1 ## 2 1 1 1 1 1 1 ## 3 0.32 0.4 1 1 1 1 ## 4 1 1 1 1 1 1 ## 5 1 1 1 1 1 1 ## 6 1 1 1 1 1 1 ## 7 1 0.68 1 1 1 1 ## 8 0.74 0.72 1 1 1 1 ## 9 0.62 0.78 1 1 1 1 ## 10 1 1 1 1 1 1 ## 11 . . . . . . ## 12 . . . . . . ## 13 . . . . . . ## 48 0.64 0.6 1 1 1 1 ## ## Mean ## [1] 0.83 0.85 1.00 0.99 1.00 1.00 More information on customizing PM functions can be found in the Custom Performance Metrics chapter. In the next section we will demonstrate using PM functions in summarizing and plotting functions. 15.5 Summarizing Management Procedure Performance The Examining the MSE Results chapter introduced the summary function for MSE objects and some of the plotting functions for visualizing the results. Here we demonstrate how the PM functions can be used in the summary function and the trade-off plots: 15.5.1 summary Table The summary function provides information on the performance of the Management Procedures with respect to the performance metrics. By default, summary includes the PNOF, P50, AAVY and LTY performance metrics: summary(MSE) ## Calculating Performance Metrics ## Performance.Metrics ## 1 Probability of not overfishing (F&lt;FMSY) ## 2 Spawning Biomass relative to SBMSY ## 3 Average Annual Variability in Yield (Years 1-50) ## 4 Average Yield relative to Reference Yield (Years 41-50) ## ## 1 Prob. F &lt; FMSY (Years 1 - 50) ## 2 Prob. SB &gt; 0.5 SBMSY (Years 1 - 50) ## 3 Prob. AAVY &lt; 20% (Years 1-50) ## 4 Prob. Yield &gt; 0.5 Ref. Yield (Years 41-50) ## ## ## Probability: ## MP PNOF P50 AAVY LTY ## 1 AvC 0.67 0.75 0.94 0.54 ## 2 DCAC 0.62 0.73 0.96 0.61 ## 3 FMSYref 0.37 0.98 1.00 0.99 ## 4 curE 0.71 0.88 0.21 0.77 ## 5 matlenlim 0.72 0.99 0.27 0.59 ## 6 MRreal 0.76 0.92 0.23 0.79 It is straightforward to include other PM functions by adding the names of the PM functions, for example: summary(MSE, &#39;P100&#39;, &#39;Yield&#39;) ## Calculating Performance Metrics ## Performance.Metrics ## 1 Spawning Biomass relative to SBMSY ## 2 Yield relative to Reference Yield (Years 1-50) ## ## 1 Prob. SB &gt; SBMSY (Years 1 - 50) ## 2 Mean Relative Yield (Years 1-50) ## ## ## Probability: ## MP P100 Yield ## 1 AvC 0.66 0.62 ## 2 DCAC 0.63 0.73 ## 3 FMSYref 0.41 1.00 ## 4 curE 0.67 0.82 ## 5 matlenlim 0.94 0.61 ## 6 MRreal 0.71 0.81 or all available PM functions: summary(MSE, avail(&#39;PM&#39;)) ## Calculating Performance Metrics ## Performance.Metrics ## 1 Average Annual Variability in Yield (Years 1-50) ## 2 Average Yield relative to Reference Yield (Years 41-50) ## 3 Spawning Biomass relative to SBMSY ## 4 Spawning Biomass relative to SBMSY ## 5 Spawning Biomass relative to SBMSY ## 6 Probability of not overfishing (F&lt;FMSY) ## 7 Average Yield relative to Reference Yield (Years 1-10) ## 8 Yield relative to Reference Yield (Years 1-50) ## ## 1 Prob. AAVY &lt; 20% (Years 1-50) ## 2 Prob. Yield &gt; 0.5 Ref. Yield (Years 41-50) ## 3 Prob. SB &gt; 0.1 SBMSY (Years 1 - 50) ## 4 Prob. SB &gt; SBMSY (Years 1 - 50) ## 5 Prob. SB &gt; 0.5 SBMSY (Years 1 - 50) ## 6 Prob. F &lt; FMSY (Years 1 - 50) ## 7 Prob. Yield &gt; 0.5 Ref. Yield (Years 1-10) ## 8 Mean Relative Yield (Years 1-50) ## ## ## Probability: ## MP AAVY LTY P10 P100 P50 PNOF STY Yield ## 1 AvC 0.94 0.54 0.81 0.66 0.75 0.67 0.86 0.62 ## 2 DCAC 0.96 0.61 0.82 0.63 0.73 0.62 0.81 0.73 ## 3 FMSYref 1.00 0.99 1.00 0.41 0.98 0.37 0.99 1.00 ## 4 curE 0.21 0.77 0.99 0.67 0.88 0.71 0.87 0.82 ## 5 matlenlim 0.27 0.59 1.00 0.94 0.99 0.72 0.43 0.61 ## 6 MRreal 0.23 0.79 1.00 0.71 0.92 0.76 0.86 0.81 The summary function returns a data frame which can be useful for referring to the PM results elsewhere in the analysis. For example, Results &lt;- summary(MSE, avail(&#39;PM&#39;), silent=TRUE) # silent=TRUE to hide print-out to console Results$Yield # access the PM results ## [1] 0.62 0.73 1.00 0.82 0.61 0.81 15.5.2 Trade-Off Plots The TradePlot function takes an object of class MSE and the names of PM functions (at least 2) to produce a trade-off plot. For example: TradePlot(MSE) # default plot ## MP STY LTY P10 AAVY Satisificed ## 1 AvC 0.86 0.54 0.81 0.94 TRUE ## 2 DCAC 0.81 0.61 0.82 0.96 TRUE ## 3 FMSYref 0.99 0.99 1.00 1.00 TRUE ## 4 curE 0.87 0.77 0.99 0.21 FALSE ## 5 matlenlim 0.43 0.59 1.00 0.27 FALSE ## 6 MRreal 0.86 0.79 1.00 0.23 FALSE The order of the PM function names determines plotting on the x and y axes. For example: TradePlot(MSE, &#39;P50&#39; ,&#39;LTY&#39;) # x = P50, y = LTY ## MP P50 LTY Satisificed ## 1 AvC 0.75 0.54 TRUE ## 2 DCAC 0.73 0.61 TRUE ## 3 FMSYref 0.98 0.99 TRUE ## 4 curE 0.88 0.77 TRUE ## 5 matlenlim 0.99 0.59 TRUE ## 6 MRreal 0.92 0.79 TRUE TradePlot(MSE, &#39;LTY&#39; ,&#39;P50&#39;) # x = LTY, y = P50 ## MP LTY P50 Satisificed ## 1 AvC 0.54 0.75 TRUE ## 2 DCAC 0.61 0.73 TRUE ## 3 FMSYref 0.99 0.98 TRUE ## 4 curE 0.77 0.88 TRUE ## 5 matlenlim 0.59 0.99 TRUE ## 6 MRreal 0.79 0.92 TRUE The PMs are recycled if an odd number are provided: TradePlot(MSE, &#39;P50&#39; ,&#39;LTY&#39;, &#39;STY&#39;) ## Odd number of PMs. Recycling first PM ## MP P50 LTY STY Satisificed ## 1 AvC 0.75 0.54 0.86 TRUE ## 2 DCAC 0.73 0.61 0.81 TRUE ## 3 FMSYref 0.98 0.99 0.99 TRUE ## 4 curE 0.88 0.77 0.87 TRUE ## 5 matlenlim 0.99 0.59 0.43 FALSE ## 6 MRreal 0.92 0.79 0.86 TRUE The Lims argument is used to set the vertical and horizontal acceptable risk thresholds and are interpreted in the same order as the names of the PM functions. For example: TradePlot(MSE, &#39;P50&#39; ,&#39;LTY&#39;, Lims=c(0.8, 0)) # 80% minimum acceptable risk for P50, no minimum for LTY ## MP P50 LTY Satisificed ## 1 AvC 0.75 0.54 FALSE ## 2 DCAC 0.73 0.61 FALSE ## 3 FMSYref 0.98 0.99 TRUE ## 4 curE 0.88 0.77 TRUE ## 5 matlenlim 0.99 0.59 TRUE ## 6 MRreal 0.92 0.79 TRUE TradePlot(MSE, &#39;P50&#39; ,&#39;STY&#39;, &#39;P100&#39;, &#39;LTY&#39;, Lims=c(0.8, 0, 0.5, 0)) # 80% minimum acceptable risk for P50, 50% for P100, no minimum for STY and LTY ## MP P50 STY P100 LTY Satisificed ## 1 AvC 0.75 0.86 0.66 0.54 FALSE ## 2 DCAC 0.73 0.81 0.63 0.61 FALSE ## 3 FMSYref 0.98 0.99 0.41 0.99 FALSE ## 4 curE 0.88 0.87 0.67 0.77 TRUE ## 5 matlenlim 0.99 0.43 0.94 0.59 TRUE ## 6 MRreal 0.92 0.86 0.71 0.79 TRUE The TradePlot function returns a data frame with the results of the performance metrics, and a column indicating if an MP has met minimum performance criteria for all performance metrics. In the previous example, 3 MPs (curE, matlenlim, MRreal) met the minimum performance criteria for all four performance metrics. The TradePlot function can be used to make a variety of custom trade-off plots. For example, the Tplot, Tplot2, and Tplot3 functions all use this function to produce different trade-off plots: Tplot ## function(MSEobj, Lims=c(0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5), ...) { ## if (class(Lims)!=&quot;numeric&quot;) stop(&quot;Second argument must be numeric&quot;) ## TradePlot(MSEobj, Lims=Lims, PMlist=list(&quot;PNOF&quot;, &quot;LTY&quot;, &quot;P100&quot;, &quot;LTY&quot;, &quot;P50&quot;, &quot;LTY&quot;, &quot;P10&quot;, &quot;LTY&quot;), ...) ## } ## &lt;bytecode: 0x0000000019b43ef0&gt; ## &lt;environment: namespace:DLMtool&gt; Tplot(MSE) ## MP PNOF LTY P100 P50 P10 Satisificed ## 1 AvC 0.67 0.54 0.66 0.75 0.81 TRUE ## 2 DCAC 0.62 0.61 0.63 0.73 0.82 TRUE ## 3 FMSYref 0.37 0.99 0.41 0.98 1.00 FALSE ## 4 curE 0.71 0.77 0.67 0.88 0.99 TRUE ## 5 matlenlim 0.72 0.59 0.94 0.99 1.00 TRUE ## 6 MRreal 0.76 0.79 0.71 0.92 1.00 TRUE Similarly, we can easily reproduce NOAA_plot using the Tradeplot function: NOAA_plot(MSE) ## PNOF B50 LTY VY ## AvC 66.7 74.8 54.2 87.5 ## DCAC 62.2 73.2 58.3 89.6 ## FMSYref 59.8 98.5 100.0 100.0 ## curE 70.9 87.6 75.4 2.1 ## matlenlim 71.8 99.3 60.4 4.2 ## MRreal 75.8 92.0 78.3 2.1 TradePlot(MSE, Lims=c(0.5, 0, 0.8, 0.5), PMlist=list(&quot;PNOF&quot;, &quot;LTY&quot;, &quot;P50&quot;, &quot;AAVY&quot;), Refs=list(AAVY=0.15)) ## MP PNOF LTY P50 AAVY Satisificed ## 1 AvC 0.67 0.54 0.75 0.880 FALSE ## 2 DCAC 0.62 0.61 0.73 0.900 FALSE ## 3 FMSYref 0.37 0.99 0.98 1.000 FALSE ## 4 curE 0.71 0.77 0.88 0.021 FALSE ## 5 matlenlim 0.72 0.59 0.99 0.042 FALSE ## 6 MRreal 0.76 0.79 0.92 0.021 FALSE See the Plotting MSE Results section for examples on DLMtool plotting functions for the MSE object. Advanced users may wish to develop their own plotting and summary functions. See the Custom Performance Metrics section for more details on this. "],
["value-of-information.html", "Chapter 16 Value of Information", " Chapter 16 Value of Information The Value of Information (VOI) functions have been designed to explore the sensitivity of the performance of the Management Procedures to variability in the observation processes and operating model parameters. There are several VOI functions in DLMtool. The VOI function generates two plots, one corresponding to the operating model parameters, and the other to the observation model parameters, showing the gradient in long-term yield with respect to the individual parameters: VOI(MSE) ## [[1]] ## MP 1 2 3 4 5 6 ## 1 AvC Asp SSBMSY M LenCV L5 FMSY_M ## 2 21.01 20.91 20.56 20.41 19.43 17.77 ## 3 DCAC LenCV L5 Vmaxlen M BMSY_B0 Asp ## 4 29.35 28.68 25.97 24.84 24.73 24.54 ## 5 FMSYref hs SSB0 LFS LenCV M Asp ## 6 4.47 4.22 3.94 3.94 3.69 3.62 ## 7 curE AC K SSB0 qinc procmu procsd ## 8 16.84 16.64 15.03 15 14.6 14.6 ## 9 matlenlim qinc SSBMSY MGT maxlen D K ## 10 22.98 20.99 20.37 20.24 19.8 18.69 ## 11 MRreal K qinc AC D procmu procsd ## 12 15.16 15.13 14.77 13.75 12.43 12.43 ## ## [[2]] ## MP 1 2 3 4 5 6 ## 1 AvC Cbias Csd ## 2 25.22 17.03 ## 3 DCAC Cbias Csd Derr Mbias FMSY_Mbias Dbias ## 4 38.27 23.16 21.37 18.39 14.59 12.7 ## 5 FMSYref &lt;NA&gt; ## 6 &lt;NA&gt; ## 7 curE &lt;NA&gt; ## 8 &lt;NA&gt; ## 9 matlenlim lenMbias ## 10 19.65 ## 11 MRreal &lt;NA&gt; ## 12 &lt;NA&gt; The VOIplot function shows something similar, but has an argument to specify either the Observation or Operating Model parameters: # Observation Parameters VOIplot(MSE, nMP=5) # OM Parameters VOIplot(MSE, Par=&quot;OM&quot;, nMP=5) By default, the VOIplot function only shows the four Management Procedures with the greatest sensitivity. Here we’ve made it show all five methods using the nMP argument. In this example we can see that the Fratio method is particularly sensitive to bias in the current estimate of abundance, and over-estimates of the current abundance result in very low long-term yield (probably do to collapse of the stock). The DCAC method appears most sensitive to bias in the estimated catch. We can also use the VOIplot function to look at the sensitivity with respect to the final biomass by specifying the YVar argument: VOIplot(MSE, Par=&quot;OM&quot;, nMP=5, YVar=&quot;B&quot;) This result shows, perhaps unsurprisingly, that the final biomass is often strongly sensitive to the initial depletion, particularly for the DCAC and matlenlim methods. The VOIplot2 function is an updated version of VOIplot that uses the PM functions and plots the Value of Information for a single MP: VOIplot2(MSE) VOIplot2(MSE, type=&quot;OM&quot;) and with a different MP and performance metric: VOIplot2(MSE, MP=&quot;DCAC&quot;, PM=&quot;P100&quot;) VOIplot2(MSE, MP=&quot;DCAC&quot;, type=&quot;OM&quot;, PM=&quot;P100&quot;) The VOI2 function relates the operating model parameters and parameters of the observation model to relative yield (yield over last 5 years of projection relative to a ‘best F’ scenario that maximizes yield. VOI2(MSE) VOI2 assumes that relative cost for each type of improvement in data is linearly related to the number of samples (e.g. nCAAobs) or square function of improved precision and bias e.g.: relative \\(\\text{cost}= \\frac{1}{(\\text{newCV}/\\text{oldCV})^2}\\) The VOI features of DLMtool are continuing to be developed and more VOI functions will be added soon. "],
["the-fishery-data-object.html", "Chapter 17 The Fishery Data Object 17.1 In the MSE 17.2 Application of Management Procedures Using Real Fisheries Data", " Chapter 17 The Fishery Data Object Data is an object class in the DLMtool that contains all of the fishery information that can be used by the Management Procedure. You find the documentation for the Data class by typing: class?Data You can see from the documentation that the Data object, or Fishery Data object, contains many slots, and a lot of information can be stored in this object, including biological parameters, fishery statistics such as time-series of catch, and past management recommendations. 17.1 In the MSE In the MSE the Fishery Data object is populated with data that is generated by the simulation model. Here the ‘true’ data generated by the model is filtered through the Observation Model (using the Observation parameters) and entered into the Fishery Data object to represent typical fisheries data. The MSE consists of many hundreds of simulations, and because the DLMtool has been designed for parallel processing, the Fishery Data object in the MSE actually consists of hundreds of ‘versions’ of the simulated fishery data. The first argument for all Management Procedure functions is x, which is the position in the Data object that refers to the data corresponding that particular iteration. In the MSE, the value of x goes from 1 to the total number of simulations (nsim). The second argument for all Management Procedures in the DLMtool is the Data object. For example, the arguments to the AvC MP are: args(AvC) ## function (x, Data, reps = 100, plot = FALSE) ## NULL The Developing Custom Management Procedures section describes the arguments and internal workings of the Management Procedure functions in more detail. 17.2 Application of Management Procedures Using Real Fisheries Data In contrast to the MSE, in the real world application of a Management Procedure, we only have one version of the fishery data: the data that has been collected from the fishery. The Fishery Data object contains all of the fishery information that can be used by a Management Procedure. By definition, many sources of data are not available in data-limited fisheries, and the Fishery Data object may not be completely populated. The DLMtool can be used to determine which of the Management Procedures in the Toolkit are available to be used given the data in the Fishery Data object, which methods cannot be used, and what data are required to make these methods available. "],
["example-data-objects.html", "Chapter 18 Example Data Objects", " Chapter 18 Example Data Objects The DLMtool package has a number of example Fishery Data objects. This can be listed using the avail function: avail(&quot;Data&quot;) ## [1] &quot;Atlantic_mackerel&quot; &quot;China_rockfish&quot; &quot;Cobia&quot; ## [4] &quot;Example_datafile&quot; &quot;Gulf_blue_tilefish&quot; &quot;ourReefFish&quot; ## [7] &quot;Red_snapper&quot; &quot;SimulatedData&quot; &quot;Simulation_1&quot; "],
["creating-your-own-data-object.html", "Chapter 19 Creating Your Own Data Object 19.1 Creating a Data File in Excel 19.2 Importing the Data object 19.3 Example Fishery Data Files 19.4 Populating a Data Object in R", " Chapter 19 Creating Your Own Data Object DLMtool has a series of functions to make importing data and applying data-limited Management Procedures relatively straightforward. There are two approaches: Fill out a .csv data file in excel or a text editor and use a DLMtool function to create a properly formatted Data object (class Data), or Create a blank Data object and populate it in R. 19.1 Creating a Data File in Excel Probably the easiest way to get your data into the DLMtool is to populate a data table in an Excel workbook. You can create a Data workbook using the DataInit function, for example: DataInit(&quot;MyData&quot;) This will create a file ‘MyData.xlsx’ in your current working directory, which can be populate with your fishery data. Remember, to see the help documentation for information on the slots in the Data object: ?class(&quot;Data&quot;) You do not have to enter data for every line of the data file, if data are not available simply put an ‘NA’ next to any given field. 19.2 Importing the Data object Once populated, the Excel Data file can be imported into R: MyData &lt;- XL2Data(&#39;MyData&#39;) In this case we get an error because the Data file is empty: we haven’t populated it with an data yet. Luckily for us, DLMtool includes several example Data files. 19.3 Example Fishery Data Files One example Data file is the China rockfish. You can download this Data file to your current working directory and import into R: China_rockfish &lt;- XL2Data(&quot;China_rockfish.csv&quot;) The CSV files for the other example Fishery Data objects are also included in the DLMtool package. To find the location where these files are located on your machine, use the DLMDataDir function: DLMDataDir() ## [1] &quot;C:/Users/User/Documents/R/win-library/3.5/DLMtool&quot; We can then load one of the example CSV files using the XL2Data function: China_rockfish2 &lt;- XL2Data(file.path(DLMDataDir(), &quot;China_rockfish.csv&quot;)) ## Reading China_rockfish.csv or the new function: China_rockfish2 &lt;- new(&quot;Data&quot;, file.path(DLMDataDir(),&quot;China_rockfish.csv&quot;)) Alternatively, you can navigate to the data directory (DLMDataDir()) on your machine and examine the contents and structure of the CSV data files in MS Excel or other software. 19.4 Populating a Data Object in R You can create a blank Data object and fill the slots directly in R. For example: Madeup &lt;- new(&#39;Data&#39;) # Create a blank DLM object Madeup@Name &lt;- &#39;Test&#39; # Name it Madeup@Cat &lt;- matrix(20:11*rlnorm(10,0,0.2),nrow=1) # Generate fake catch data Madeup@Units &lt;- &quot;Million metric tonnes&quot; # State units of catch Madeup@AvC &lt;- mean(Madeup@Cat) # Average catches for time t (DCAC) Madeup@t &lt;- ncol(Madeup@Cat) # No. yrs for Av. catch (DCAC) Madeup@Dt &lt;- 0.5 # Depletion over time t (DCAC) Madeup@Dep &lt;- 0.5 # Depletion relative to unfished Madeup@vbK &lt;- 0.2 # VB maximum growth rate Madeup@vbt0 &lt;- (-0.5) # VB theoretical age at zero length Madeup@vbLinf &lt;- 200 # VB maximum length Madeup@Mort &lt;- 0.1 # Natural mortality rate Madeup@Abun &lt;- 200 # Current abundance Madeup@FMSY_M &lt;- 0.75 # Ratio of FMSY/M Madeup@L50 &lt;- 100 # Length at 50% maturity Madeup@L95 &lt;- 120 # Length at 95% maturity Madeup@BMSY_B0 &lt;- 0.35 # BMSY relative to unfished "],
["plotting-data-objects.html", "Chapter 20 Plotting Data Objects", " Chapter 20 Plotting Data Objects A generic summary function is available to visualize the data in a Data object. By default the summary function waits for user input before displaying the next plot, this option can be switched off using wait=FALSE: summary(Cobia, wait=FALSE, rmd=TRUE) ## ## ## ## Time-Series ## ## ## ## Catch-at-Age ## Plot 1 of 2 ## Plot 2 of 2 ## ## ## ## Catch-at-Length ## Plot 1 of 2 ## Plot 2 of 2 ## ## ## ## Parameter Distributions "],
["determining-feasible-and-available-management-procedures.html", "Chapter 21 Determining Feasible and Available Management Procedures 21.1 Feasible MPs 21.2 Available MPs 21.3 Unavailable MPs", " Chapter 21 Determining Feasible and Available Management Procedures Although all management procedures can be tested in the simulation, it is often the case that not all MPs can actually be applied in a fishery. This can happen for two reasons: Insufficient data exists to use an MP, for example, a MP may use catch-at-age data which does not exist for the fishery Management constraints such as issues with enforcement or legal requirements may mean some management options are not possible. Management procedures which can be applied given the current fishery data are referred to as Available. Management procedures that return management recommendations that are, at least in theory, applicable to the fishery are referred to as Feasible. DLMtool has functions to identify MPs that are Available and Feasible, and also provides information for what additional data are required to allow Not Available MPs to be used. 21.1 Feasible MPs The Fease function can be used to determine which MPs are Feasible. For example, if only TAC management is feasible in a fishery, the feasible MPs are: Fease(TAC=TRUE, TAE=FALSE, SL=FALSE, Spatial=FALSE) ## Feasible management: ## TAC - total allowable catch ## No Data object provided. Returning feasible MPs ## [1] &quot;AvC&quot; &quot;BK&quot; &quot;BK_CC&quot; &quot;BK_ML&quot; &quot;CC1&quot; ## [6] &quot;CC2&quot; &quot;CC3&quot; &quot;CC4&quot; &quot;CC5&quot; &quot;CompSRA&quot; ## [11] &quot;CompSRA4010&quot; &quot;DAAC&quot; &quot;DBSRA&quot; &quot;DBSRA_40&quot; &quot;DBSRA4010&quot; ## [16] &quot;DCAC&quot; &quot;DCAC_40&quot; &quot;DCAC_ML&quot; &quot;DCAC4010&quot; &quot;DCACs&quot; ## [21] &quot;DD&quot; &quot;DD4010&quot; &quot;DepF&quot; &quot;DynF&quot; &quot;Fadapt&quot; ## [26] &quot;Fdem&quot; &quot;Fdem_CC&quot; &quot;Fdem_ML&quot; &quot;FMSYref&quot; &quot;FMSYref50&quot; ## [31] &quot;FMSYref75&quot; &quot;Fratio&quot; &quot;Fratio_CC&quot; &quot;Fratio_ML&quot; &quot;Fratio4010&quot; ## [36] &quot;GB_CC&quot; &quot;GB_slope&quot; &quot;GB_target&quot; &quot;Gcontrol&quot; &quot;HDAAC&quot; ## [41] &quot;ICI&quot; &quot;ICI2&quot; &quot;Iratio&quot; &quot;Islope1&quot; &quot;Islope2&quot; ## [46] &quot;Islope4&quot; &quot;IT10&quot; &quot;IT5&quot; &quot;Itarget1&quot; &quot;Itarget2&quot; ## [51] &quot;Itarget3&quot; &quot;Itarget4&quot; &quot;ITM&quot; &quot;L95target&quot; &quot;Lratio_BHI&quot; ## [56] &quot;Lratio_BHI2&quot; &quot;Lratio_BHI3&quot; &quot;LstepCC1&quot; &quot;LstepCC2&quot; &quot;LstepCC3&quot; ## [61] &quot;LstepCC4&quot; &quot;Ltarget1&quot; &quot;Ltarget2&quot; &quot;Ltarget3&quot; &quot;Ltarget4&quot; ## [66] &quot;MCD&quot; &quot;MCD4010&quot; &quot;NFref&quot; &quot;Rcontrol&quot; &quot;Rcontrol2&quot; ## [71] &quot;SBT1&quot; &quot;SBT2&quot; &quot;SPmod&quot; &quot;SPMSY&quot; &quot;SPslope&quot; ## [76] &quot;SPSRA&quot; We can confirm that all of these MPs are output controls (return a TAC) by using the MPtype function: feaseMPs &lt;- Fease(TAC=TRUE, TAE=FALSE, SL=FALSE, Spatial=FALSE) ## Feasible management: ## TAC - total allowable catch ## No Data object provided. Returning feasible MPs MPtype(feaseMPs) ## MP Type Recs ## 1 AvC Output TAC ## 2 BK Output TAC ## 3 BK_CC Output TAC ## 4 BK_ML Output TAC ## 5 CC1 Output TAC ## 6 CC2 Output TAC ## 7 CC3 Output TAC ## 8 CC4 Output TAC ## 9 CC5 Output TAC ## 10 CompSRA Output TAC ## 11 CompSRA4010 Output TAC ## 12 DAAC Output TAC ## 13 DBSRA Output TAC ## 14 DBSRA_40 Output TAC ## 15 DBSRA4010 Output TAC ## 16 DCAC Output TAC ## 17 DCAC_40 Output TAC ## 18 DCAC_ML Output TAC ## 19 DCAC4010 Output TAC ## 20 DCACs Output TAC ## 21 DD Output TAC ## 22 DD4010 Output TAC ## 23 DepF Output TAC ## 24 DynF Output TAC ## 25 Fadapt Output TAC ## 26 Fdem Output TAC ## 27 Fdem_CC Output TAC ## 28 Fdem_ML Output TAC ## 29 Fratio Output TAC ## 30 Fratio_CC Output TAC ## 31 Fratio_ML Output TAC ## 32 Fratio4010 Output TAC ## 33 GB_CC Output TAC ## 34 GB_slope Output TAC ## 35 GB_target Output TAC ## 36 Gcontrol Output TAC ## 37 HDAAC Output TAC ## 38 ICI Output TAC ## 39 ICI2 Output TAC ## 40 Iratio Output TAC ## 41 Islope1 Output TAC ## 42 Islope2 Output TAC ## 43 Islope4 Output TAC ## 44 IT10 Output TAC ## 45 IT5 Output TAC ## 46 Itarget1 Output TAC ## 47 Itarget2 Output TAC ## 48 Itarget3 Output TAC ## 49 Itarget4 Output TAC ## 50 ITM Output TAC ## 51 L95target Output TAC ## 52 Lratio_BHI Output TAC ## 53 Lratio_BHI2 Output TAC ## 54 Lratio_BHI3 Output TAC ## 55 LstepCC1 Output TAC ## 56 LstepCC2 Output TAC ## 57 LstepCC3 Output TAC ## 58 LstepCC4 Output TAC ## 59 Ltarget1 Output TAC ## 60 Ltarget2 Output TAC ## 61 Ltarget3 Output TAC ## 62 Ltarget4 Output TAC ## 63 MCD Output TAC ## 64 MCD4010 Output TAC ## 65 Rcontrol Output TAC ## 66 Rcontrol2 Output TAC ## 67 SBT1 Output TAC ## 68 SBT2 Output TAC ## 69 SPmod Output TAC ## 70 SPMSY Output TAC ## 71 SPslope Output TAC ## 72 SPSRA Output TAC ## 73 FMSYref Reference TAC ## 74 FMSYref50 Reference TAC ## 75 FMSYref75 Reference TAC ## 76 NFref Reference TAC If a Data object is provided to Fease, the function will return the names of MPs that are both feasible in terms of management methods, and available in terms of the fishery data: feaseMPs &lt;- Fease(Atlantic_mackerel, TAC=FALSE, TAE=TRUE, SL=TRUE, Spatial=FALSE) ## Feasible management: ## TAE - total allowable effort ## SL - size selectivity ## Data object provided. Returning feasible and available MPs MPtype(feaseMPs) ## MP Type Recs ## 1 curE Input TAE ## 2 curE75 Input TAE ## 3 DDe Input TAE ## 4 DDe75 Input TAE ## 5 DDes Input TAE ## 6 DTe40 Input TAE ## 7 DTe50 Input TAE ## 8 ItargetE1 Input TAE ## 9 ItargetE2 Input TAE ## 10 ItargetE3 Input TAE ## 11 ItargetE4 Input TAE ## 12 matlenlim Input SL ## 13 matlenlim2 Input SL ## 14 minlenLopt1 Input SL ## 15 slotlim Input SL 21.2 Available MPs The Can function generates a list of the MPs that are available to be applied to the Data object: Can(Atlantic_mackerel) ## [1] &quot;AvC&quot; &quot;AvC_MLL&quot; &quot;BK&quot; &quot;CC1&quot; ## [5] &quot;CC2&quot; &quot;CC3&quot; &quot;CC4&quot; &quot;CC5&quot; ## [9] &quot;curE&quot; &quot;curE75&quot; &quot;DAAC&quot; &quot;DBSRA&quot; ## [13] &quot;DBSRA_40&quot; &quot;DBSRA4010&quot; &quot;DCAC&quot; &quot;DCAC_40&quot; ## [17] &quot;DCAC4010&quot; &quot;DCACs&quot; &quot;DD&quot; &quot;DD4010&quot; ## [21] &quot;DDe&quot; &quot;DDe75&quot; &quot;DDes&quot; &quot;DepF&quot; ## [25] &quot;DTe40&quot; &quot;DTe50&quot; &quot;DynF&quot; &quot;Fadapt&quot; ## [29] &quot;Fdem&quot; &quot;Fratio&quot; &quot;Fratio4010&quot; &quot;GB_slope&quot; ## [33] &quot;Gcontrol&quot; &quot;HDAAC&quot; &quot;ICI&quot; &quot;ICI2&quot; ## [37] &quot;Iratio&quot; &quot;Islope1&quot; &quot;Islope2&quot; &quot;Islope4&quot; ## [41] &quot;Itarget1&quot; &quot;Itarget1_MPA&quot; &quot;Itarget2&quot; &quot;Itarget3&quot; ## [45] &quot;Itarget4&quot; &quot;ItargetE1&quot; &quot;ItargetE2&quot; &quot;ItargetE3&quot; ## [49] &quot;ItargetE4&quot; &quot;matlenlim&quot; &quot;matlenlim2&quot; &quot;MCD&quot; ## [53] &quot;MCD4010&quot; &quot;minlenLopt1&quot; &quot;MRnoreal&quot; &quot;MRreal&quot; ## [57] &quot;NFref&quot; &quot;Rcontrol&quot; &quot;Rcontrol2&quot; &quot;SBT1&quot; ## [61] &quot;slotlim&quot; &quot;SPmod&quot; &quot;SPMSY&quot; &quot;SPslope&quot; ## [65] &quot;SPSRA&quot; &quot;YPR&quot; If all management methods are feasible, the list of MPs returned by the Can function will be the same as those returned by the Fease function when the Data object is provided. 21.3 Unavailable MPs The Cant function displays a list of the MPs that cannot be applied to the Data object together with the reason why: Cant(Atlantic_mackerel) ## [,1] ## [1,] &quot;BK_CC&quot; ## [2,] &quot;BK_ML&quot; ## [3,] &quot;CompSRA&quot; ## [4,] &quot;CompSRA4010&quot; ## [5,] &quot;DCAC_ML&quot; ## [6,] &quot;EtargetLopt&quot; ## [7,] &quot;Fdem_CC&quot; ## [8,] &quot;Fdem_ML&quot; ## [9,] &quot;FMSYref&quot; ## [10,] &quot;FMSYref50&quot; ## [11,] &quot;FMSYref75&quot; ## [12,] &quot;Fratio_CC&quot; ## [13,] &quot;Fratio_ML&quot; ## [14,] &quot;GB_CC&quot; ## [15,] &quot;GB_target&quot; ## [16,] &quot;IT10&quot; ## [17,] &quot;IT5&quot; ## [18,] &quot;ITe10&quot; ## [19,] &quot;ITe5&quot; ## [20,] &quot;ITM&quot; ## [21,] &quot;L95target&quot; ## [22,] &quot;LBSPR&quot; ## [23,] &quot;LBSPR_MLL&quot; ## [24,] &quot;Lratio_BHI&quot; ## [25,] &quot;Lratio_BHI2&quot; ## [26,] &quot;Lratio_BHI3&quot; ## [27,] &quot;LstepCC1&quot; ## [28,] &quot;LstepCC2&quot; ## [29,] &quot;LstepCC3&quot; ## [30,] &quot;LstepCC4&quot; ## [31,] &quot;LstepCE1&quot; ## [32,] &quot;LstepCE2&quot; ## [33,] &quot;Ltarget1&quot; ## [34,] &quot;Ltarget2&quot; ## [35,] &quot;Ltarget3&quot; ## [36,] &quot;Ltarget4&quot; ## [37,] &quot;LtargetE1&quot; ## [38,] &quot;LtargetE4&quot; ## [39,] &quot;SBT2&quot; ## [40,] &quot;SPSRA_ML&quot; ## [41,] &quot;YPR_CC&quot; ## [42,] &quot;YPR_ML&quot; ## [,2] ## [1,] &quot;Missing data: CAA&quot; ## [2,] &quot;Missing data: Lbar, Lc, CAL&quot; ## [3,] &quot;Missing data: CAA&quot; ## [4,] &quot;Missing data: CAA&quot; ## [5,] &quot;Missing data: Lbar, Lc, CAL&quot; ## [6,] &quot;Missing data: ML&quot; ## [7,] &quot;Missing data: CAA&quot; ## [8,] &quot;Missing data: Lbar, Lc, CAL&quot; ## [9,] &quot;MP returned an error. Check MP function and/or Data object.&quot; ## [10,] &quot;MP returned an error. Check MP function and/or Data object.&quot; ## [11,] &quot;MP returned an error. Check MP function and/or Data object.&quot; ## [12,] &quot;Missing data: CAA&quot; ## [13,] &quot;Missing data: Lbar, Lc, CAL&quot; ## [14,] &quot;Missing data: Cref&quot; ## [15,] &quot;Missing data: Cref, Iref&quot; ## [16,] &quot;Missing data: Iref, MPrec&quot; ## [17,] &quot;Missing data: Iref, MPrec&quot; ## [18,] &quot;Missing data: Iref&quot; ## [19,] &quot;Missing data: Iref&quot; ## [20,] &quot;Missing data: Iref, MPrec&quot; ## [21,] &quot;Missing data: ML&quot; ## [22,] &quot;Missing data: CAL&quot; ## [23,] &quot;Missing data: CAL&quot; ## [24,] &quot;Missing data: CAL&quot; ## [25,] &quot;Missing data: CAL&quot; ## [26,] &quot;Missing data: CAL&quot; ## [27,] &quot;Missing data: ML&quot; ## [28,] &quot;Missing data: ML&quot; ## [29,] &quot;Missing data: ML&quot; ## [30,] &quot;Missing data: ML&quot; ## [31,] &quot;Missing data: ML&quot; ## [32,] &quot;Missing data: ML&quot; ## [33,] &quot;Missing data: ML&quot; ## [34,] &quot;Missing data: ML&quot; ## [35,] &quot;Missing data: ML&quot; ## [36,] &quot;Missing data: ML&quot; ## [37,] &quot;Missing data: ML&quot; ## [38,] &quot;Missing data: ML&quot; ## [39,] &quot;Missing data: Rec, Cref&quot; ## [40,] &quot;Missing data: Lbar, Lc, CAL&quot; ## [41,] &quot;Missing data: CAA&quot; ## [42,] &quot;Missing data: Lbar, Lc, CAL&quot; "],
["applying-management-procedures.html", "Chapter 22 Applying Management Procedures", " Chapter 22 Applying Management Procedures The runMP function can be used to apply a MP to a Data object. For example, to apply the AvC method: runMP(Atlantic_mackerel, &quot;AvC&quot;, reps=1000) ## TAC ## AvC 24.33 The runMP prints out the MP recommendations to the console. In the case of a TAC, where multiple repititions where (see reps = 1000 above) used the runMP function prints the median TAC recommendation. Although it only displays a summary, runMP invisibly returns the Data object with the TAC slot populated: Recs &lt;- runMP(Atlantic_mackerel, &quot;AvC&quot;) ## TAC ## AvC 24.76 hist(Recs@TAC) runMP can be used to run several MPs: runMP(Atlantic_mackerel, c(&quot;AvC&quot;, &quot;AvC_MLL&quot;)) ## TAC LR5 LFR ## AvC 24.54 ## AvC_MLL 23.88 90.25 95 Or all available MPs: Atlantic_mackerel &lt;- runMP(Atlantic_mackerel, reps=1000) ## running all available MPs ## Method Rcontrol produced greater than 50% NA values ## TAC Effort LR5 LFR HS Area 1 Area 2 ## AvC 24.89 ## AvC_MLL 24.31 90.25 95.00 ## BK 11.28 ## CC1 23.37 ## CC2 21.09 ## CC3 18.80 ## CC4 16.41 ## CC5 14.00 ## curE 1.00 ## curE75 0.75 ## DAAC 2.91 ## DBSRA 6.22 ## DBSRA_40 9.88 ## DBSRA4010 4.06 ## DCAC 5.69 ## DCAC_40 7.24 ## DCAC4010 1.43 ## DCACs 5.73 ## DD 2.03 ## DD4010 0.45 ## DDe 0.09 ## DDe75 0.07 ## DDes 0.90 ## DepF 2.94 ## DTe40 0.90 ## DTe50 0.90 ## DynF 5.04 ## Fadapt 8.13 ## Fdem 4.70 ## Fratio 3.68 ## Fratio4010 2.04 ## GB_slope 15.14 ## Gcontrol 6.53 ## HDAAC 2.86 ## ICI 13.91 ## ICI2 14.03 ## Iratio 10.04 ## Islope1 16.91 ## Islope2 14.74 ## Islope4 13.42 ## Itarget1 7.06 ## Itarget1_MPA 7.08 0 1 ## Itarget2 7.04 ## Itarget3 7.07 ## Itarget4 4.98 ## ItargetE1 0.85 ## ItargetE2 0.85 ## ItargetE3 0.85 ## ItargetE4 0.85 ## matlenlim 90.25 95.00 ## matlenlim2 99.28 104.50 ## MCD 13.63 ## MCD4010 8.82 ## minlenLopt1 89.75 99.72 ## MRnoreal 0 1 ## MRreal 0 1 ## NFref 0.01 ## Rcontrol 6.53 ## Rcontrol2 6.53 ## SBT1 14.91 ## slotlim 99.28 104.50 142.55 ## SPmod 15.71 ## SPMSY 11.53 ## SPslope 13.82 ## SPSRA 5.74 ## YPR 7.89 The TAC recommendations from each Output control can be plotted: boxplot(Atlantic_mackerel) "],
["averaging-mps.html", "Chapter 23 Averaging MPs", " Chapter 23 Averaging MPs In some cases users may wish to provide management advice by averaging the recommendations from several different well-performing management procedures. This of course is a new management procedure in itself, and should be tested in MSE before being adopted for use in a fishery. The makeMeanMP function can be used to create a new MP that averages the results of several MPs. For example, suppose we wished to develop an MP that averages the results of 4 output control MPs: BK, DBSRA, Fadapt and Rcontrol. This can be achieved by the following: avgMP &lt;- makeMeanMP(c(&quot;BK&quot;, &quot;DBSRA&quot;, &quot;Fadapt&quot;, &quot;Rcontrol&quot;)) class(avgMP) ## [1] &quot;MP&quot; And now we can test our new MP in MSE. We will run a decent run of simulations so the results are stable: OM &lt;- DLMtool::testOM OM@nsim &lt;- 200 MSE &lt;- runMSE(OM, MPs=c(&quot;avgMP&quot;, &quot;BK&quot;, &quot;DBSRA&quot;, &quot;Fadapt&quot;, &quot;Rcontrol&quot;), parallel = TRUE) ## Running MSE in parallel on 10 processors ## MSE completed How did our newly created averaging MP perform? Tplot(MSE) ## MP PNOF LTY P100 P50 P10 Satisificed ## 1 avgMP 0.51 0.80 0.42 0.68 0.90 FALSE ## 2 BK 0.42 0.53 0.33 0.49 0.75 FALSE ## 3 DBSRA 0.68 0.91 0.57 0.86 1.00 TRUE ## 4 Fadapt 0.49 0.61 0.42 0.60 0.79 FALSE ## 5 Rcontrol 0.90 0.36 0.87 0.94 0.98 FALSE More information on creating your own MPs can be found in the Developing Custom Management Procedures chapter. "],
["evaluating-om.html", "Chapter 24 Evaluating OM", " Chapter 24 Evaluating OM The Turing function has been designed to evaluate an Operating Model against a Data object from the same fishery. The function generates 5 random samples of Data from the OM object and plots these together with the corresponding data in the Data object. Ideally, in a well conditioned OM one should not be able to visually detect which of the plots are the real data and which have been artifically generated by the operating model. The Turing function takes an object of class OM and an object of class Data. It first plots the simulated and real data and then waits for user input before revelaing which of the plots are the real data from the Data object. We use the wait=FALSE argument here so that each plot is printed without waiting for user input. In this example we are using a Data object that was simulated using the same OM, so it shouldn’t be suprising that it is difficult to detect which of the plots are from the Data object: Turing(DLMtool::testOM, DLMtool::SimulatedData, wait=FALSE) ## Simulating Data ## Randomly sampling 5 iterations ## Plotting: Catch Data ## Plotting: Index Data ## Plotting: Recruitment Data ## Plotting: Mean Length Data ## Plotting: Lbar Data ## Plotting: Catch-at-Age Data ## Plotting: Catch-at-Length Data The Turing function is useful for evaluating if your OM adequately produces fishery data that appears similiar (e.g as variable) as your real observed data. "],
["customizing-the-operating-model.html", "Chapter 25 Customizing the Operating Model 25.1 Accounting for Historical Changes in Fishing 25.2 Size-Specific Natural Mortality 25.3 Selection, Retention and Discard Mortality", " Chapter 25 Customizing the Operating Model 25.1 Accounting for Historical Changes in Fishing In some circumstances there may be knowledge on the changes in fishing practices over the years, and it would be good to include this information in the Operating Model. The Operating Model can be conditioned with respect to historical trends in the fishing mortality, historical changes in the selectivity pattern, and the existence of MPAs. Remember to update and recompile the OM documentation whenever the OM is modified. 25.1.1 Historical Trends in Fishing Mortality Suppose that we know the fishery began in 1950, and fishing effort increased slowly over the next decade, was relatively stable between 1960 and 1970, then increased dramatically over the next 10 years. We also know that, while fishing effort stayed relatively constant from 1980 to around 2000, there has been a general decline in fishing effort in recent years. This information can be included in the Operating Model by using the ChooseEffort function. The ChooseEffort function takes an existing Fleet object as its first argument, and allows the user to manually map out the range for the historical trend in fishing effort. The ChooseEffort function then returns the updated Fleet object. A second optional argument can be used to specify the historical years. If used, this will replace the nyears in the Fleet object with the length of the Years vector. MyFleet &lt;- ChooseEffort(MyFleet, Years=1950:2016) If we take a look at the MyFleet object, we will see that three slots EffYears, EffLower and EffUpper have been replaced with the new values. Note that the trajectory that is mapped out here represents the bounds on the relative fishing mortality for each year. In this example, the fishing mortality rate was highest (on average) between 1980 and 2000, and is currently around 65 - 80% of this maximum level. 25.1.2 Historical Trends in Selectivity Pattern Suppose that we may knew there had been changes in the selectivity pattern of the fishery over time. This information can be included in the Operating Model by using the ChooseSelect function. Like the ChooseEffort function described above, the ChooseSelection function takes a Fleet object as it’s first argument, and returns an updated Fleet object. Suppose the selectivity pattern changed in 1970 and then again in 1990, perhaps because of changes in fishing regulations. These change points in the selectivity curve can be mapped by the following command: MyFleet &lt;- ChooseSelect(MyFleet, FstYr=1950, SelYears=c(1970, 1990)) Note that the first year (FstYr) must also be specified, and the selectivity pattern is mapped for this year as well. When ChooseSelect is used, the L5Lower, L5Upper, LFSLower, LFSUpper, VmaxLower, VmaxUpper, and SelYears slots are updated in the Fleet object. If these slots are populated, the values in the L5, LFS, and Vmaxlen slots are ignored in the operating model. 25.1.3 Including Existing MPAs By default the MSE assumes that there are no spatial closures in the historical period. Existing spatial closures can be accounted for with the MPA slot in the Fleet or OM object. To account for historical MPAs, the MPA slot should be a matrix with each row should containing a year index (e.g 10 for 10th historical year) followed by fraction of area open to fishing for each area. i.e. each row represents a change and the number of columns is nareas (default is 2) + 1. The spatial closures are assumed to remain in place for the future projections unless changed by a MP. Default (if left blank) is all areas are open to fishing in historical period. For example: OM &lt;- new(&quot;OM&quot;, Albacore, Generic_Fleet, Perfect_Info, Perfect_Imp) ## 50% of Area 1 was closed 30 years ago cl1 &lt;- c(OM@nyears-30, 0.5, 1) ## 80% of Area 1 was closed 15 years ago cl2 &lt;- c(OM@nyears-15, 0.2, 1) ## 100% of Area 1 was closed last year cl3 &lt;- c(OM@nyears-1, 0, 1) OM@MPA &lt;- matrix(c(cl1, cl2, cl3), ncol=3, byrow=TRUE) plotMPA(OM) 25.2 Size-Specific Natural Mortality 25.2.1 Constant M at age/size By default DLMtool assumes that natural mortality (M) is constant across age and size classes. However, in many species M is known to vary by size, and is often assumed to be higher for smaller age-classes and reduces as individuals age and grow. A number of users requested the option to include age or size-specific M and this has now been added to DLMtool. There are a number of ways to specify age or size-specific M in DLMtool. 25.2.2 Lorenzen function of weight Natural mortality is often assumed to be a function of weight. Size-specific M can be included in DLMtool following the approach of Lorenzen (1996): \\[M_w = M\\left(\\frac{W}{W_\\infty}\\right)^b\\] where \\(M_w\\) is the natural mortality at weight \\(W\\), \\(M\\) is the natural mortality rate of adult fish, \\(W_\\infty\\) is the asymptotic weight, and \\(b\\) is the allometric scaling factor (Stock@Mexp). Lorezen (1996) found that the exponent \\(b\\) had an average value of -0.288, with 90% confidence intervals of -0.315 – -0.261 for fish from natural systems. Because DLMtool uses an age-structured model, M is calculated as a function of age: \\[M_a = M\\left(\\frac{W_a}{W_\\infty}\\right)^b\\] where \\(M_a\\) is natural mortality at age \\(a\\) and \\(W_a\\) is the mean weight at age \\(a\\). M-at-age is then rescaled so that the mean M of adult age classes (mean age of maturity and greater) is equal to the natural mortality rate sampled from the stock object (Stock@M). The plotM function can be used to visually inspect samples of the M-at-age, -length, and -weight that are generated by the model: Mackerel@Mexp &lt;- c(-0.315, -0.261) plotM(Mackerel) 25.2.3 Map Age-Specific M Usually the M slot contains two values, a lower and upper bound for the constant M-at-age. Users who wish for more control of M-at-age can use the M and M2 slots in the Stock object to directly input values for M-at-age (M for lower bound and M2 for upper bound). maxage values of M must be supplied for slots M and M2. One way to do this is to use the ChooseM function to map out the bounds for age-specific M: OM &lt;- new(&quot;OM&quot;, Blue_shark, Generic_FlatE, Generic_Obs, Perfect_Imp) OM &lt;- ChooseM(OM) Click here for a larger version of the image. Alternatively, users can input the values directly into the M and M2 slots (must be length maxage): OM &lt;- new(&quot;OM&quot;, Albacore, Generic_FlatE, Generic_Obs, Perfect_Imp) OM@M &lt;- c(0.7, 0.65, 0.60, 0.55, 0.61, 0.68, 0.75, 0.63, 0.51, 0.39, 0.27, 0.15, 0.15, 0.15, 0.15) OM@M2 &lt;- c(0.85, 0.8, 0.75, 0.7, 0.76, 0.83, 0.9, 0.78, 0.66, 0.54, 0.42, 0.3, 0.3, 0.3, 0.3) The plotM function can then be used to visually display samples of the resulting M at age and size: plotM(OM) 25.2.4 Map Length-Specific M There is also the option to map length-specific M using the plotting tool: OM &lt;- new(&quot;OM&quot;, Albacore, Generic_FlatE, Generic_Obs, Perfect_Imp) OM &lt;- ChooseM(OM, &quot;length&quot;) Click here for a larger version of the image. This option uses the Custom Parameters feature of DLMtool: str(OM@cpars) ## List of 1 ## $ M_at_Length:&#39;data.frame&#39;: 42 obs. of 3 variables: ## ..$ Lens: int [1:42] 0 5 10 15 20 25 30 35 40 45 ... ## ..$ M1 : num [1:42] 0.8 0.8 0.8 0.8 0.8 0.8 0.8 0.8 0.8 0.725 ... ## ..$ M2 : num [1:42] 0.9 0.9 0.9 0.9 0.9 ... Again, samples of the resulting M at age and size can be plotted: plotM(OM) ## valid custom parameters (OM@cpars) found: ## M_at_Length 25.3 Selection, Retention and Discard Mortality Note that if OM@isRel == FALSE the selectivity and retention parameters are either in absolute units, the same units as OM@Linf and OM@L50. If OM@isRel == TRUE the selectivity and retention parameters are assumed to be multiples of the length at maturity (OM@L50). 25.3.1 Fishery Selection Curve The fishery selection or vulnerability to the fishing gear in DLMtool is modelled using a double-normal curve and the parameters in the Fleet object: L5 - smallest length at 5% selection, LFS - smallest length at full selection, and Vmaxlen the vulnerability of the largest length class (defined as expected length at maximum age Stock@maxage). Here we set up a Operating Model with dome-shaped selectivity and plot a sample of the selectivity-at-age and -length using the plotSelect function: OM &lt;- new(&quot;OM&quot;, Albacore, FlatE_Dom, Generic_Obs, Perfect_Imp, nsim=5) plotSelect(OM, sim=1) The plot shows three curves - vulnerability, realized selection and retention - in each panel. In this case they are all the same, because the default setting of DLMtool is to assume that all selected fish are retained in the catch. 25.3.2 Fishery Retention Curve In some cases the fishing gear selects fish (often small sizes) that are not retained in the catch and are discarded at sea. The fishery-retention curve can be specified following the same approach as selectivity, using the following slots in the Fleet or OM object: LR5 - the smallest length at 5% retention LFR - the smallest length at full retention Rmaxlen - the retention of the largest size class (defined as expected length at maximum age Stock@maxage). The default values for these parameters are: OM@LR5 ## [1] 0 0 OM@LFR ## [1] 0 0 OM@Rmaxlen ## [1] 1 1 meaning that the default assumption is that all size classes are fully retained by the fishery. The retention curve can be modified by providing values for these slots: OM@LR5 &lt;- c(0.6, 0.7) OM@LFR &lt;- c(0.9, 1) Note that the values in the LR5 and LFR slots must be in the same units as those in the L5 and LFS slots. Here we are specifying the values relative to the size of maturity, and assuming that the fishery discards the smaller sized fish: plotSelect(OM, sim=1) The plot shows that the retention curve for the fishery has shifted to the right, towards larger and older fish, while the vulnerability of the fishing gear remains the same. Because we are assuming no discard mortality in this case, the realized selection and retention curves are equivalent. This means that although fish of age/length between the vulnerability and retention curves are selected by the fishery, they are discarded with 100% survival and therefore are not removed from the population. 25.3.3 Discard Mortality The assumption of 100% survival of discarded fish may be unrealistic in many situations. Discard mortality can be specified by the Fdisc slot in the Stock or OM object. The Fdisc slot represents the fraction of discarded fish that die, or \\(1-\\text{survival}\\). Here we assume that between 30 and 50% of discarded fish suffer fishing mortality: OM@Fdisc &lt;- c(0.3, 0.5) plotSelect(OM, sim=1) We can see now that the realized selection and the retention curves are different for the age/size classes that are discarded by the fishery. The realized selection curve (dashed red line) represents the actual selectivity of the fish removed from the population. The retention curve (dotted blue line) shows the age/size classes that are retained by the fishery and appear in the total cathc, catch-at-age, and catch-at-length fishery data. The shaded gray area between these two curves represents that age/size classes that are caught and killed by the fishery but are discarded and do not appear in the catch statistics. The gear vulnerability curve remains unchanged, and shows that some individuals in the smaller age/size classes are caught and discarded alive back into the population. 25.3.4 General Discarding General discarding across all age or size classes can be included using the discarding rate slot DR in the Fleet or OM object. For example, here we assume that between 10 and 20% of all age/size classes are discarded by the fishery: OM@DR &lt;- c(0.1, 0.2) Plotting the selectivity and retention curves shows that a proportion of all age and size classes are now discarded, with the survival rate determined by the Fdisc parameter: plotSelect(OM, sim=1) "],
["developing-custom-management-procedures.html", "Chapter 26 Developing Custom Management Procedures 26.1 The Anatomy of an MP 26.2 A Constant Catch MP 26.3 A More Complex MP 26.4 Beyond the Catch Limit", " Chapter 26 Developing Custom Management Procedures DLMtool was designed to be extensible in order to promote the development of new Management Procedures. In this chapter we design a series of new Management Procedures that include spatial controls and input controls in the form of size limit restrictions. If you wish, you can also add your newly developed MPs to the DLMtool package so they are accessible to other uses. Of course you will be credited as the author. Please contact us for details how to do this. As we saw before, real data are stored in a class of objects Data. The DLMtool MSE function generates simulated data and puts it in exactly the same format as real data. This is highly desirable because it means that the same MP code that is tested in the MSE can then be used to make management recommendations. If an MP is coded incorrectly it may catastrophically fail MSE testing and will therefore be excluded from use in management. 26.1 The Anatomy of an MP Let’s examine an existing output MP to identify the MP data requirements. avail(&#39;Output&#39;) ## [1] &quot;AvC&quot; &quot;BK&quot; &quot;BK_CC&quot; &quot;BK_ML&quot; &quot;CC1&quot; ## [6] &quot;CC2&quot; &quot;CC3&quot; &quot;CC4&quot; &quot;CC5&quot; &quot;CompSRA&quot; ## [11] &quot;CompSRA4010&quot; &quot;DAAC&quot; &quot;DBSRA&quot; &quot;DBSRA_40&quot; &quot;DBSRA4010&quot; ## [16] &quot;DCAC&quot; &quot;DCAC_40&quot; &quot;DCAC_ML&quot; &quot;DCAC4010&quot; &quot;DCACs&quot; ## [21] &quot;DD&quot; &quot;DD4010&quot; &quot;DepF&quot; &quot;DynF&quot; &quot;Fadapt&quot; ## [26] &quot;Fdem&quot; &quot;Fdem_CC&quot; &quot;Fdem_ML&quot; &quot;Fratio&quot; &quot;Fratio_CC&quot; ## [31] &quot;Fratio_ML&quot; &quot;Fratio4010&quot; &quot;GB_CC&quot; &quot;GB_slope&quot; &quot;GB_target&quot; ## [36] &quot;Gcontrol&quot; &quot;HDAAC&quot; &quot;ICI&quot; &quot;ICI2&quot; &quot;Iratio&quot; ## [41] &quot;Islope1&quot; &quot;Islope2&quot; &quot;Islope4&quot; &quot;IT10&quot; &quot;IT5&quot; ## [46] &quot;Itarget1&quot; &quot;Itarget2&quot; &quot;Itarget3&quot; &quot;Itarget4&quot; &quot;ITM&quot; ## [51] &quot;L95target&quot; &quot;Lratio_BHI&quot; &quot;Lratio_BHI2&quot; &quot;Lratio_BHI3&quot; &quot;LstepCC1&quot; ## [56] &quot;LstepCC2&quot; &quot;LstepCC3&quot; &quot;LstepCC4&quot; &quot;Ltarget1&quot; &quot;Ltarget2&quot; ## [61] &quot;Ltarget3&quot; &quot;Ltarget4&quot; &quot;MCD&quot; &quot;MCD4010&quot; &quot;Rcontrol&quot; ## [66] &quot;Rcontrol2&quot; &quot;SBT1&quot; &quot;SBT2&quot; &quot;SPmod&quot; &quot;SPMSY&quot; ## [71] &quot;SPslope&quot; &quot;SPSRA&quot; &quot;SPSRA_ML&quot; &quot;YPR&quot; &quot;YPR_CC&quot; ## [76] &quot;YPR_ML&quot; &quot;avgMP&quot; Since we’ve seen it used as a default MP in lots of the examples above, lets learn more about DCAC ?DCAC We can even see all the code for this MP by simply typing the name of the MP into the console (this is a fantastic advantage of using R - there is complete transparency about package functions): DCAC ## function (x, Data, reps = 100, plot = FALSE) ## { ## rundcac &lt;- DCAC_(x, Data, reps, updateD = TRUE) ## TAC &lt;- TACfilter(rundcac$dcac) ## if (plot) ## DCAC_plot(x, Data, dcac = rundcac$dcac, TAC, Bt_K = rundcac$Bt_K, ## yrs = 1:length(Data@Year)) ## Rec &lt;- new(&quot;Rec&quot;) ## Rec@TAC &lt;- TAC ## Rec ## } ## &lt;bytecode: 0x0000000016d22068&gt; ## &lt;environment: namespace:DLMtool&gt; ## attr(,&quot;class&quot;) ## [1] &quot;MP&quot; “Crikey that looks complicated!” might be your first reaction. However this output MP function is easily demystified. Like all MPs it has four arguments: x, Data, reps and plot (the last argument was added recently and is optional). The argument x is the position in the Data object. When real data are stored in a Data object, there is only one position - there is only one real data set. However, in MSE we conduct many simulations and x refers to simulated data from simulation number x. Any single parameters such as natural mortality rate (Mort) are a vector (nsim long). See Data@Mort[x] in the DCAC code. Any time series such as annual catches or relative abundance indices, are a matrix of nsim rows and nyears columns. A range of objects of class Data are available: avail(&#39;Data&#39;) ## [1] &quot;Atlantic_mackerel&quot; &quot;China_rockfish&quot; &quot;Cobia&quot; ## [4] &quot;Example_datafile&quot; &quot;Gulf_blue_tilefish&quot; &quot;ourReefFish&quot; ## [7] &quot;Red_snapper&quot; &quot;SimulatedData&quot; &quot;Simulation_1&quot; ## [10] &quot;China_rockfish2&quot; &quot;Madeup&quot; &quot;Recs&quot; For simplicity lets use a Data object with just one simulation, Simulation_1 and rename it Data Data &lt;- Simulation_1 Since there is only one simulation in this data set (1 position) we can now see a single value of natural mortality rate: Data@Mort ## [1] 0.2244735 And a matrix of catches with only 1 row: Data@Cat ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## [1,] 4.275057 12.43761 14.63192 35.31725 28.69802 30.84651 24.14059 ## [,8] [,9] [,10] [,11] [,12] [,13] [,14] ## [1,] 36.78335 29.27517 38.18088 59.30242 56.08995 37.96849 51.84985 ## [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] ## [1,] 60.76729 41.53713 39.31114 57.9673 57.2248 72.37596 80.69301 76.63558 ## [,23] [,24] [,25] [,26] [,27] [,28] [,29] [,30] ## [1,] 59.37687 48.82643 50.38803 80.71158 53.35875 74.31955 48.83082 43.348 ## [,31] [,32] [,33] [,34] [,35] [,36] [,37] ## [1,] 65.17864 49.94281 47.38492 45.23197 80.92438 51.91477 29.36491 ## [,38] [,39] [,40] [,41] [,42] [,43] [,44] ## [1,] 43.44834 49.46923 50.33217 49.53639 39.28779 27.31767 38.97092 ## [,45] [,46] [,47] [,48] [,49] [,50] ## [1,] 51.1054 37.34677 37.33128 24.24094 23.47756 21.08158 We could generate a single TAC recommendation from these data using DCAC by specifying position 1 (there is only 1 simulation) and by setting reps=1 (we want a single DCAC TAC recommendation) DCAC(x=1,Data,reps=1) ## TAC (median) ## 37.61246 If we wanted a stochastic estimate of the TAC we could increase the number of reps: hist(DCAC(x=1,Data,reps=1000)@TAC,xlab=&quot;TAC&quot;,ylab=&quot;Freq.&quot;,col=&quot;blue&quot;) 26.2 A Constant Catch MP We’ve now got a better idea of the anatomy of an MP. It is a function that must accept three arguments (we will ignore plot for now): x: a simulation number Data: an object of class Data reps: the MP can provide a sample of TACs reps long. Let’s have a go at designing our own custom MP that can work with DLMtool. We’re going to develop an MP that sets the TAC as the ‘3rd highest catch’. We decide to call our function THC THC&lt;-function(x, Data, reps){ # Find the position of third highest catch THCpos&lt;-order(Data@Cat[x,],decreasing=T)[3] # Make this the mean TAC recommendation THCmu&lt;-Data@Cat[x,THCpos] # A sample of the THC is taken according to a fixed CV of 10% TACs &lt;- THCmu * exp(rnorm(reps, -0.1^2/2, 0.1)) # this is a lognormal distribution Rec &lt;- new(&quot;Rec&quot;) # create a &#39;Rec&#39;object Rec@TAC &lt;- TACs # assign the TACs to the TAC slot Rec # return the Rec object } To recap that’s just seven lines of code: THC&lt;-function(x, Data, reps){ THCpos&lt;-order(Data@Cat[x,],decreasing=T)[3] THCmu&lt;-Data@Cat[x,THCpos] Rec &lt;- new(&quot;Rec&quot;) Rec@TAC &lt;- THCmu * exp(rnorm(reps, -0.1^2/2, 0.1)) Rec } We can quickly test our new MP for the example Data object THC(x=1,Data,reps=10)@TAC ## [1] 79.11177 72.52747 82.94707 87.01687 87.66503 70.79588 78.22426 ## [8] 72.82187 75.81387 80.42515 Now that we know it works, to make the function compatible with the DLMtool package we have to assign it the class ‘MP’ so that DLMtool recognizes the function as a management procedure class(THC)&lt;-&quot;MP&quot; If we want to run the MSE in parallel we need to export the newly created function to the cluster: sfExport(&#39;THC&#39;) 26.3 A More Complex MP The THC MP is simple and frankly not a great performer (depending on depletion, life-history, adherence to TAC recommendations). Let’s innovate and create a brand new MP that could suit a catch-data-only stock like Indian Ocean Longtail tuna! It may be possible to choose a single fleet and establish a catch rate that is ‘reasonable’ or ‘fairly productive’ relative to current catch rates. This could be for example, 40% of the highest catch rate observed for this fleet or, for example, 150% of current cpue levels. It is straightforward to design an MP that will aim for this target index level by making adjustments to the TAC. We will call this MP TCPUE, short for target catch per unit effort: TCPUE&lt;-function(x,Data,reps){ mc&lt;-0.05 # max change in TAC frac&lt;-0.3 # target index is 30% of max nyears&lt;-length(Data@Ind[x,]) # number of years of data smoothI&lt;-smooth.spline(Data@Ind[x,]) # smoothed index targetI&lt;-max(smoothI$y)*frac # target currentI&lt;-mean(Data@Ind[x,(nyears-2):nyears]) # current index ratio&lt;-currentI/targetI # ratio currentI/targetI if(ratio &lt; (1 - mc)) ratio &lt;- 1 - mc # if currentI &lt; targetI if(ratio &gt; (1 + mc)) ratio &lt;- 1 + mc # if currentI &gt; targetI Rec &lt;- new(&quot;Rec&quot;) Rec@TAC &lt;- Data@MPrec[x] * ratio * exp(rnorm(reps, -Data@CV_Ind[x]^2/2, Data@CV_Ind[x])) Rec } The TCPUE function simply decreases the past TAC (stored in Data@MPrec) if the index is lower than the target and increases the TAC if the index is higher than the target. All that is left is to make it compatible with DLMtool: class(TCPUE)&lt;-&quot;MP&quot; sfExport(&quot;TCPUE&quot;) 26.4 Beyond the Catch Limit All management procedures return an object of class ‘Rec’ that contains 13 slots: slotNames(&quot;Rec&quot;) ## [1] &quot;TAC&quot; &quot;Effort&quot; &quot;Spatial&quot; &quot;Allocate&quot; &quot;LR5&quot; &quot;LFR&quot; ## [7] &quot;HS&quot; &quot;Rmaxlen&quot; &quot;L5&quot; &quot;LFS&quot; &quot;Vmaxlen&quot; &quot;Fdisc&quot; ## [13] &quot;Misc&quot; We’ve already seen the TAC slot in the previous exercise. The remaining slots relate to various forms of input control: Effort (total allowable effort (TAE) relative to last historical year) Spatial - Fraction of each area that is open Allocate - Allocation of effort from closed areas to open areas LR5 - Length at 5% retention LFR - Length at 100% retention HS - Upper slot limit Rmaxlen - Retention of the maximum length class L5 - Length at 5% selection (e.g a change in gear type) LFS - Length at 100% selection (e.g a change in gear type) Vmaxlen - Selectivity of the maximum length class Fdisc - Update the discard mortality if required Misc - An optional slot for storing additional information The curE MP just keeps effort constant at current levels: curE ## function (x, Data, reps, plot = FALSE) ## { ## rec &lt;- new(&quot;Rec&quot;) ## rec@Effort &lt;- 1 ## if (plot) ## curE_plot(x, rec, Data) ## rec ## } ## &lt;bytecode: 0x0000000018fea478&gt; ## &lt;environment: namespace:DLMtool&gt; ## attr(,&quot;class&quot;) ## [1] &quot;MP&quot; Note that only the Effort slot in the Rec object is populated in this case. To highlight the differences among Input control MPs examine spatial control MP MRreal that closes area 1 to fishing and reallocates fishing to the open area 2: MRreal ## function (x, Data, reps, plot = FALSE) ## { ## rec &lt;- new(&quot;Rec&quot;) ## rec@Allocate &lt;- 1 ## rec@Spatial &lt;- c(0, rep(1, Data@nareas - 1)) ## if (plot) ## barplot(rec@Spatial, xlab = &quot;Area&quot;, ylab = &quot;Fraction Open&quot;, ## ylim = c(0, 1), names = 1:Data@nareas) ## return(rec) ## } ## &lt;bytecode: 0x0000000019d261b0&gt; ## &lt;environment: namespace:DLMtool&gt; ## attr(,&quot;class&quot;) ## [1] &quot;MP&quot; In contrast MRnoreal does not reallocate fishing effort: MRnoreal ## function (x, Data, reps, plot = FALSE) ## { ## rec &lt;- new(&quot;Rec&quot;) ## rec@Allocate &lt;- 0 ## rec@Spatial &lt;- c(0, rep(1, Data@nareas - 1)) ## if (plot) ## barplot(rec@Spatial, xlab = &quot;Area&quot;, ylab = &quot;Fraction Open&quot;, ## ylim = c(0, 1), names = 1:Data@nareas) ## return(rec) ## } ## &lt;bytecode: 0x0000000019d1e728&gt; ## &lt;environment: namespace:DLMtool&gt; ## attr(,&quot;class&quot;) ## [1] &quot;MP&quot; The MP matlenlim only specifies the parameters of length retention using an estimate of length at 50% maturity (Stock@L50): matlenlim ## function (x, Data, reps, plot = FALSE) ## { ## rec &lt;- new(&quot;Rec&quot;) ## rec@LFR &lt;- Data@L50[x] ## rec@LR5 &lt;- rec@LFR * 0.95 ## if (plot) ## size_lim_plot(x, Data, rec) ## rec ## } ## &lt;bytecode: 0x000000000ba61150&gt; ## &lt;environment: namespace:DLMtool&gt; ## attr(,&quot;class&quot;) ## [1] &quot;MP&quot; 26.4.1 An Example Effort Control Here we will copy and modify the MP we developed earlier to specify a new version of the target catch per unit effort MP (TCPUE) that provides effort recommendations: TCPUE_e&lt;-function(x,Data,reps){ mc&lt;-0.05 # max change in TAC frac&lt;-0.3 # target index is 30% of max nyears&lt;-length(Data@Ind[x,]) # number of years of data smoothI&lt;-smooth.spline(Data@Ind[x,]) # smoothed index targetI&lt;-max(smoothI$y)*frac # target currentI&lt;-mean(Data@Ind[x,(nyears-2):nyears]) # current index ratio&lt;-currentI/targetI # ratio currentI/targetI if(ratio &lt; (1 - mc)) ratio &lt;- 1 - mc # if currentI &lt; targetI if(ratio &gt; (1 + mc)) ratio &lt;- 1 + mc # if currentI &gt; targetI rec &lt;- new(&quot;Rec&quot;) rec@Effort &lt;- Data@MPeff[x] * ratio rec } There have been surprisingly few changes to make TCPUE an input control MP that sets total allowable effort. We have had to use stored recommendations of effort in the Data@MPeff slot, and The final line of the MP is our input control recommendatation that only modified the Effort. That is all. Again, we need to assign our new function to class MP and export it to the cluster: class(TCPUE_e)&lt;-&quot;MP&quot; sfExport(&#39;TCPUE_e&#39;) Let’s test the two MPs and see how they peform: testMSE&lt;-runMSE(testOM,MPs=c(&quot;TCPUE&quot;,&quot;TCPUE_e&quot;), parallel = TRUE) ## Running MSE in parallel on 10 processors ## MSE completed NOAA_plot(testMSE) ## PNOF B50 LTY VY ## TCPUE 45.8 57.8 45.4 81.2 ## TCPUE_e 53.8 75.1 80.4 2.1 "],
["custom-parameters.html", "Chapter 27 Custom Parameters 27.1 Valid cpars names 27.2 Correlated samples 27.3 Custom internal parameters", " Chapter 27 Custom Parameters By default, DLMtool samples the operating model parameters from a uniform distribution. Because the parameters are sampled independently, it is not possible to generate correlated samples. However, the cpars slot in the OM object can be used to pass custom samples into the MSE. The addition of the cpars slot provides a lot of flexibility to the DLMtool, and allows users full control of all parameters used in the model. For example, it is possible to generate operating models directly from the output of common stock assessment packages using functions in DLMtool (e.g SS2DLM for Stock Synthesis 3, and iSCAM2DLM for a iSCAM model - Note: these functions have now been moved to MSEtool). These functions take the correlated parameter values from the output of the stock assessment and provide them to DLMtool via the cpars slot, resulting in an operating model that is conditioned on the stock assessment. The cpars feature is being continually developed as more features are requested for DLMtool. 27.1 Valid cpars names The cpars slot requires a named list containing the custom parameter values. You can see the valid names for cpars by typing: head(validcpars()) ## Var. Dim. Desc. Type ## 1 R0 numeric vector length nsim Virgin recruitment Stock ## 2 M numeric vector length nsim Natural mortality Stock ## 3 Mexp numeric vector length nsim Lorenzen M-weight exponent Stock ## 4 Msd numeric vector length nsim Inter-annual variability in M Stock ## 5 Mgrad numeric vector length nsim Gradient in M Stock ## 6 h numeric vector length nsim Steepness Stock The custom parameters are divided into 5 different types: ‘Stock’, ‘Fleet’, ‘Obs’, and ‘Imp’ corresponding to the OM components of the same names, and ‘internal’ for internal operating model parameters that over-ride or ignore the values in the OM slots. A warning message will alert you if variables appear in the named cpars list that are not in validcpars(), and these will be ignored in the MSE. 27.2 Correlated samples As the cpars feature is used to provide correlated samples to the MSE, it is important that the same number of custom parameters are provided for each variable. In most cases, this is simply a vector nsim long. For example, if you wish to supply correlated samples of the von Bertalanffy growth parameters, you would create three vectors of length nsim containing the samples of Linf, K, and t0. If the vectors are shorter than nsim they will simply be recycled. An error message will alert you if the vectors are not the same length. As a demonstration, we will use the ForceCor function to generate correlated samples of M, K, L50, and Linf and examine the cpars slot in the resulting OM object: OM &lt;- ForceCor(DLMtool::testOM) str(OM@cpars) ## List of 4 ## $ M : num [1:48] 0.382 0.39 0.396 0.353 0.4 ... ## $ K : num [1:48] 0.174 0.176 0.187 0.163 0.196 ... ## $ L50 : num [1:48] 84.8 86.6 88.9 88.3 88 ... ## $ Linf: num [1:48] 132 132 130 134 128 ... You can see that the OM@cpars slot is a list of length 4 and contains named vectors with 48 correlated samples of the four parameters. Because the OM@cpars slot contains these values, the M, K, L50, and Linf values in the OM, e.g. OM@M will be ignored. Any additional custom parameters can be added to cpars using this same approach. For example, to provide custom (in this case uncorrelated) samples of t0: OM@cpars$t0 &lt;- runif(OM@cpars, -1, 0) str(OM@cpars) ## List of 5 ## $ M : num [1:48] 0.382 0.39 0.396 0.353 0.4 ... ## $ K : num [1:48] 0.174 0.176 0.187 0.163 0.196 ... ## $ L50 : num [1:48] 84.8 86.6 88.9 88.3 88 ... ## $ Linf: num [1:48] 132 132 130 134 128 ... ## $ t0 : num [1:4] -0.768 -0.759 -0.203 -0.168 27.3 Custom internal parameters It is also possible to supply custom generated time-varing values or other values to internal parameters using the cpars slot. For example, time-varying natural mortality or selectivity patterns. These are referred to as internal custom parameters. A list of valid internal cpars can be found by using the validcpars function. Here, for presentation purposes, we print just the first two columns: val_int &lt;- validcpars(&#39;internal&#39;) val_int[,c(1,2)] ## Var. ## 1 Cbias ## 2 CAL_bins ## 3 CAL_binsmid ## 4 L95 ## 5 Perr_y ## 6 M_at_Length ## 7 Asize ## 8 Karray ## 9 Linfarray ## 10 Marray ## 11 Krand ## 12 Linfrand ## 13 Mrand ## 14 ageM ## 15 age95 ## 16 M_ageArray ## 17 Mat_age ## 18 LatASD ## 19 Wt_age ## 20 Len_age ## 21 mov ## 22 initD ## 23 Find ## 24 dFfinal ## 25 V ## 26 retA ## 27 retL ## 28 lenMbias ## 29 Mbias ## 30 Kbias ## 31 t0bias ## 32 Linfbias ## 33 LFCbias ## 34 FMSYbias ## 35 FMSY_Mbias ## 36 BMSY_B0bias ## 37 Irefbias ## 38 Brefbias ## 39 Crefbias ## 40 Dbias ## 41 hbias ## 42 hsim ## 43 Data ## Dim. ## 1 numeric vector length nsim ## 2 numeric vector ## 3 numeric vector length(CAL_bins)-1 ## 4 numeric vector length nsim ## 5 numeric matrix dim = c(nsim, maxage+proyears+nyears-1) ## 6 numeric matrix dim = c(n.lengths, 3) ## 7 numeric matrix dim = c(nsim, narea) ## 8 numeric matrix dim = c(nsim, nyears+proyears) ## 9 numeric matrix dim = c(nsim, nyears+proyears) ## 10 numeric matrix dim = c(nsim, nyears+proyears) ## 11 numeric matrix dim = c(nsim, nyears+proyears) ## 12 numeric matrix dim = c(nsim, nyears+proyears) ## 13 numeric matrix dim = c(nsim, nyears+proyears) ## 14 numeric matrix dim = c(nsim, nyears+proyears) ## 15 numeric matrix dim = c(nsim, nyears+proyears) ## 16 numeric array dim = c(nsim, maxage, nyears+proyears) ## 17 numeric array dim = c(nsim, maxage, nyears+proyears) ## 18 numeric array dim = c(nsim, maxage, nyears+proyears) ## 19 numeric array dim = c(nsim, maxage, nyears+proyears) ## 20 numeric array dim = c(nsim, maxage, nyears+proyears) ## 21 numeric array dim = c(nsim, maxage, narea, narea) OR dim = c(nsim, maxage, narea, narea, nyears+proyears) ## 22 numeric vector length nsim ## 23 numeric matrix dim = c(nsim, nyears) ## 24 numeric vector length nsim ## 25 numeric array dim = c(nsim, maxage, nyears+proyears) ## 26 numeric array dim = c(nsim, maxage, nyears+proyears) ## 27 numeric array dim = c(nsim, nCALbins, nyears+proyears) ## 28 numeric vector length nsim ## 29 numeric vector length nsim ## 30 numeric vector length nsim ## 31 numeric vector length nsim ## 32 numeric vector length nsim ## 33 numeric vector length nsim ## 34 numeric vector length nsim ## 35 numeric vector length nsim ## 36 numeric vector length nsim ## 37 numeric vector length nsim ## 38 numeric vector length nsim ## 39 numeric vector length nsim ## 40 numeric vector length nsim ## 41 numeric vector length nsim ## 42 numeric vector length nsim ## 43 Object of class Data We can see that there are 43 valid internal cpars. The internal cpars are parameters that are derived from one or more of the OM slots. For example, M_ageArray is an internal array that describes the natural mortality rate at age for each simulation and year. Typically, this array is derived from the M, M2, Mexp, Mgrad and Msd slots in the Stock object. Using the cpars feature we can override these values in the OM and provide our own values for M for each simulation, age, and year. Information on the M_ageArray variable in cpars can be found in the output of the validcpars function: val_int[15,] ## Var. Dim. ## 15 age95 numeric matrix dim = c(nsim, nyears+proyears) ## Desc. Type ## 15 Age at 95% maturity by simulation and year internal To generate our own values of the M-at-age array we would populate OM@cpars$M_ageArray with an array with dimensions OM@nsim, OM@maxage, OM@nyears+OM@proyears. The cpars feature is very powerful but also somewhat complicated, especially if you are using internal custom parameters. For example, by default DLMtool uses the OM@L50_95 slot (the increment between length at 50% maturity (OM@L50) and length at 95% maturity (L95)) to calculate the internal parameter L95. This is neccessary to ensure that L95 is always greater than L50. Using internal parameters in cpars it is possible to pass values to L95 directly, however now it is up to you to make sure that the L95 values are greater than the corresponding L50 values, otherwise you end up with a species where fraction mature decreases with age/size! OM &lt;- testOM OM@cpars$L95 &lt;- rep(80, OM@nsim) temp &lt;- runMSE(OM, Hist=TRUE) ## Loading operating model ## valid custom parameters (OM@cpars) found: ## L95 ## Optimizing for user-specified movement ## Optimizing for user-specified depletion in last historical year ## 11 simulations have final biomass that is not close to sampled depletion ## Re-sampling depletion, recruitment error, and fishing effort ## Calculating historical stock and fishing dynamics ## Calculating MSY reference points for each year ## Calculating B-low reference points ## Calculating reference yield - best fixed F strategy ## Simulating observed data ## Returning historical simulations data.frame(L50=temp@SampPars$L50, L95=temp@SampPars$L95, diff=temp@SampPars$L95 - temp@SampPars$L50) ## L50 L95 diff ## 1 89.29632 80 -9.296324 ## 2 85.94840 80 -5.948397 ## 3 83.02974 80 -3.029737 ## 4 82.72569 80 -2.725685 ## 5 87.00959 80 -7.009591 ## 6 82.88771 80 -2.887705 ## 7 90.17793 80 -10.177931 ## 8 83.81742 80 -3.817423 ## 9 87.81777 80 -7.817765 ## 10 84.97352 80 -4.973519 ## 11 88.37993 80 -8.379927 ## 12 87.54484 80 -7.544837 ## 13 89.68775 80 -9.687752 ## 14 90.60570 80 -10.605700 ## 15 90.11753 80 -10.117530 ## 16 89.93550 80 -9.935500 ## 17 83.79199 80 -3.791989 ## 18 82.63972 80 -2.639718 ## 19 85.90402 80 -5.904019 ## 20 89.30135 80 -9.301353 ## 21 86.76698 80 -6.766979 ## 22 83.99262 80 -3.992624 ## 23 88.38363 80 -8.383626 ## 24 84.21836 80 -4.218363 ## 25 81.24307 80 -1.243072 ## 26 81.36054 80 -1.360544 ## 27 83.45353 80 -3.453532 ## 28 86.99403 80 -6.994028 ## 29 83.24743 80 -3.247426 ## 30 87.87676 80 -7.876755 ## 31 82.32874 80 -2.328738 ## 32 86.58952 80 -6.589517 ## 33 90.09740 80 -10.097400 ## 34 84.91566 80 -4.915659 ## 35 83.48538 80 -3.485384 ## 36 90.99788 80 -10.997882 ## 37 85.78385 80 -5.783854 ## 38 90.74749 80 -10.747493 ## 39 83.28700 80 -3.286995 ## 40 84.65751 80 -4.657509 ## 41 88.04526 80 -8.045262 ## 42 82.42479 80 -2.424794 ## 43 84.60668 80 -4.606678 ## 44 84.31737 80 -4.317373 ## 45 90.17543 80 -10.175434 ## 46 89.00868 80 -9.008677 ## 47 85.91241 80 -5.912413 ## 48 86.02250 80 -6.022501 plot(1:OM@maxage, temp@AtAge$Maturity[1,,1], type=&quot;l&quot;, xlab=&quot;Age&quot;, ylab=&quot;Maturity&quot;) We have tried to include checks to ensure the model is simulating credible population dynamics, but as this somewhat contrived example shows, care is needed when using OM@cpars to specify internal parameters. We recommend first running the model with Hist=TRUE as in the above example and examining the generated values to ensure the parameters you have added in OM@cpars are being used as expected. If you find that this is a feature you wish to use but are unclear how to do it, bug us with an email! "],
["subsetting-the-mse-object.html", "Chapter 28 Subsetting the MSE Object 28.1 Subsetting by Performance 28.2 Subsetting by Operating Model Parameters", " Chapter 28 Subsetting the MSE Object The plotting functions demonstrated above calculate the probabilities and show the trade-offs for all the simulations in the MSE. However, sometimes it is interesting to examine the results of individual Management Procedures or simulations. Many of the plotting functions have the optional arguments MPs and sims which allow you to specify which particular Management Procedures or simulations to include in the plots. You can also manually subset the MSE object using the Sub function. 28.1 Subsetting by Performance For example, we may wish to include only Management Procedures that have greater than 70% probability that the biomass is above \\(0.5B_{MSY}\\): We can do this using a combination of the summary function and the Sub function: stats &lt;- summary(BSharkMSE) # save summary object to `stats` ## Calculating Performance Metrics ## Performance.Metrics ## 1 Probability of not overfishing (F&lt;FMSY) ## 2 Spawning Biomass relative to SBMSY ## 3 Average Annual Variability in Yield (Years 1-50) ## 4 Average Yield relative to Reference Yield (Years 41-50) ## ## 1 Prob. F &lt; FMSY (Years 1 - 50) ## 2 Prob. SB &gt; 0.5 SBMSY (Years 1 - 50) ## 3 Prob. AAVY &lt; 20% (Years 1-50) ## 4 Prob. Yield &gt; 0.5 Ref. Yield (Years 41-50) ## ## ## Probability: ## MP PNOF P50 AAVY LTY ## 1 Fratio 0.49 0.58 0.59 0.46 ## 2 DCAC 0.60 0.72 0.77 0.63 ## 3 Fdem 0.54 0.62 0.64 0.52 ## 4 DD 0.50 0.69 0.78 0.69 ## 5 matlenlim 0.49 0.87 0.33 0.85 accept &lt;- which(stats$P50 &gt; 0.70) # index of methods that pass the criteria MPs &lt;- stats[accept,&quot;MP&quot;] # the acceptable MPs subMSE &lt;- Sub(BSharkMSE, MPs=MPs) Here we can see that the DCAC, matlenlim methods (2 of the 5) met our specified criteria. We used the Sub function to create a new MSE object that only includes these Management Procedures. We can than proceed to continue our analysis on the subMSE object, e.g.: Tplot(subMSE) ## MP PNOF LTY P100 P50 P10 Satisificed ## 1 DCAC 0.60 0.63 0.56 0.72 0.79 TRUE ## 2 matlenlim 0.49 0.85 0.67 0.87 0.99 FALSE 28.2 Subsetting by Operating Model Parameters We can also subset the MSE object by simulation. For example, we may be interested to look at how the methods perform under different assumptions about the natural mortality rate (M). In this MSE M ranged from 0.15 to 0.25. Here we identify the simulations where M was below and above the median rate: below &lt;- BSharkMSE@OM$M &lt; median(BSharkMSE@OM$M) above &lt;- BSharkMSE@OM$M &gt; median(BSharkMSE@OM$M) We can then use the Sub function to create two MSE objects, one only including simulations with lower values of M, and the other with simulations where M was above the median value: belowMSE &lt;- Sub(BSharkMSE, sims=below) aboveMSE &lt;- Sub(BSharkMSE, sims=above) You can see that the original MSE object has been split into two objects, each with half of the simulations: belowMSE@nsim ## [1] 100 aboveMSE@nsim ## [1] 100 We could then continue our analysis on each subset MSE and determine if the natural mortality rate is critical in determining which Management Procedure we would choose as the best option for managing the fishery. "],
["custom-performance-metrics.html", "Chapter 29 Custom Performance Metrics 29.1 Necessity of Complexity 29.2 PM Methods in Detail 29.3 Creating Example PMs and Plot", " Chapter 29 Custom Performance Metrics PM methods were introduced in the Performance Metrics Methods chapter. DLMtool includes several built-in PM methods: avail(&quot;PM&quot;) ## [1] &quot;AAVY&quot; &quot;LTY&quot; &quot;P10&quot; &quot;P100&quot; &quot;P50&quot; &quot;PNOF&quot; &quot;STY&quot; &quot;Yield&quot; We saw in Customizing the PM Functions that it is straightforward to modify the years that the performance statistics are calculated over using the Yrs argument, and the reference level using the Ref argument. In this section we describe the PM functions in more detail for advanced users who wish to develop their own PM methods. We will demonstrate this using the P50 performance metric function as an example. 29.1 Necessity of Complexity While at first glance the PM functions may appear overly complicated, they are actually quite straightforward. This level of complexity is required because functions of class PM not only return the required performance statistic, but also relevant contextual information. Imagine we want to develop a function to calculate the probability that \\(B &gt; 0.5 B_\\text{MSY}\\), which we will define as not overfished. We could do something like this: P_Noverfished &lt;- function(MSEobj) { round(apply(MSEobj@B_BMSY &gt;0.5, 2, mean),2) } We could increase the flexibility of the function by adding additional arguments to specify the years to calculate the statistic over, but for this demonstration we will keep it simple. Applying our function to calculate the performance statistic is straightforward: MSEobj &lt;- runMSE(silent=TRUE) # run an exampe MSE p_noverfish &lt;- P_Noverfished(MSEobj) # calculate and store our performance statistic p_noverfish ## [1] 0.75 0.73 0.98 0.88 0.99 0.92 The p_noverfish variable now contains our performance statistic, which we could use to plot or tabulate results. However, the numeric vector returned by P_Noverfished includes no information on what these numbers represent. This makes it difficult to include the results in generic plotting or summary functions. Furthermore, it is easy to imagine that with several similiar performance metric functions, it will be easy to loose track of the meaning of the results unless an elaborate variable naming system is used. The PM functions have been designed to avoid this problem by returning all information related to the calculation of the performance statistic. Here we calculate the same performance metric using the relevant PM function: p1 &lt;- P50(MSEobj) Note that we don’t need to use a descriptive variable name; the p1 variable includes relevant information on the performance metric. Note also that PM function are most often passed directly to plotting or table functions instead of being called and stored directly. The p1 variable is an object of class PMobj and includes the following slots: slotNames(p1) ## [1] &quot;Name&quot; &quot;Caption&quot; &quot;Stat&quot; &quot;Ref&quot; &quot;Prob&quot; &quot;Mean&quot; &quot;MPs&quot; The first two slots contain a descriptive name of the performance statistic, and a caption that can be used in plots or summary tables: p1@Name ## [1] &quot;Spawning Biomass relative to SBMSY&quot; p1@Caption ## [1] &quot;Prob. SB &gt; 0.5 SBMSY (Years 1 - 50)&quot; The last two slots contain the results of performance statistic and the names of the MPs: p1@Mean ## [1] 0.7475000 0.7325000 0.9845833 0.8762500 0.9933333 0.9195833 p1@MPs ## [1] &quot;AvC&quot; &quot;DCAC&quot; &quot;FMSYref&quot; &quot;curE&quot; &quot;matlenlim&quot; &quot;MRreal&quot; We will look at the other 3 slots in detail in the next section. The main point here is to demonstrate the using functions of class PM that return objects of class PMobj has the advantage that the function output is completely self-contained and can be used elsewhere without requiring any additional information. 29.2 PM Methods in Detail Let’s go through the P50 function in detail to see how it works: P50 ## function (MSEobj = NULL, Ref = 0.5, Yrs = NULL) ## { ## Yrs &lt;- ChkYrs(Yrs, MSEobj) ## PMobj &lt;- new(&quot;PMobj&quot;) ## PMobj@Name &lt;- &quot;Spawning Biomass relative to SBMSY&quot; ## if (Ref != 1) { ## PMobj@Caption &lt;- paste0(&quot;Prob. SB &gt; &quot;, Ref, &quot; SBMSY (Years &quot;, ## Yrs[1], &quot; - &quot;, Yrs[2], &quot;)&quot;) ## } ## else { ## PMobj@Caption &lt;- paste0(&quot;Prob. SB &gt; SBMSY (Years &quot;, Yrs[1], ## &quot; - &quot;, Yrs[2], &quot;)&quot;) ## } ## PMobj@Ref &lt;- Ref ## PMobj@Stat &lt;- MSEobj@B_BMSY[, , Yrs[1]:Yrs[2]] ## PMobj@Prob &lt;- calcProb(PMobj@Stat &gt; PMobj@Ref, MSEobj) ## PMobj@Mean &lt;- calcMean(PMobj@Prob) ## PMobj@MPs &lt;- MSEobj@MPs ## PMobj ## } ## &lt;bytecode: 0x000000001a55c460&gt; ## &lt;environment: namespace:DLMtool&gt; ## attr(,&quot;class&quot;) ## [1] &quot;PM&quot; Firstly, functions of class PM must have three arguments: MSEobj, Ref, and Yrs: args(P50) ## function (MSEobj = NULL, Ref = 0.5, Yrs = NULL) ## NULL The first argument MSEobj is obvious, an object of class MSE to calculate the performance statistic. The second argument Ref must have a default value. This is used as reference for the performance statistic, and will be demonstrated shortly. The third argument Yrs can have a default value of NULL or specify a numeric vector of length 2 with the first and last years to calculate the performance statistic, or a numeric vector of length 1 in which case if it is positive it is the first Yrs and if negative the last Yrs of the projection period. The first line of a PM function must be Yrs &lt;- ChkYrs(Yrs, MSEobj). This line updates the Yrs variable and makes sure that the specified year indices are valid. For example: ChkYrs(NULL, MSEobj) # returns all projection years ChkYrs(c(1,10), MSEobj) # returns first 10 years ChkYrs(c(60,80), MSEobj) # returns message and last 20 years ChkYrs(5, MSEobj) # first 5 years ChkYrs(-5, MSEobj) # last 5 years ChkYrs(c(50,10), MSEobj) # returns an error When the default value for Yrs is NULL, the Yrs variable is updated to include all projection years: Yrs &lt;- ChkYrs(NULL, MSEobj) Yrs ## [1] 1 50 Next we create a new object of class PMobj, and populate the Name slot with a short but descriptive name: PMobj &lt;- new(&quot;PMobj&quot;) PMobj@Name &lt;- &quot;Spawning Biomass relative to SBMSY&quot; The next line populates the Caption slot with a brief caption including the years over which the performance statistic is calculated. The if statement is not crucial, but avoids the redundant SB &gt; 1 SBMSY in cases where Ref=1. Next we store the value of the Ref argument in the PMobj@Ref slot so that information is contained in the function output. PMobj@Ref &lt;- Ref The Stat slot is an array that stores the variable which we wish to calculate the performance statistic; an output from the runMSE function with dimensions MSE@nsim, MSE@nMPs, and MSE@proyears (or fewer if the argument Yrs != NULL). In this case we want to calculate a performance statistic related to the biomass relative to BMSY, and so we assign the Stat slot as follows: PMobj@Stat &lt;- MSEobj@B_BMSY[, , Yrs[1]:Yrs[2]] Note that we are including all simulations and MPs and indexing the years specified in Yrs. Next we use the calcProb function to calculate the mean of PMobj@Stat &gt; PMobj@Ref over the years dimension. This results in a matrix with dimensions MSE@nsim, MSE@nMPs: PMobj@Prob &lt;- calcProb(PMobj@Stat &gt; PMobj@Ref, MSEobj) Note that in order to calculate a probability the argument to the calcProb function must be a logical array, which is achieved using the Ref slot. Also note that in this case PMobj@Stat &gt; PMobj@Ref is equivalent to MSEobj@B_BMSY[, , Yrs[1]:Yrs[2]] &gt; 0.5. The PM functions have been designed this way so that in most cases the PMobj@Prob &lt;- calcProb(PMobj@Stat &gt; PMobj@Ref) line is identical in all PM functions and does not need to be modified. The exception to this is if we don’t want to calculate a probability but want the actual mean values of PMobj@Stat, demonstrated in the example below. In the next line we calculate the mean of PMobj@Prob over simulations using the calcMean function: PMobj@Mean &lt;- calcMean(PMobj@Prob) Similiar to the previous line, this line is identical in all PM functions and can be simply copy/pasted from other PM functions without being modified. The Mean slot is a numeric vector of length MSEobj@nMPs with the overall performance statistic, in this case the probability of \\(B &gt; 0.5B_\\text{MSY}\\) across all simulations and years. Finally, we store the names of the MPs and return the PMobj. 29.3 Creating Example PMs and Plot As an example, we will create another version of DFO_plot using some custom PM functions and a customized version of TradePlot. First we create the plot using DFO_plot: DFO_plot(MSEobj) From the help documentation (?DFO_plot) we can see that this function plots mean biomass relative to BMSY and fishing mortality rate relative to FMSY over the final 5 years of the projection. First we’ll develop a PM function to calculate the mean B/BMSY for the last 5 years of the projection period. Notice that this is very similiar to P50 described above, with the modification of the Caption and the Prob slots, and the Yrs argument. We are calculating a mean here instead of a probability and are not using the Ref argument: MeanB &lt;- function(MSEobj = NULL, Ref = 1, Yrs = -5) { Yrs &lt;- ChkYrs(Yrs, MSEobj) PMobj &lt;- new(&quot;PMobj&quot;) PMobj@Name &lt;- &quot;Spawning Biomass relative to SBMSY&quot; PMobj@Caption &lt;- paste0(&quot;Mean SB/SBMSY (Years &quot;, Yrs[1], &quot; - &quot;, Yrs[2], &quot;)&quot;) PMobj@Ref &lt;- Ref PMobj@Stat &lt;- MSEobj@B_BMSY[, , Yrs[1]:Yrs[2]] PMobj@Prob &lt;- calcProb(PMobj@Stat, MSEobj) PMobj@Mean &lt;- calcMean(PMobj@Prob) PMobj@MPs &lt;- MSEobj@MPs PMobj } We develop a PM function to calculate average F/FMSY in a similar way: MeanF &lt;- function(MSEobj = NULL, Ref = 1, Yrs = -5) { Yrs &lt;- ChkYrs(Yrs, MSEobj) PMobj &lt;- new(&quot;PMobj&quot;) PMobj@Name &lt;- &quot;Fishing Mortality relative to FMSY&quot; PMobj@Caption &lt;- paste0(&quot;Mean F/FMSY (Years &quot;, Yrs[1], &quot; - &quot;, Yrs[2], &quot;)&quot;) PMobj@Ref &lt;- Ref PMobj@Stat &lt;- MSEobj@F_FMSY[, , Yrs[1]:Yrs[2]] PMobj@Prob &lt;- calcProb(PMobj@Stat, MSEobj) PMobj@Mean &lt;- calcMean(PMobj@Prob) PMobj@MPs &lt;- MSEobj@MPs PMobj } Similar to developing custom MPs we need to tell R that these new functions are PM methods: class(MeanB) &lt;- &quot;PM&quot; class(MeanF) &lt;- &quot;PM&quot; Now we can test our performance metric functions: data.frame(MP=MeanB(MSEobj)@MPs, B_BMSY=MeanB(MSEobj)@Mean, F_FMSY=MeanF(MSEobj)@Mean) ## MP B_BMSY F_FMSY ## 1 AvC 1.5028154 1.8089924 ## 2 DCAC 0.7287867 2.7666544 ## 3 FMSYref 0.9561748 1.0202412 ## 4 curE 1.5474619 0.9160854 ## 5 matlenlim 2.6493047 0.8945637 ## 6 MRreal 1.6312194 0.7449103 How do these results compare to what is shown in DFO_plot? We could also use the summary function with our new PM functions, but note that these results are not probabilities: summary(MSEobj, &#39;MeanB&#39;, &#39;MeanF&#39;) ## Calculating Performance Metrics ## Performance.Metrics ## 1 Spawning Biomass relative to SBMSY Mean SB/SBMSY (Years 46 - 50) ## 2 Fishing Mortality relative to FMSY Mean F/FMSY (Years 46 - 50) ## ## ## Probability: ## MP MeanB MeanF ## 1 AvC 1.50 1.80 ## 2 DCAC 0.73 2.80 ## 3 FMSYref 0.96 1.00 ## 4 curE 1.50 0.92 ## 5 matlenlim 2.60 0.89 ## 6 MRreal 1.60 0.74 Finally, we will develop a customized plotting function to reproduce the image produced by DFO_plot. We can produced something fairly similar quite quickly using the TradePlot function: TradePlot(MSEobj, &#39;MeanB&#39;, &#39;MeanF&#39;, Lims=c(0,0)) ## MP MeanB MeanF Satisificed ## 1 AvC 1.50 1.80 TRUE ## 2 DCAC 0.73 2.80 TRUE ## 3 FMSYref 0.96 1.00 TRUE ## 4 curE 1.50 0.92 TRUE ## 5 matlenlim 2.60 0.89 TRUE ## 6 MRreal 1.60 0.74 TRUE Adding the shaded polygons and text requires a little more tweaking and some knowledge of the ggplot2 package. We will wrap up our code in a function: NewPlot &lt;- function(MSEobj) { # create but don&#39;t show the plot P &lt;- TradePlot(MSEobj, &#39;MeanB&#39;, &#39;MeanF&#39;, Lims=c(0,0), Show=FALSE) P1 &lt;- P$Plots[[1]] # the ggplot objects are returned as a list # add the shaded regions and the text P1 + ggplot2::geom_rect(ggplot2::aes(xmin=c(0,0,0), xmax=c(0.4, 0.8, Inf), ymin=c(0,0,1), ymax=rep(Inf,3)), alpha=c(0.8, 0.6, 0.4), fill=&quot;grey86&quot;) + ggplot2::annotate(geom = &quot;text&quot;, x = c(0.25, 0.6, 1.25), y = Inf, label = c(&quot;Critical&quot;, &quot;Cautious&quot;, &quot;Healthy&quot;) , color = c(&#39;white&#39;, &#39;darkgray&#39;, &#39;darkgray&#39;), size=5, angle = 270, hjust=-0.25) } NewPlot(MSEobj) "],
["using-real-indices.html", "Chapter 30 Using Real Indices", " Chapter 30 Using Real Indices Since DLMtool V5.3 real indices of abundance can be added to the Data object and used to condition the OM. Three types of real indices can provided: ‘Biomass’, ‘VBiomass’ and “SpBiomass” for total, vulnerable, and spawning biomass respectively. The type(s) of index is specified in Data@Type and the index provided as a vector of length OM@nyears in Data@RInd, or a matrix with nrow = number of indices and ncol = OM@nyears. The Data object with the real indices can be included in the operating model using the cpars slot. The information in the Data@RInd slot used in the MSE will match exactly the provided indices during the historical simulation period. The hyper-stability/depletion (beta) and observation error are calculated by comparing the real indices with the simulated indices during the historical year period and used to generate the Data@RInd in the projection period. For example, here we first generate some indices of abundance and then include those indices as real indices of abundance in the OM. First we generate three indices (total biomass, vulnerable biomass, and spawning biomass): OM &lt;- DLMtool::testOM Hist &lt;- runMSE(OM, Hist=TRUE, silent=TRUE) Bind &lt;- Hist@TSdata$B[1,] # use the first simulation as our &#39;real&#39; data Bind &lt;- Bind/mean(Bind) VBind &lt;- Hist@TSdata$VB[1,] VBind &lt;- VBind/mean(VBind) SpBInd&lt;- Hist@TSdata$SSB[1,] SpBInd &lt;- SpBInd/mean(SpBInd) Next we add these ‘real’ indices to a Data object: Data &lt;- new(&quot;Data&quot;) Data@Type &lt;- c(&quot;Biomass&quot;, &quot;VBiomass&quot;, &#39;SpBiomass&#39;) Data@RInd &lt;- array(rbind(Bind, VBind, SpBInd), dim=c(1, 3, length(Bind))) Note that Data@RInd is an array with dimensions: number of simulations (1 in this case because it is ‘real’ data), number of real indices (3 in this case), and the length of the longest index (all equal to OM@nyears in this case): dim(Data@RInd) ## [1] 1 3 50 Now we can add the Data object to our OM using the cpars slot: OM@cpars$Data &lt;- Data And run the MSE (we use the argument PPD=TRUE here to return the simulated Data object at the end of the MSE): MSE &lt;- runMSE(OM, MPs=&quot;AvC&quot;, silent=TRUE, PPD=TRUE) data &lt;- MSE@Misc$Data[[1]] # the simulated data from the first MP Note the dimensions of the RInd array in the simulated data: dim(data@RInd) ## [1] 48 3 98 The index is the same for every simulation for the historical years: all(data@RInd[1,,1:OM@nyears] == data@RInd[2,,1:OM@nyears]) ## [1] TRUE all(data@RInd[1,,1:OM@nyears] == data@RInd[OM@nsim,,1:OM@nyears]) ## [1] TRUE And identical to the real indices provided in the Data object: all(Data@RInd[1,,] == data@RInd[OM@nsim,,1:OM@nyears]) ## [1] TRUE The hyper-stability/depletion coefficient (beta), auto-correlation, standard deviation, and correlation for each simulation and index are returned as a data frame in the Misc slot: head(MSE@Misc$RInd.stats) ## Index beta ac sd cor ## 1 Biomass 0.9999971 0.8814744 6.770047e-07 1.0000000 ## 2 Biomass 0.9772490 0.5920802 1.466233e-01 0.8019266 ## 3 Biomass 0.4767877 0.4903107 1.461586e-01 0.8072193 ## 4 Biomass 1.3560009 0.6799227 1.772741e-01 0.6702492 ## 5 Biomass 0.2489784 0.5153964 1.221488e-01 0.8703264 ## 6 Biomass 1.2168390 0.5341129 1.370332e-01 0.8062220 Note that in this case there is perfect correlation for simulation 1. This is not surprising because our ‘real’ indices were generated from simulation 1 of the same OM. Low or negative correlation values indicate that the simulated trends in abundance are very different from the real indices provided in the Data object. The observation error stored in RInd.stats are used to maintain the same error structure in the projection simulations. "],
["acknowledgements.html", "A Acknowledgements", " A Acknowledgements Thanks to the many people who have alerted us to issues or bugs, provided suggestions for improvements, or asked the tricky, but important, questions that have helped us continue to develop the DLMtool. This User Guide has been developed with the bookdown package. Developers: Thomas Carruthers, University of British Columbia (UBC) Institute for the Oceans and Fisheries Adrian Hordyk, University of British Columbia (UBC) Institute for the Oceans and Fisheries Collaborators: Doug Butterworth, University of Cape Town Campbell Davies, Commonwealth Scientific and Industrial Research Organisation (CSIRO) Helena Geromont, University of Cape Town William Harford, National Oceanic and Atmospheric Administration (NOAA) Richard Hillary, Commonwealth Scientific and Industrial Research Organisation (CSIRO) Quang Huynh, Virginia Institute of Marine Science (VIMS) Laurie Kell, International Commission for the Conservation of Atlantic Tuna (ICCAT) Toshihide Kitakado, University of Tokyo Skyler Sagarese, University of Miami Rosenstiel School of Marine and Atmospheric Science (RSMAS) Liz Brooks, National Oceanic and Atmospheric Administration (NOAA) Robyn Forrest, Canadian Department of Fisheries and Oceans Chris Grandin, Canadian Department of Fisheries and Oceans California Department of Fish and Wildlife Funders: David &amp; Lucille Packard Foundation Gordon &amp; Betty Moore Foundation Kingfisher Foundation Natural Resources Defense Council Resources Legacy Fund Fisheries and Oceans, Canada (DFO) United Nations Food &amp; Agriculture Organization (FAO) "],
["references.html", "B References", " B References Beverton, R. J. H., &amp; Holt, S. J. (1957). On the dynamics of exploited fish populations. Fishery Investigation Series 2, United Kingdom Ministry of Agriculture and Fisheries, (Vol. 19). Book, London, United Kingdom. Butterworth, D. S. (2007). Why a management procedure approach? Some positives and negatives. ICES Journal of Marine Science: Journal Du Conseil, 64(1995), 613–617. Costello, C., Ovando, D., Hilborn, R., Gaines, S. D., Deschenes, O., &amp; Lester, S. E. (2012). Status and solutions for the world’s unassessed fisheries. Science, 338, 517–520. Lorenzen, K. (1996), The relationship between body weight and natural mortality in juvenile and adult fish: a comparison of natural ecosystems and aquaculture. Journal of Fish Biology, 49: 627–642 Newman, D., Berkson, J., &amp; Suatoni, L. (2015). Current methods for setting catch limits for data-limited fish stocks in the United States. Fisheries Research, 164, 86–93. Punt, A. E. (2015). Strategic management decision-making in a complex world: quantifying, understanding, and using trade-offs. ICES Journal of Marine Science, (fsv193), 12. Punt, A. E., Butterworth, D. S., de Moor, C. L., De Oliveira, J. A. A., &amp; Haddon, M. (2014). Management strategy evaluation: best practices. Fish and Fisheries. Restrepo, V., Thompson, G. G., Mace, P., Gabriel, W., Low, L., MacCall, A., Methot, R.D., Powers, J.E., Taylor, B., Wade, P.R., &amp; Witzig, J. (1998). Guidance on the use of precautionary approaches to implementing National Standard 1 of the Magnuson-Stevens Fishery Conservation and Management. NOAA Technical Memorandum. Walters, C. J., &amp; Martell, S. J. D. (2004). Fisheries ecology and management. Book, Princeton, USA: Princeton University Press. "],
["getting-help.html", "C Getting Help C.1 First Time Working With R? C.2 Installing the DLMtool Package C.3 A Brief Note on S4 Methods C.4 Additional Help on the DLMtool C.5 Questions on R-related Problems", " C Getting Help C.1 First Time Working With R? This section is designed for first-time users of the DLMtool, or users who may not have a lot of experience with R. You should be able to skip this section if you are familiar with R and RStudio, installing new R packages, and entering R commands into the R console. To get started with the DLMtool you will need at least two things: A current version of the R software installed on your machine. The latest version of the DLMtool package. The R Software The R software can be freely downloaded from the CRAN website and is available for all operating systems. Updated versions of R are released frequently, and it is recommended that you have the latest version installed. If you are using Windows OS, you can uses the installr package and the updateR() function to update and install the latest version. Alternatively, head to the CRAN website to download the latest version of R. RStudio RStudio is a freely available integrated development environment (IDE) for R. It is not essential that you use RStudio, but it can make things a lot easier, especially if you are new to R. This User Guide assumes that you are using RStudio to operate the DLMtool. It is important to be aware that RStudio and R are two different pieces of software that must be installed separately. We recommend installing the R software before downloading and installing RStudio. C.2 Installing the DLMtool Package If this is the first time you are using DLMtool, you will need to install the DLMtool package from CRAN. Installing DLMtool Using R Console This can be done by running the command: install.packages(&quot;DLMtool&quot;) A prompt may appear asking you to select a CRAN mirror. It is best to pick the mirror that is the closest geographical distance. Installing DLMtool Using RStudio An alternative method to install the DLMtool package is to click the Packages tab in the lower right panel in RStudio, and click Install. Check that Repository (CRAN, CRANextra) is selected in the Install from: drop-down menu, type DLMtool into the packages dialog box, and click Install. The DLMtool package relies on a number of other R packages, which the installation process will automatically install. The number of packages that are installed, and the time it takes, will depend on what packages you already have installed on your system (and your download speed). Updating the DLMtool Package You will only need to install the DLMtool package once. However, the DLMtool package is updated from time to time, and you will need to re-install from CRAN for each new version. This can be done by using the update.packages command: update.packages(&quot;DLMtool&quot;) Loading the DLMtool Package Once installed, the DLMtool package can be loaded into R by typing in the command line: library(DLMtool) or locating the DLMtool package in the list of packages in RStudio and checking the box. C.3 A Brief Note on S4 Methods The core functions of DLMtool are S4 Classes. Many R users may not have worked with S4 methods before. R has three different object oriented (OO) systems, the most common of which is known as S3. S3 is known as a generic-function OO, and is a casual system with no formal definition of classes. S4 works similar to S3, but is more formal and uses classes with a more rigid definition. It is not essential to understand the difference between S3 and S4, or why one is preferred over the other, to use the DLMtool. The most important thing that you need to know how to access the information in S4 classes. If you have work with R in the past, you are probably familiar with using the $ symbol to access elements in a data frame or list. S4 classes contain a named list of slots which are analogous to a standard R list. However, the slots in a S4 class differ in two important ways: The type of content in each slot (e.g., character, numeric, matrix) is determined in the class definition, and cannot be changed. In other words, you are not able to put content of class character into a slot that is expecting information of class numeric. This is what is meant by the S4 system being more strict than S3. The slots are accessed with the @ symbol. This is essentially the same as the $ symbol in S3 classes. You will see examples of this throughout the User Guide. The main thing to note here is that when you see the @ symbol being used, it refers to some particular information (a slot) being accessed from a larger collection of data (the object). For further information on the S3 and S4 systems see Advanced R. C.4 Additional Help on the DLMtool This User Guide aims to explain the workings of the DLMtool, and address the most common questions and issues associated with the package. Additional help material for the DLMtool package and functions can be obtained in the usual way: help(DLMtool) Documentation for each function can be obtained by typing a ? symbol followed by the function name. For example: ?runMSE Information on the DLMtool classes can be found by first typing class followed by the ? symbol and the class name. For example: class?Data You can access this user guide at any time from the R console: userguide() C.5 Questions on R-related Problems Although the User Guide attempts to address the most common issues, undoubtedly there will be times where you have problems with your R code. R has a somewhat annoying habit of returning cryptic error messages, that are sometimes indecipherable, especially to those who are new to the software. Most coding problems with the R language are the result of a missing parenthesis, an extra or missing comma or quotation mark, or some other minor typo that stops your code from running. There are a number of resources available on the Internet that are devoted to dealing with questions and problems with R programming. StackOverflow is great place to start searching for answers to your R-related problems. There is a high chance that in the past someone has posted the exact question that you are dealing with, and one or several kind souls have provided helpful solutions. If not, you can post your own question. But be aware, the StackOverflow community is made up entirely of people who volunteer their time to help others, and they sometimes have little patience for questions that don’t demonstrate a proper search for already posted answers to the problem. "],
["assumptions-of-dlmtool.html", "D Assumptions of DLMtool D.1 Biology D.2 MSE Model Assumptions D.3 Management Procedures D.4 Data and Method Application D.5 Calculating Reference Points", " D Assumptions of DLMtool Like all models, DLMtool is a simplication of reality. In order to approximate real fishery dynamics, DLMtool relies on a number of simplifying assumptions. Some of these assumptions are common to many fishery science models (e.g., age-structured population dynamics) and are a central to the structure of DLMtool. Other assumptions are a result of the way DLMtool was designed and developed, and may represent limitations of DLMtool for applications to particular situations. It may be possible to deal with some of these assumptions by further development of DLMtool. D.1 Biology Short-Lived Species Due to the problems with approximating fine-scale temporal dynamics with an annual model it is not advised to use the DLMtool for very short lived stocks (i.e., species with a longevity of 5 years or less). Technically, you could just divide all temporal parameters by a subyear resolution, but the TAC would be set by sub year and the data would also be available at this fine-scale which is highly unlikely in a data-limited setting. A MSE model with monthly or weekly time-steps for the population dynamics is required for short-lived species, and may be developed in the future. Density-Dependent Compensation DLMtool assumes that, with the exception of the stock-recruitment relationship, there is no density-dependent compensation in the population dynamics, and fish growth, maturity, and mortality does not change directly in response to changes in stock size. von Bertalanffy Growth Growth model in DLMtool is modelled using the von Bertalanffy growth curve. While this is the most commonly applied model to describe fish growth, it may not be the preferred growth model for some species. The consequences of assuming the von Bertalanffy growth model should be considered when using the DLMtool for species with alternative growth patterns. Since DLMtool V4.4 it is possible to use alternative length-at-age models by using cpars. See the Custom Parameters chapter for more information. Natural Mortality Rate at Age By default DLMtool assumes that natural mortality (M) is constant with age and size. Since DLMtool V4.4 size or age-specific M can be specified. See the Size-Specific Natural Mortality chapter for more information. D.2 MSE Model Assumptions Retention and Selectivity The OM has slots for both gear selectivity and retention by size. If the retention slots are not populated, it is assumed that retention = selectivity, that is, all fish that are captured by the gear are retained by the fishers. Most size-regulation MPs (e.g., matlenlim) change the retention pattern and leave the selectivity pattern unchanged. For example, if a size limited is regulated well above the current size of selection, fish smaller than the size limit are still caught by the gear but are discarded and may suffer some fishing mortality (Stock@Fdisc). MPs can be designed to modify gear selectivity instead of, or in addition to, the retention-at-size. Non-Convergence of Management Procedure In some cases during the MSE Management Procedure may not be able to successfully calculate a management recommendation from the simulated data. For example, a catch-curve may used to estimate \\(Z\\), and \\(F\\) is calculated as \\(F=Z-M\\). Because of process and observation error, it is possible that the estimated \\(F\\) is negative, in which case the MP may fail to calculate a recommended catch limit. The Management Procedures have been designed to return NA if they fail to calculate a management recommendation for any reason. In this case, the management recommendations from the previous year are used in the simulation, e.g., \\(\\text{TAC}_y = \\text{TAC}_{y-1}\\). Idealised Observation Models for Catch Composition Data Currently, DLMtool simulates catch-composition data from the true simulated catch composition data via a multinomial distribution and some effective sample size. This observation model may be unrealistically well-behaved and favour those approaches that use these data. We are considering adding a growth-type-group model to improve the realism of simulated length composition data. Two-Box Model DLMtool uses a two-box spatial model and assumes homogeneous fishing, and distribution of the fish stock. That is, growth and other life-history characteristics do not vary across the two spatial areas. Spatial targeting of the fishing fleet is currently being developed in the model. Ontogenetic Habitat Shifts Since the operating model simulates two areas, it is possible to prescribe a log-linear model that moves fish from one area to the other as they grow older. This could be used to simulate the ontogenetic shift of groupers from near shore waters to offshore reefs. Currently this feature is in development. Closed System DLMtool assumes that the population being modelled is in a closed system. There is no immigration or emigration, and a unit stock is assumed to be represented in the model and impacted by the management decisions. This assumption may be violated where the stock extends across management jurisdictions. Violations of this assumption may impact the interpretation of the MSE results, and these implications should be considered when applying DLMtool. Although a unit stock is a central assumption of many modeling and assessment approaches, it may be possible to further develop DLMtool to account for stocks that cross management boundaries. D.3 Management Procedures Harvest Control Rules Must be Integrated into Data-Limited MPs In this version of DLMtool, harvest control rules (e.g. the 40-10 rule) must be written into a data-limited MP. There is currently no ability to do a factorial comparison of say 4 harvest controls rules against 3 MPs (the user must describe all 12 combinations). The reason for this is that it would require further subclasses. For example the 40-10 rule may be appropriate for the output of DBSRA but it would not be appropriate for some of the simple management procedures such as DynF that already incorporate throttling of TAC recommendations according to stock depletion. D.4 Data and Method Application Data Assumed to be Representative The MSE model accounts for observation error in the simulated fishery data. However, the application of management procedures for management advice assumes that the provided fishery data is representative of the fishery and is the best available information on the stock. Processing of fishery data should take place before entering the data into the fishery data tables, and assumptions of the management procedures should be carefully evaluated when applying methods using DLMtool. D.5 Calculating Reference Points Biological reference points are used to initialize the simulations (e.g. Depletion) and evaluate the performance of management procedures (e.g., \\(B/B_{MSY}\\), \\(B/B_0\\), etc). Although these terms are used frequently, the definition of biological reference points can be ambiguous, and there may be multiple ways of defining or interpreting them. This is especially true when life-history and fishing parameters vary over time. Here we describe how the biological reference points are defined and calculated in DLMtool. Depletion and Unfished Reference Points The Depletion parameter in the Stock Object (Stock@D) is used to initialize the historical simulations. Although the term Depletion is used frequently in fisheries science, it is rarely clearly defined. In most contexts, Depletion is used to mean the biomass today relative to the average unfished biomass. This raises two questions: What do we mean by biomass? Is it total biomass (B), vulnerable biomass (VB), or spawning biomass (SB)? What do we mean by average unfished biomass? Average over what time-period? Does this refer to the average biomass at some time in history before fishing commenced? Or is the expected biomass today if the stock had not been fished? Examples can be found for all three definitions of biomass in the first question. We define Depletion with respect to spawning biomass (SB). That is, the values specified in Stock@D refer to the spawning biomass in the last historical year (i.e. ‘today’; \\(SB_{y=\\text{OM@nyears}}^{\\text{unfished}}\\)) relative to the average unfished spawning biomass \\((SB_0)\\). The answer to the second question is a little more complicated. There are several ways to define \\(SB_0\\) within the simulation model: The unfished spawning biomass at the beginning of the simulations (i.e Year = 1). The unfished spawning biomass at the end of the historical simulations (i.e Year = OM@nyears). The average unfished spawning biomass over the first several years of the simulations. This could be different to 1 due to inter-annual variability in life-history parameters (e.g, Stock@Linfsd). The average unfished spawning biomass over all historical years (or the last several years). This could be different to 3 due to time-varying trends in parameters (e.g., by using OM@cpars$Linfarray). In DLMtool the operating model is specified based on the assumed or estimated spawning biomass today relative to the average equilibrium (i.e no process error in recruitment) biomass at the beginning of the fishery; i.e., the change in biomass over the history of the fishery (point 3 above). We use the age of 50% maturity (\\(A_{50}\\) in the first historical year; calculated internally from Stock@Linf, Stock@Linfsd, Stock@K, Stock@Ksd, Stock@t0, and Stock@L50) as an approximation of generation time, and calculate the average unfished spawning biomass \\((SB_0)\\) over the first \\(A_{50}\\) years in the historical simulations. That is: \\[ SB_0 = \\frac{\\sum_{y=1}^{A_{50}} SB_y^{\\text{unfished}}}{A_{50}} \\] where \\(A_{50}\\) is rounded up to the nearest integer and \\(SB_y^{\\text{unfished}}\\) is the equilibrium unfished spawning biomass in year \\(y\\). The same calculation is used to calculate other unfished reference points (e.g, \\(B_0\\), \\(VB_0\\)), as well as the unfished spawning-per-recruit parameters used in the Ricker stock-recruitment relationship. The unfished reference points and unfished biomass and numbers by year are returned as a list in the MSE and Hist objects; i.e MSE@Misc$Unfished$Refs and `MSE@Misc$Unfished$ByYear respectively. Note Note that although Depletion is calculated relative to the average unfished equilibrium spawning biomass, the population in the simulation model is initialized under dynamic conditions, that is, with process error in recruitment to all age classes. This means that, depending on the magnitude of recruitment variability, the initial biomass in Year 1 may be quite different to the equilibrium unfished biomass as calculated above. D.5.1 Initial Depletion As noted above, the operating model initializes the population in an unfished dynamic state. Since DLMtool version 5.3 it is possible specify depletion in the first historical year by using OM@cpars$initD. When this feature is used, the population is initialized in a dynamic state with spawning biomass equal to \\(\\text{initD} * SB_0\\); that is, initial spawning biomass in Year 1 is relative to the unfished spawning biomass in Year 1. Analysts need to be aware that if there are large time-varying trends in life-history parameters, the \\(SB_0\\) in Year 1, which is no longer the first year that the fishery commenced, may be different to the \\(SB_0\\) from the (not modeled) period before fishing. D.5.2 MSY Reference Points The calculation of maximum sustainable yield (MSY) and related reference points are also impacted by inter-annual variability in life-history and fishing parameters (i.e., selectivity pattern). For example, if there is large inter-annual variability in natural mortality or growth, MSY and \\(B_{\\text{MSY}}\\) may vary significantly between years. We calculate MSY and related metrics (e.g., \\(B_{\\text{MSY}}\\)) for each time-step in the model based on the life-history and fishing parameters in that year. The MSY reference points are used in both the simulated Data object, and to evaluate the performance of the management procedures. For the simulated Data object, we calculate MSY reference points following a similar procedure to that described above for \\(B_0\\). We use \\(A_{50}\\) as an approximation of generation time, and average the annual MSY values over \\(A_{50}\\) years around the last historical year. For example, if OM@nyears = 50 and \\(A_{50}=5\\), \\(SB_{\\text{MSY}}\\) is calculated as: \\[ SB_{\\text{MSY}} = \\sum_{y=48}^{52}{SB_y^{\\text{MSY}}} \\] where \\(SB_y^{\\text{MSY}}\\) is the spawning biomass corresponding with maximum sustainable yield in year \\(y\\). The logic behind this is, if estimates of MSY, \\(B_\\text{MSY}\\), etc are available, they are likely calculated based on current life-history information, which would be estimated from data spanning several age classes. The MSY reference points in the Data object are not updated in the future projection years. The MSY reference points and MSY values by year are returned in MSE@Misc$MSYRefs. Note In DLMtool the MSY metrics are always calculated by year. The slot MSE@B_BMSY returns the spawning biomass in the projections divided by \\(SB_\\text{MSY}\\) in each year of the projections. For alternative methods to calculate \\(B/B_{\\text{MSY}}\\), such as relative to the constant \\(B_\\text{MSY}\\) described above, use MSE@SSB or MSE@B and the data stored in MSE@Misc$MSYRefs. D.5.3 Setting Depletion at a fraction of BMSY Relative reference points such as \\(\\frac{B_\\text{MSY}}{B_0}\\), and \\(\\frac{SB_\\text{MSY}}{SB_0}\\) are calculated relative to the unfished biomass described in the previous section. This means that it is relatively straightforward to initialize the simulation model at a fraction of \\(B_\\text{MSY}\\) rather than \\(B_0\\). For example, suppose you wish to set the depletion in the final historical year at \\(0.5SB_\\text{MSY}\\): library(DLMtool) OM &lt;- testOM; OM@nsim &lt;- 2 OM@cpars$D &lt;- runif(OM@nsim, OM@D[1], OM@D[2]) # need to populate OM@cpars$D so that random samples are the same Hist &lt;- runMSE(OM, Hist=TRUE, silent=TRUE) OM@cpars$D &lt;- 0.5 * Hist@Ref$SSBMSY_SSB0 # update Depletion to 0.5 BMSY using cpars Hist &lt;- runMSE(OM, Hist=TRUE, silent=TRUE) matplot(t(Hist@TSdata$SSB/Hist@Ref$SSBMSY), type=&quot;l&quot;, ylim=c(0,3), ylab=&quot;B/BMSY&quot;, xlab=&quot;Historical Years&quot;, bty=&quot;l&quot;) abline(h=0.5, lty=2, col=&quot;gray&quot;) "],
["changes.html", "E Changes", " E Changes Important changes - DLMtool V4.1 and greater DLMtool V4.1 introduced some important changes to the Operating Model object. The number of simulations (nsim) and the number of projection years (proyears) are now slots in the OM object, rather than arguments to runMSE (see Management Strategy Evaluation). This change was required to allow users to specify their own custom futures for parameters like M, growth, etc. The OM object also now has a new random seed slot in the operating model, which ensures that the MSE results are now exactly reproducible. You can modify the number of simulations, the number of projection years, or the value of the random seed by modifiying the relevant slots in the OM object: OM@nsim OM@proyears OM@seed Important changes - DLMtool V4.5 and greater Since DLMtool V5.0 the following slots have been added to the OM object: OM@interval OM@pstar OM@maxF OM@reps This was done so that an OM object is completely self-contained and includes all information used in the MSE. "]
]
